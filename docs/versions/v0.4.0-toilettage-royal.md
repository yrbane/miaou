# üê± Version 0.4.0 "Toilettage Royal"
## *Quand l'√©l√©gance rencontre l'ergonomie*

> **Phase 4 : Interfaces utilisateur** - Exp√©rience utilisateur moderne et accessible

---

## üéØ Vision de cette version

Le **Toilettage Royal** transforme Miaou d'un outil technique en une exp√©rience utilisateur raffin√©e et accessible. Comme un chat qui fait sa toilette avec minutie pour para√Ætre au mieux de sa forme, cette version polit chaque aspect de l'interface pour cr√©er une exp√©rience digne des plus grandes messageries, mais en d√©centralis√©.

**Motto :** *"L'√©l√©gance technique au service de l'humain"*

---

## üñ•Ô∏è Application Desktop Native (Tauri)

### **Architecture Tauri moderne**
```rust
// src-tauri/src/main.rs
use tauri::{CustomMenuItem, Menu, MenuItem, Submenu, WindowBuilder, WindowUrl};
use tauri::api::notification::Notification;

#[tauri::command]
async fn send_message(
    peer_id: String, 
    content: String,
    app_handle: tauri::AppHandle
) -> Result<String, String> {
    let miaou_core = app_handle.state::<MiaouCore>();
    
    match miaou_core.messaging.send_message(&peer_id, &content).await {
        Ok(message_id) => {
            // Notification syst√®me
            Notification::new(&app_handle.config().tauri.bundle.identifier)
                .title("Message envoy√©")
                .body(&format!("Message envoy√© √† {}", peer_id))
                .icon("message-sent")
                .show()?;
            
            Ok(message_id.to_string())
        },
        Err(e) => Err(format!("Erreur envoi: {}", e))
    }
}

#[tauri::command]
async fn get_peer_list(app_handle: tauri::AppHandle) -> Result<Vec<PeerInfo>, String> {
    let miaou_core = app_handle.state::<MiaouCore>();
    
    let peers = miaou_core.network.get_connected_peers().await
        .map_err(|e| format!("Erreur r√©cup√©ration pairs: {}", e))?;
    
    Ok(peers.into_iter().map(|p| PeerInfo {
        id: p.id.to_string(),
        display_name: p.display_name.unwrap_or("Utilisateur anonyme".to_string()),
        status: match p.connection_state {
            ConnectionState::Connected => "En ligne".to_string(),
            ConnectionState::Connecting => "Connexion...".to_string(),
            ConnectionState::Disconnected => "Hors ligne".to_string(),
        },
        last_seen: p.last_seen.map(|t| t.timestamp()),
        unread_count: p.unread_messages,
    }).collect())
}

#[tauri::command]
async fn get_conversation_history(
    peer_id: String,
    limit: Option<usize>,
    app_handle: tauri::AppHandle
) -> Result<Vec<MessageInfo>, String> {
    let miaou_core = app_handle.state::<MiaouCore>();
    
    let messages = miaou_core.messaging.get_conversation_history(
        &peer_id,
        limit.unwrap_or(50)
    ).await.map_err(|e| format!("Erreur historique: {}", e))?;
    
    Ok(messages.into_iter().map(|m| MessageInfo {
        id: m.id.to_string(),
        sender_id: m.sender.to_string(),
        content: m.content,
        timestamp: m.timestamp.timestamp(),
        message_type: format!("{:?}", m.message_type),
        delivery_status: format!("{:?}", m.delivery_status),
    }).collect())
}

fn create_menu() -> Menu {
    let quit = CustomMenuItem::new("quit".to_string(), "Quitter");
    let about = CustomMenuItem::new("about".to_string(), "√Ä propos");
    let new_conversation = CustomMenuItem::new("new_conversation".to_string(), "Nouvelle conversation");
    let settings = CustomMenuItem::new("settings".to_string(), "Pr√©f√©rences");
    
    let app_menu = Submenu::new("Miaou", Menu::new()
        .add_item(about)
        .add_native_item(MenuItem::Separator)
        .add_item(settings)
        .add_native_item(MenuItem::Separator)
        .add_item(quit));
    
    let file_menu = Submenu::new("Fichier", Menu::new()
        .add_item(new_conversation));
    
    Menu::new()
        .add_submenu(app_menu)
        .add_submenu(file_menu)
}

fn main() {
    tauri::Builder::default()
        .menu(create_menu())
        .manage(MiaouCore::new())
        .invoke_handler(tauri::generate_handler![
            send_message,
            get_peer_list,
            get_conversation_history,
            connect_to_peer,
            disconnect_from_peer,
            get_profile_info,
            update_profile,
            get_network_status,
            export_conversations,
            import_conversations
        ])
        .setup(|app| {
            // Configuration fen√™tre principale
            let main_window = WindowBuilder::new(
                app,
                "main",
                WindowUrl::App("index.html".into())
            )
            .title("Miaou - Messagerie D√©centralis√©e")
            .inner_size(1200.0, 800.0)
            .min_inner_size(800.0, 600.0)
            .center()
            .build()?;
            
            // Configuration th√®me selon pr√©f√©rences syst√®me
            main_window.set_theme(Some(match app.get_cli_config().theme {
                Some(theme) => match theme.as_str() {
                    "dark" => tauri::Theme::Dark,
                    "light" => tauri::Theme::Light,
                    _ => app.theme().unwrap_or(tauri::Theme::Light),
                },
                None => app.theme().unwrap_or(tauri::Theme::Light),
            }));
            
            Ok(())
        })
        .on_menu_event(|event| {
            match event.menu_item_id() {
                "quit" => {
                    std::process::exit(0);
                },
                "about" => {
                    // Ouvrir dialog √† propos
                },
                "new_conversation" => {
                    // Ouvrir dialog nouvelle conversation
                },
                "settings" => {
                    // Ouvrir fen√™tre pr√©f√©rences
                },
                _ => {}
            }
        })
        .run(tauri::generate_context!())
        .expect("Erreur d√©marrage application Tauri");
}
```

### **Interface frontend moderne (React + TypeScript)**
```typescript
// src/App.tsx
import React, { useEffect, useState } from 'react';
import { invoke } from '@tauri-apps/api/tauri';
import { listen } from '@tauri-apps/api/event';
import { Layout } from './components/Layout';
import { ConversationList } from './components/ConversationList';
import { ChatView } from './components/ChatView';
import { StatusBar } from './components/StatusBar';
import { NotificationManager } from './components/NotificationManager';
import { ThemeProvider } from './contexts/ThemeContext';
import { MiaouProvider } from './contexts/MiaouContext';
import './App.css';

interface PeerInfo {
  id: string;
  display_name: string;
  status: string;
  last_seen?: number;
  unread_count: number;
}

interface MessageInfo {
  id: string;
  sender_id: string;
  content: string;
  timestamp: number;
  message_type: string;
  delivery_status: string;
}

function App() {
  const [peers, setPeers] = useState<PeerInfo[]>([]);
  const [selectedPeer, setSelectedPeer] = useState<string | null>(null);
  const [messages, setMessages] = useState<MessageInfo[]>([]);
  const [networkStatus, setNetworkStatus] = useState<'connecting' | 'connected' | 'disconnected'>('connecting');

  useEffect(() => {
    // Charger la liste initiale des pairs
    loadPeers();
    
    // √âcouter les √©v√©nements temps r√©el
    const unlistenNewMessage = listen('new-message', (event) => {
      const newMessage = event.payload as MessageInfo;
      if (newMessage.sender_id === selectedPeer || newMessage.sender_id === 'local') {
        setMessages(prev => [...prev, newMessage]);
      }
      
      // Mettre √† jour le compteur non-lu
      setPeers(prev => prev.map(peer => 
        peer.id === newMessage.sender_id 
          ? { ...peer, unread_count: peer.unread_count + 1 }
          : peer
      ));
    });
    
    const unlistenPeerStatusChange = listen('peer-status-changed', (event) => {
      const { peer_id, status } = event.payload as { peer_id: string, status: string };
      setPeers(prev => prev.map(peer => 
        peer.id === peer_id 
          ? { ...peer, status }
          : peer
      ));
    });
    
    const unlistenNetworkStatus = listen('network-status-changed', (event) => {
      setNetworkStatus(event.payload as any);
    });
    
    return () => {
      unlistenNewMessage.then(fn => fn());
      unlistenPeerStatusChange.then(fn => fn());
      unlistenNetworkStatus.then(fn => fn());
    };
  }, [selectedPeer]);

  const loadPeers = async () => {
    try {
      const peerList = await invoke<PeerInfo[]>('get_peer_list');
      setPeers(peerList);
    } catch (error) {
      console.error('Erreur chargement pairs:', error);
    }
  };

  const loadConversation = async (peerId: string) => {
    try {
      setSelectedPeer(peerId);
      const conversation = await invoke<MessageInfo[]>('get_conversation_history', {
        peerId,
        limit: 100
      });
      setMessages(conversation);
      
      // Marquer comme lu
      setPeers(prev => prev.map(peer => 
        peer.id === peerId 
          ? { ...peer, unread_count: 0 }
          : peer
      ));
    } catch (error) {
      console.error('Erreur chargement conversation:', error);
    }
  };

  const sendMessage = async (content: string) => {
    if (!selectedPeer || !content.trim()) return;
    
    try {
      await invoke('send_message', {
        peerId: selectedPeer,
        content: content.trim()
      });
      
      // Le message sera ajout√© automatiquement via l'√©v√©nement
    } catch (error) {
      console.error('Erreur envoi message:', error);
      // Afficher notification d'erreur
    }
  };

  return (
    <ThemeProvider>
      <MiaouProvider>
        <div className="app">
          <Layout>
            <div className="main-content">
              <ConversationList
                peers={peers}
                selectedPeer={selectedPeer}
                onSelectPeer={loadConversation}
                onRefresh={loadPeers}
              />
              
              <ChatView
                selectedPeer={selectedPeer}
                messages={messages}
                onSendMessage={sendMessage}
                peers={peers}
              />
            </div>
            
            <StatusBar networkStatus={networkStatus} />
          </Layout>
          
          <NotificationManager />
        </div>
      </MiaouProvider>
    </ThemeProvider>
  );
}

export default App;
```

### **Composants UI modernes**
```typescript
// src/components/ChatView.tsx
import React, { useState, useRef, useEffect } from 'react';
import { formatDistanceToNow } from 'date-fns';
import { fr } from 'date-fns/locale';
import { EmojiPicker } from './EmojiPicker';
import { MessageBubble } from './MessageBubble';
import { TypingIndicator } from './TypingIndicator';
import './ChatView.css';

interface ChatViewProps {
  selectedPeer: string | null;
  messages: MessageInfo[];
  onSendMessage: (content: string) => void;
  peers: PeerInfo[];
}

export const ChatView: React.FC<ChatViewProps> = ({
  selectedPeer,
  messages,
  onSendMessage,
  peers
}) => {
  const [messageInput, setMessageInput] = useState('');
  const [showEmojiPicker, setShowEmojiPicker] = useState(false);
  const [isTyping, setIsTyping] = useState(false);
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLTextAreaElement>(null);

  const selectedPeerInfo = peers.find(p => p.id === selectedPeer);

  useEffect(() => {
    // Auto-scroll vers le bas quand nouveaux messages
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  useEffect(() => {
    // Focus automatique sur l'input
    if (selectedPeer && inputRef.current) {
      inputRef.current.focus();
    }
  }, [selectedPeer]);

  const handleSendMessage = () => {
    if (messageInput.trim()) {
      onSendMessage(messageInput);
      setMessageInput('');
      setShowEmojiPicker(false);
    }
  };

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSendMessage();
    }
  };

  const handleEmojiSelect = (emoji: string) => {
    setMessageInput(prev => prev + emoji);
    setShowEmojiPicker(false);
    inputRef.current?.focus();
  };

  if (!selectedPeer) {
    return (
      <div className="chat-view-empty">
        <div className="empty-state">
          <div className="empty-icon">üí¨</div>
          <h3>S√©lectionnez une conversation</h3>
          <p>Choisissez un contact pour commencer √† discuter de mani√®re s√©curis√©e</p>
        </div>
      </div>
    );
  }

  return (
    <div className="chat-view">
      <div className="chat-header">
        <div className="peer-info">
          <div className="peer-avatar">
            <img 
              src={`https://api.dicebear.com/6.x/cats/svg?seed=${selectedPeer}`}
              alt={selectedPeerInfo?.display_name}
            />
            <div className={`status-indicator ${selectedPeerInfo?.status === 'En ligne' ? 'online' : 'offline'}`} />
          </div>
          <div className="peer-details">
            <h3>{selectedPeerInfo?.display_name || 'Utilisateur anonyme'}</h3>
            <span className="peer-status">
              {selectedPeerInfo?.status === 'En ligne' 
                ? 'En ligne'
                : selectedPeerInfo?.last_seen 
                  ? `Vu ${formatDistanceToNow(new Date(selectedPeerInfo.last_seen * 1000), { locale: fr, addSuffix: true })}`
                  : 'Hors ligne'
              }
            </span>
          </div>
        </div>
        
        <div className="chat-actions">
          <button className="action-btn" title="Appel audio" disabled>
            üìû
          </button>
          <button className="action-btn" title="Appel vid√©o" disabled>
            üìπ
          </button>
          <button className="action-btn" title="Options">
            ‚öôÔ∏è
          </button>
        </div>
      </div>

      <div className="messages-container">
        <div className="messages-list">
          {messages.map((message, index) => (
            <MessageBubble
              key={message.id}
              message={message}
              isOwn={message.sender_id === 'local'}
              showAvatar={
                index === 0 || 
                messages[index - 1]?.sender_id !== message.sender_id
              }
              peer={selectedPeerInfo}
            />
          ))}
          
          {isTyping && <TypingIndicator />}
          
          <div ref={messagesEndRef} />
        </div>
      </div>

      <div className="message-input-container">
        <div className="message-input-area">
          <button 
            className="emoji-btn"
            onClick={() => setShowEmojiPicker(!showEmojiPicker)}
            title="√âmojis"
          >
            üòÄ
          </button>
          
          <textarea
            ref={inputRef}
            value={messageInput}
            onChange={(e) => setMessageInput(e.target.value)}
            onKeyPress={handleKeyPress}
            placeholder="Tapez votre message..."
            className="message-input"
            rows={1}
            maxLength={4000}
          />
          
          <button
            className="send-btn"
            onClick={handleSendMessage}
            disabled={!messageInput.trim()}
            title="Envoyer (Entr√©e)"
          >
            üì§
          </button>
        </div>
        
        {showEmojiPicker && (
          <EmojiPicker
            onEmojiSelect={handleEmojiSelect}
            onClose={() => setShowEmojiPicker(false)}
          />
        )}
        
        <div className="message-tools">
          <span className="char-counter">
            {messageInput.length}/4000
          </span>
          <span className="encryption-indicator" title="Messages chiffr√©s de bout en bout">
            üîê Chiffr√©
          </span>
        </div>
      </div>
    </div>
  );
};
```

---

## üì± Applications Mobiles Natives (Android/iOS)

### **Architecture mobile unifi√©e**

Les applications mobiles Miaou utilisent une architecture Rust native avec des bindings sp√©cifiques √† chaque plateforme, garantissant performance maximale et int√©gration syst√®me profonde.

```rust
// src/mobile.rs - Interface commune mobile
use crate::{PlatformInterface, core::MiaouCore};

pub struct MobilePlatform {
    core: MiaouCore,
    platform_name: &'static str,
    native_integration: Box<dyn NativeIntegration>,
}

pub trait NativeIntegration: Send + Sync {
    fn initialize_platform(&mut self) -> Result<(), String>;
    fn request_permissions(&self) -> Result<PermissionSet, String>;
    fn setup_notifications(&self) -> Result<(), String>;
    fn integrate_contacts(&self) -> Result<ContactManager, String>;
    fn setup_background_sync(&self) -> Result<(), String>;
}
```

### **Application Android (JNI)**

```kotlin
// android/app/src/main/java/net/nethttp/miaou/MainActivity.kt
package net.nethttp.miaou

import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp

class MainActivity : ComponentActivity() {
    private external fun nativeInitialize(): Boolean
    private external fun nativeSendMessage(peerId: String, content: String): String
    private external fun nativeGetPeers(): Array<String>
    private external fun nativeGetMessages(peerId: String): Array<String>

    companion object {
        init {
            System.loadLibrary("miaou")
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        // Initialisation du moteur Rust
        if (!nativeInitialize()) {
            throw RuntimeException("√âchec d'initialisation du moteur Miaou")
        }

        setContent {
            MiaouTheme {
                MiaouApp(
                    onSendMessage = { peerId, content ->
                        nativeSendMessage(peerId, content)
                    },
                    onLoadPeers = { nativeGetPeers().toList() },
                    onLoadMessages = { peerId -> nativeGetMessages(peerId).toList() }
                )
            }
        }
    }
}

@Composable
fun MiaouApp(
    onSendMessage: (String, String) -> String,
    onLoadPeers: () -> List<String>,
    onLoadMessages: (String) -> List<String>
) {
    var selectedPeerId by remember { mutableStateOf<String?>(null) }
    val peers = remember { mutableStateListOf<String>() }
    val messages = remember { mutableStateListOf<String>() }

    LaunchedEffect(Unit) {
        peers.addAll(onLoadPeers())
    }

    LaunchedEffect(selectedPeerId) {
        selectedPeerId?.let { peerId ->
            messages.clear()
            messages.addAll(onLoadMessages(peerId))
        }
    }

    Row(modifier = Modifier.fillMaxSize()) {
        // Liste des conversations
        LazyColumn(
            modifier = Modifier
                .weight(1f)
                .fillMaxHeight()
        ) {
            items(peers) { peer ->
                ConversationItem(
                    peerName = peer,
                    onClick = { selectedPeerId = peer },
                    isSelected = selectedPeerId == peer
                )
            }
        }

        // Vue des messages
        selectedPeerId?.let { peerId ->
            Column(
                modifier = Modifier
                    .weight(2f)
                    .fillMaxHeight()
            ) {
                LazyColumn(
                    modifier = Modifier.weight(1f)
                ) {
                    items(messages) { message ->
                        MessageItem(content = message)
                    }
                }

                MessageComposer(
                    onSendMessage = { content ->
                        onSendMessage(peerId, content)
                        messages.add("Moi: $content")
                    }
                )
            }
        }
    }
}
```

### **Application iOS (SwiftUI)**

```swift
// ios/Miaou/ContentView.swift
import SwiftUI
import Foundation

struct ContentView: View {
    @State private var peers: [String] = []
    @State private var selectedPeer: String?
    @State private var messages: [String] = []
    @State private var newMessage = ""
    
    var body: some View {
        NavigationView {
            // Liste des conversations
            List(peers, id: \.self) { peer in
                ConversationRow(
                    peerName: peer,
                    isSelected: selectedPeer == peer
                )
                .onTapGesture {
                    selectedPeer = peer
                    loadMessages(for: peer)
                }
            }
            .navigationTitle("Conversations")
            .onAppear {
                initializeMiaou()
                loadPeers()
            }
            
            // Vue des messages
            if let selectedPeer = selectedPeer {
                VStack {
                    List(messages, id: \.self) { message in
                        MessageRow(content: message)
                    }
                    
                    HStack {
                        TextField("Message...", text: $newMessage)
                            .textFieldStyle(RoundedBorderTextFieldStyle())
                        
                        Button("Envoyer") {
                            sendMessage(to: selectedPeer, content: newMessage)
                            messages.append("Moi: \(newMessage)")
                            newMessage = ""
                        }
                        .disabled(newMessage.isEmpty)
                    }
                    .padding()
                }
                .navigationTitle(selectedPeer)
            } else {
                Text("S√©lectionnez une conversation")
                    .foregroundColor(.secondary)
            }
        }
    }
    
    private func initializeMiaou() {
        miaou_initialize()
    }
    
    private func loadPeers() {
        // Appel des fonctions C export√©es depuis Rust
        let peerCount = miaou_get_peer_count()
        for i in 0..<peerCount {
            if let cString = miaou_get_peer_name(i),
               let peerName = String(cString: cString, encoding: .utf8) {
                peers.append(peerName)
                miaou_free_string(UnsafeMutablePointer(mutating: cString))
            }
        }
    }
    
    private func loadMessages(for peer: String) {
        messages.removeAll()
        let messageCount = miaou_get_message_count(peer)
        for i in 0..<messageCount {
            if let cString = miaou_get_message(peer, i),
               let message = String(cString: cString, encoding: .utf8) {
                messages.append(message)
                miaou_free_string(UnsafeMutablePointer(mutating: cString))
            }
        }
    }
    
    private func sendMessage(to peer: String, content: String) {
        miaou_send_message(peer, content)
    }
}

// Fonctions C import√©es depuis Rust
@_silgen_name("miaou_initialize")
func miaou_initialize()

@_silgen_name("miaou_get_peer_count")
func miaou_get_peer_count() -> Int32

@_silgen_name("miaou_get_peer_name")
func miaou_get_peer_name(_ index: Int32) -> UnsafePointer<CChar>?

@_silgen_name("miaou_get_message_count")
func miaou_get_message_count(_ peer: String) -> Int32

@_silgen_name("miaou_get_message")
func miaou_get_message(_ peer: String, _ index: Int32) -> UnsafePointer<CChar>?

@_silgen_name("miaou_send_message")
func miaou_send_message(_ peer: String, _ content: String)

@_silgen_name("miaou_free_string")
func miaou_free_string(_ ptr: UnsafeMutablePointer<CChar>)
```

### **Synchronisation cross-platform**

```rust
// src/sync/mod.rs
pub struct CrossPlatformSync {
    local_storage: LocalStorage,
    sync_protocol: SyncProtocol,
    conflict_resolver: ConflictResolver,
}

impl CrossPlatformSync {
    pub async fn sync_with_devices(&mut self) -> Result<SyncResult, SyncError> {
        // D√©couverte des autres instances Miaou de l'utilisateur
        let discovered_devices = self.discover_user_devices().await?;
        
        for device in discovered_devices {
            let sync_session = self.establish_sync_session(&device).await?;
            
            // Synchronisation des conversations
            self.sync_conversations(&sync_session).await?;
            
            // Synchronisation des contacts
            self.sync_contacts(&sync_session).await?;
            
            // Synchronisation des pr√©f√©rences
            self.sync_preferences(&sync_session).await?;
        }
        
        Ok(SyncResult::Success)
    }

    async fn resolve_message_conflicts(&self, local: &Message, remote: &Message) -> Message {
        // R√©solution de conflits bas√©e sur timestamp et hash
        if local.timestamp > remote.timestamp {
            local.clone()
        } else if remote.timestamp > local.timestamp {
            remote.clone()
        } else {
            // Timestamps identiques, utiliser le hash pour consistance
            if local.content_hash() > remote.content_hash() {
                local.clone()
            } else {
                remote.clone()
            }
        }
    }
}

pub struct MobileFeatures {
    notification_manager: NotificationManager,
    background_sync: BackgroundSync,
    battery_optimizer: BatteryOptimizer,
    data_saver: DataSaver,
}

impl MobileFeatures {
    pub async fn setup_background_tasks(&self) -> Result<(), String> {
        // Configuration des t√¢ches en arri√®re-plan optimis√©es mobile
        self.background_sync.configure_intervals(
            wifi_sync_interval: Duration::minutes(5),
            cellular_sync_interval: Duration::minutes(15),
            low_battery_interval: Duration::hours(1),
        ).await?;
        
        // Configuration des notifications intelligentes
        self.notification_manager.setup_smart_notifications(
            bundle_similar: true,
            quiet_hours: (22, 7), // 22h-7h
            priority_contacts: self.get_priority_contacts().await?,
        ).await?;
        
        Ok(())
    }
}
```

---

## üåê Interface Web Progressive (WebAssembly)

### **Architecture WebAssembly**
```rust
// src/wasm_bindings.rs
use wasm_bindgen::prelude::*;
use wasm_bindgen_futures::spawn_local;
use web_sys::{console, window};
use serde::{Deserialize, Serialize};

// Import JS functions
#[wasm_bindgen]
extern "C" {
    fn alert(s: &str);
    
    #[wasm_bindgen(js_namespace = console)]
    fn log(s: &str);
}

// Macro pour logging dans la console
macro_rules! console_log {
    ($($t:tt)*) => (log(&format_args!($($t)*).to_string()))
}

#[wasm_bindgen]
pub struct MiaouWasm {
    core: MiaouCore,
    js_callbacks: JsCallbacks,
}

#[wasm_bindgen]
impl MiaouWasm {
    #[wasm_bindgen(constructor)]
    pub fn new() -> Result<MiaouWasm, JsError> {
        // Configuration logging
        console_error_panic_hook::set_once();
        
        console_log!("Initialisation Miaou WebAssembly...");
        
        let core = MiaouCore::new()
            .map_err(|e| JsError::new(&format!("Erreur init core: {}", e)))?;
        
        Ok(MiaouWasm {
            core,
            js_callbacks: JsCallbacks::new(),
        })
    }
    
    #[wasm_bindgen]
    pub async fn initialize(&mut self, config: JsValue) -> Result<(), JsError> {
        let config: WebConfig = config.into_serde()
            .map_err(|e| JsError::new(&format!("Config invalide: {}", e)))?;
        
        console_log!("Configuration: {:?}", config);
        
        // Initialiser les composants
        self.core.initialize_crypto().await
            .map_err(|e| JsError::new(&format!("Erreur crypto: {}", e)))?;
        
        self.core.initialize_network().await
            .map_err(|e| JsError::new(&format!("Erreur r√©seau: {}", e)))?;
        
        // D√©marrer la d√©couverte de pairs
        self.core.start_peer_discovery().await
            .map_err(|e| JsError::new(&format!("Erreur d√©couverte: {}", e)))?;
        
        console_log!("Miaou WebAssembly initialis√© avec succ√®s");
        Ok(())
    }
    
    #[wasm_bindgen]
    pub async fn send_message(&mut self, peer_id: &str, content: &str) -> Result<String, JsError> {
        let peer_id = PeerId::from_str(peer_id)
            .map_err(|e| JsError::new(&format!("Peer ID invalide: {}", e)))?;
        
        let message_id = self.core.messaging.send_message(&peer_id, content).await
            .map_err(|e| JsError::new(&format!("Erreur envoi: {}", e)))?;
        
        // Notifier JavaScript
        self.js_callbacks.on_message_sent(&message_id.to_string(), peer_id.to_string());
        
        Ok(message_id.to_string())
    }
    
    #[wasm_bindgen]
    pub async fn get_peers(&self) -> Result<JsValue, JsError> {
        let peers = self.core.network.get_discovered_peers().await
            .map_err(|e| JsError::new(&format!("Erreur peers: {}", e)))?;
        
        let peers_info: Vec<WebPeerInfo> = peers.into_iter()
            .map(|p| WebPeerInfo {
                id: p.id.to_string(),
                display_name: p.display_name.unwrap_or("Anonyme".to_string()),
                status: match p.connection_state {
                    ConnectionState::Connected => "online".to_string(),
                    ConnectionState::Connecting => "connecting".to_string(),
                    ConnectionState::Disconnected => "offline".to_string(),
                },
                last_seen: p.last_seen.map(|t| t.timestamp()),
            })
            .collect();
        
        Ok(JsValue::from_serde(&peers_info)?)
    }
    
    #[wasm_bindgen]
    pub async fn get_conversation(&self, peer_id: &str, limit: Option<usize>) -> Result<JsValue, JsError> {
        let peer_id = PeerId::from_str(peer_id)?;
        
        let messages = self.core.messaging.get_conversation_history(&peer_id, limit.unwrap_or(50)).await
            .map_err(|e| JsError::new(&format!("Erreur conversation: {}", e)))?;
        
        let messages_info: Vec<WebMessageInfo> = messages.into_iter()
            .map(|m| WebMessageInfo {
                id: m.id.to_string(),
                sender_id: m.sender.to_string(),
                content: m.content,
                timestamp: m.timestamp.timestamp(),
                message_type: format!("{:?}", m.message_type),
            })
            .collect();
        
        Ok(JsValue::from_serde(&messages_info)?)
    }
    
    #[wasm_bindgen]
    pub fn set_message_callback(&mut self, callback: js_sys::Function) {
        self.js_callbacks.set_message_callback(callback);
    }
    
    #[wasm_bindgen]
    pub fn set_peer_status_callback(&mut self, callback: js_sys::Function) {
        self.js_callbacks.set_peer_status_callback(callback);
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct WebConfig {
    pub storage_name: String,
    pub debug_mode: bool,
    pub stun_servers: Vec<String>,
    pub turn_servers: Vec<TurnServerConfig>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct WebPeerInfo {
    pub id: String,
    pub display_name: String,
    pub status: String,
    pub last_seen: Option<i64>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct WebMessageInfo {
    pub id: String,
    pub sender_id: String,
    pub content: String,
    pub timestamp: i64,
    pub message_type: String,
}

// Gestion des callbacks JavaScript
pub struct JsCallbacks {
    message_callback: Option<js_sys::Function>,
    peer_status_callback: Option<js_sys::Function>,
}

impl JsCallbacks {
    pub fn new() -> Self {
        Self {
            message_callback: None,
            peer_status_callback: None,
        }
    }
    
    pub fn set_message_callback(&mut self, callback: js_sys::Function) {
        self.message_callback = Some(callback);
    }
    
    pub fn on_message_sent(&self, message_id: &str, peer_id: String) {
        if let Some(callback) = &self.message_callback {
            let event = js_sys::Object::new();
            js_sys::Reflect::set(&event, &"type".into(), &"message_sent".into()).unwrap();
            js_sys::Reflect::set(&event, &"message_id".into(), &message_id.into()).unwrap();
            js_sys::Reflect::set(&event, &"peer_id".into(), &peer_id.into()).unwrap();
            
            let _ = callback.call1(&JsValue::NULL, &event);
        }
    }
}
```

### **PWA avec service worker**
```javascript
// public/sw.js - Service Worker pour PWA
const CACHE_NAME = 'miaou-v0.4.0';
const urlsToCache = [
  '/',
  '/index.html',
  '/static/js/bundle.js',
  '/static/css/main.css',
  '/manifest.json',
  '/miaou-wasm.wasm',
  '/icons/icon-192x192.png',
  '/icons/icon-512x512.png'
];

// Installation du service worker
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => {
        console.log('Cache ouvert');
        return cache.addAll(urlsToCache);
      })
  );
});

// Interception des requ√™tes
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request)
      .then((response) => {
        // Retourner depuis le cache si disponible
        if (response) {
          return response;
        }
        
        // Sinon, fetch depuis le r√©seau
        return fetch(event.request).then((response) => {
          // V√©rifier que la r√©ponse est valide
          if (!response || response.status !== 200 || response.type !== 'basic') {
            return response;
          }
          
          // Cloner la r√©ponse pour le cache
          const responseToCache = response.clone();
          
          caches.open(CACHE_NAME)
            .then((cache) => {
              cache.put(event.request, responseToCache);
            });
          
          return response;
        });
      })
  );
});

// Gestion des messages re√ßus
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

// Notifications push pour messages hors-ligne
self.addEventListener('push', (event) => {
  const options = {
    body: event.data ? event.data.text() : 'Nouveau message Miaou',
    icon: '/icons/icon-192x192.png',
    badge: '/icons/badge-72x72.png',
    vibrate: [200, 100, 200],
    tag: 'miaou-message',
    requireInteraction: true,
    actions: [
      {
        action: 'open',
        title: 'Ouvrir',
        icon: '/icons/open.png'
      },
      {
        action: 'close',
        title: 'Ignorer',
        icon: '/icons/close.png'
      }
    ]
  };
  
  event.waitUntil(
    self.registration.showNotification('Miaou', options)
  );
});

// Gestion des clics sur notifications
self.addEventListener('notificationclick', (event) => {
  event.notification.close();
  
  if (event.action === 'open') {
    event.waitUntil(
      clients.openWindow('/')
    );
  }
});
```

---

## üåê Mini-site d'accueil et contenu social

### **Serveur web int√©gr√© l√©ger**
```rust
// src/web_server.rs
use axum::{
    extract::{Path, Query, State},
    http::{StatusCode, HeaderMap},
    response::{Html, IntoResponse},
    routing::{get, post},
    Router, Json
};
use tower::ServiceBuilder;
use tower_http::{
    services::ServeDir,
    cors::CorsLayer,
    compression::CompressionLayer,
    trace::TraceLayer
};
use serde::{Deserialize, Serialize};
use tera::{Tera, Context};

pub struct WebServer {
    app: Router,
    templates: Tera,
    static_dir: PathBuf,
}

impl WebServer {
    pub fn new() -> Result<Self, WebServerError> {
        // Initialiser le moteur de templates
        let mut tera = Tera::new("templates/**/*")
            .map_err(|e| WebServerError::TemplateError(e.to_string()))?;
        
        // Templates int√©gr√©s par d√©faut
        tera.add_raw_template("base.html", include_str!("../templates/base.html"))?;
        tera.add_raw_template("index.html", include_str!("../templates/index.html"))?;
        tera.add_raw_template("download.html", include_str!("../templates/download.html"))?;
        tera.add_raw_template("docs.html", include_str!("../templates/docs.html"))?;
        
        // Configuration du router
        let app = Router::new()
            .route("/", get(index_handler))
            .route("/download", get(download_handler))
            .route("/docs", get(docs_handler))
            .route("/docs/*path", get(docs_page_handler))
            .route("/api/stats", get(stats_api_handler))
            .route("/api/peers", get(peers_api_handler))
            .route("/join/:referral_code", get(referral_handler))
            .nest_service("/static", ServeDir::new("static"))
            .layer(
                ServiceBuilder::new()
                    .layer(TraceLayer::new_for_http())
                    .layer(CompressionLayer::new())
                    .layer(CorsLayer::permissive())
            )
            .with_state(WebServerState {
                templates: tera,
                miaou_core: Arc::new(Mutex::new(None)), // Sera initialis√© plus tard
            });
        
        Ok(WebServer {
            app,
            templates: tera,
            static_dir: PathBuf::from("static"),
        })
    }
    
    pub async fn serve(&self, addr: SocketAddr) -> Result<(), WebServerError> {
        println!("üåê Serveur web Miaou d√©marr√© sur http://{}", addr);
        
        axum::Server::bind(&addr)
            .serve(self.app.clone().into_make_service())
            .await
            .map_err(|e| WebServerError::ServerError(e.to_string()))?;
        
        Ok(())
    }
}

#[derive(Clone)]
struct WebServerState {
    templates: Tera,
    miaou_core: Arc<Mutex<Option<MiaouCore>>>,
}

// Handlers des pages
async fn index_handler(State(state): State<WebServerState>) -> impl IntoResponse {
    let mut context = Context::new();
    context.insert("title", "Miaou - Messagerie D√©centralis√©e");
    context.insert("description", "La messagerie qui fait ronronner les cryptographes");
    
    // Statistiques en temps r√©el
    if let Ok(Some(core)) = state.miaou_core.try_lock().as_ref() {
        let stats = core.get_network_stats().await.unwrap_or_default();
        context.insert("connected_peers", &stats.connected_peers);
        context.insert("total_messages", &stats.total_messages);
        context.insert("uptime", &format_duration(stats.uptime));
    }
    
    match state.templates.render("index.html", &context) {
        Ok(html) => Html(html),
        Err(e) => Html(format!("<h1>Erreur template: {}</h1>", e)),
    }
}

async fn download_handler(State(state): State<WebServerState>) -> impl IntoResponse {
    let mut context = Context::new();
    context.insert("title", "T√©l√©charger Miaou");
    
    // D√©tection de l'OS depuis User-Agent (simplifi√©)
    context.insert("downloads", &vec![
        DownloadInfo {
            platform: "Windows".to_string(),
            url: "/downloads/miaou-windows-x64.exe".to_string(),
            size: "25 MB".to_string(),
            version: "0.4.0".to_string(),
        },
        DownloadInfo {
            platform: "macOS".to_string(),
            url: "/downloads/miaou-macos.dmg".to_string(),
            size: "30 MB".to_string(),
            version: "0.4.0".to_string(),
        },
        DownloadInfo {
            platform: "Linux".to_string(),
            url: "/downloads/miaou-linux-x64.AppImage".to_string(),
            size: "28 MB".to_string(),
            version: "0.4.0".to_string(),
        },
    ]);
    
    Html(state.templates.render("download.html", &context).unwrap())
}

async fn docs_handler(State(state): State<WebServerState>) -> impl IntoResponse {
    let mut context = Context::new();
    context.insert("title", "Documentation Miaou");
    
    // Charger la documentation depuis les fichiers Markdown
    let docs_content = load_documentation().await.unwrap_or_default();
    context.insert("docs_content", &docs_content);
    
    Html(state.templates.render("docs.html", &context).unwrap())
}

async fn referral_handler(
    Path(referral_code): Path<String>,
    State(state): State<WebServerState>
) -> impl IntoResponse {
    let mut context = Context::new();
    context.insert("title", "Rejoindre Miaou");
    context.insert("referral_code", &referral_code);
    
    // Valider le code de parrainage
    if let Ok(Some(core)) = state.miaou_core.try_lock().as_ref() {
        match core.referrals.validate_code(&referral_code).await {
            Ok(referral_info) => {
                context.insert("valid_code", &true);
                context.insert("referrer_name", &referral_info.referrer_name);
                context.insert("bonus_credits", &referral_info.bonus_amount);
            },
            Err(_) => {
                context.insert("valid_code", &false);
                context.insert("error_message", "Code de parrainage invalide ou expir√©");
            }
        }
    }
    
    Html(state.templates.render("referral.html", &context).unwrap())
}

// API endpoints
async fn stats_api_handler(State(state): State<WebServerState>) -> impl IntoResponse {
    if let Ok(Some(core)) = state.miaou_core.try_lock().as_ref() {
        match core.get_public_stats().await {
            Ok(stats) => Json(stats).into_response(),
            Err(e) => (StatusCode::INTERNAL_SERVER_ERROR, format!("Erreur: {}", e)).into_response(),
        }
    } else {
        (StatusCode::SERVICE_UNAVAILABLE, "Service non disponible").into_response()
    }
}

#[derive(Serialize)]
struct DownloadInfo {
    platform: String,
    url: String,
    size: String,
    version: String,
}
```

### **Templates modernes et responsifs**
```html
<!-- templates/base.html -->
<!DOCTYPE html>
<html lang="fr" data-theme="auto">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}{{ title }}{% endblock %}</title>
    
    <meta name="description" content="{% block description %}{{ description }}{% endblock %}">
    <meta name="keywords" content="messagerie, d√©centralis√©, chiffrement, peer-to-peer, miaou">
    
    <!-- Open Graph -->
    <meta property="og:title" content="{{ title }}">
    <meta property="og:description" content="{{ description }}">
    <meta property="og:image" content="/static/images/miaou-og.png">
    <meta property="og:type" content="website">
    
    <!-- Favicons -->
    <link rel="icon" href="/static/icons/favicon.ico">
    <link rel="apple-touch-icon" href="/static/icons/apple-touch-icon.png">
    
    <!-- Styles -->
    <link rel="stylesheet" href="/static/css/main.css">
    <link rel="stylesheet" href="/static/css/themes.css">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="/manifest.json">
    
    {% block head_extra %}{% endblock %}
</head>
<body>
    <header class="site-header">
        <nav class="navbar">
            <div class="nav-container">
                <div class="nav-brand">
                    <a href="/">
                        <img src="/static/images/miaou-logo.svg" alt="Miaou" class="logo">
                        <span class="brand-text">Miaou</span>
                    </a>
                </div>
                
                <div class="nav-menu" id="nav-menu">
                    <a href="/" class="nav-link">Accueil</a>
                    <a href="/download" class="nav-link">T√©l√©charger</a>
                    <a href="/docs" class="nav-link">Documentation</a>
                    <a href="https://github.com/miaou-chat" class="nav-link" target="_blank">GitHub</a>
                </div>
                
                <div class="nav-actions">
                    <button class="theme-toggle" id="theme-toggle" aria-label="Changer de th√®me">
                        <span class="theme-icon">üåô</span>
                    </button>
                    <button class="mobile-menu-toggle" id="mobile-menu-toggle" aria-label="Menu">
                        <span></span>
                        <span></span>
                        <span></span>
                    </button>
                </div>
            </div>
        </nav>
    </header>

    <main class="main-content">
        {% block content %}{% endblock %}
    </main>

    <footer class="site-footer">
        <div class="footer-container">
            <div class="footer-section">
                <h4>Miaou</h4>
                <p>Messagerie d√©centralis√©e respectueuse de votre vie priv√©e</p>
                <div class="social-links">
                    <a href="https://github.com/miaou-chat" target="_blank" aria-label="GitHub">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
                        </svg>
                    </a>
                    <a href="https://matrix.to/#/#miaou:matrix.org" target="_blank" aria-label="Matrix">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M.632.55v22.9H2.28V24H0V0h2.28v.55zm7.043 7.26v1.157h.033c.309-.443.683-.784 1.117-1.024.433-.245.936-.365 1.5-.365.54 0 1.033.107 1.481.314.448.208.785.582 1.02 1.108.254-.374.6-.706 1.034-.992.434-.287.95-.43 1.546-.43.453 0 .872.056 1.26.167.388.11.716.286.993.53.276.245.489.559.646.951.152.392.23.863.23 1.417v5.728h-2.349V11.52c0-.286-.01-.559-.032-.812a1.755 1.755 0 0 0-.18-.66 1.106 1.106 0 0 0-.438-.448c-.194-.11-.457-.166-.785-.166-.332 0-.6.064-.803.189a1.38 1.38 0 0 0-.48.499 1.946 1.946 0 0 0-.231.696c-.039.244-.059.49-.059.735v4.826H9.936V11.52c0-.286-.01-.559-.032-.812a1.755 1.755 0 0 0-.18-.66 1.106 1.106 0 0 0-.438-.448c-.194-.11-.457-.166-.785-.166-.332 0-.6.064-.803.189a1.38 1.38 0 0 0-.48.499 1.946 1.946 0 0 0-.231.696c-.039.244-.059.49-.059.735v4.826H5.579V7.81h1.849v1zm13.345 0v1.372h.033c.121-.509.383-.923.785-1.241.402-.317.868-.476 1.4-.476.068 0 .15.005.246.016.096.01.18.023.254.038v1.609c-.097-.015-.204-.025-.323-.038a2.204 2.204 0 0 0-.323-.016c-.434 0-.808.117-1.121.35-.313.234-.517.54-.612.918a1.845 1.845 0 0 0-.143.717v4.307h-2.196V7.81h1.849v1zM21.72.55v22.9H20.08V24H24V0h-2.28v.55z"/>
                        </svg>
                    </a>
                </div>
            </div>
            
            <div class="footer-section">
                <h4>Ressources</h4>
                <ul>
                    <li><a href="/docs">Documentation</a></li>
                    <li><a href="/docs/api">API</a></li>
                    <li><a href="/docs/security">S√©curit√©</a></li>
                    <li><a href="/docs/contributing">Contribuer</a></li>
                </ul>
            </div>
            
            <div class="footer-section">
                <h4>Communaut√©</h4>
                <ul>
                    <li><a href="https://github.com/miaou-chat/discussions">Discussions</a></li>
                    <li><a href="https://matrix.to/#/#miaou:matrix.org">Matrix</a></li>
                    <li><a href="/blog">Blog</a></li>
                    <li><a href="/roadmap">Roadmap</a></li>
                </ul>
            </div>
            
            <div class="footer-section">
                <h4>Statut</h4>
                <div class="network-stats">
                    <div class="stat">
                        <span class="stat-label">Peers connect√©s:</span>
                        <span class="stat-value" id="connected-peers">{{ connected_peers | default(value="0") }}</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">Messages √©chang√©s:</span>
                        <span class="stat-value" id="total-messages">{{ total_messages | default(value="0") }}</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">Uptime:</span>
                        <span class="stat-value" id="uptime">{{ uptime | default(value="0s") }}</span>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="footer-bottom">
            <div class="footer-container">
                <p>&copy; 2024 Miaou. Logiciel libre sous licence MIT.</p>
                <p>
                    <a href="/privacy">Politique de confidentialit√©</a> ¬∑ 
                    <a href="/terms">Conditions d'utilisation</a> ¬∑ 
                    <a href="/security">Signaler une vuln√©rabilit√©</a>
                </p>
            </div>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="/static/js/theme.js"></script>
    <script src="/static/js/navigation.js"></script>
    <script src="/static/js/stats.js"></script>
    {% block scripts %}{% endblock %}
</body>
</html>
```

---

## üë§ Exp√©rience Utilisateur

### **Assistant d'onboarding**
```typescript
// src/components/OnboardingWizard.tsx
import React, { useState } from 'react';
import { invoke } from '@tauri-apps/api/tauri';
import { StepIndicator } from './StepIndicator';
import { SecurityExplanation } from './SecurityExplanation';
import './OnboardingWizard.css';

interface OnboardingState {
  step: number;
  profileName: string;
  password: string;
  confirmPassword: string;
  seedPhrase: string[];
  acceptedTerms: boolean;
  networkSettings: NetworkSettings;
}

export const OnboardingWizard: React.FC<{
  onComplete: (profile: ProfileInfo) => void;
}> = ({ onComplete }) => {
  const [state, setState] = useState<OnboardingState>({
    step: 1,
    profileName: '',
    password: '',
    confirmPassword: '',
    seedPhrase: [],
    acceptedTerms: false,
    networkSettings: {
      autoDiscovery: true,
      useBootstrapNodes: true,
      allowRelay: true,
    },
  });

  const steps = [
    { title: 'Bienvenue', icon: 'üëã' },
    { title: 'Profil', icon: 'üë§' },
    { title: 'S√©curit√©', icon: 'üîê' },
    { title: 'R√©seau', icon: 'üåê' },
    { title: 'Finalisation', icon: '‚úÖ' },
  ];

  const handleNextStep = () => {
    setState(prev => ({ ...prev, step: prev.step + 1 }));
  };

  const handlePrevStep = () => {
    setState(prev => ({ ...prev, step: prev.step - 1 }));
  };

  const generateSeedPhrase = async () => {
    try {
      const seedPhrase = await invoke<string[]>('generate_seed_phrase');
      setState(prev => ({ ...prev, seedPhrase }));
    } catch (error) {
      console.error('Erreur g√©n√©ration seed phrase:', error);
    }
  };

  const createProfile = async () => {
    try {
      const profile = await invoke<ProfileInfo>('create_profile_with_onboarding', {
        name: state.profileName,
        password: state.password,
        seedPhrase: state.seedPhrase,
        networkSettings: state.networkSettings,
      });
      
      onComplete(profile);
    } catch (error) {
      console.error('Erreur cr√©ation profil:', error);
    }
  };

  const renderStep = () => {
    switch (state.step) {
      case 1:
        return (
          <div className="welcome-step">
            <div className="welcome-animation">
              <div className="cat-emoji">üê±</div>
              <div className="sparkles">‚ú®</div>
            </div>
            
            <h2>Bienvenue dans Miaou !</h2>
            <p className="welcome-description">
              Miaou est une messagerie d√©centralis√©e qui respecte votre vie priv√©e. 
              Vos conversations restent entre vous et vos correspondants, 
              sans serveur central qui pourrait les espionner.
            </p>
            
            <div className="features-preview">
              <div className="feature">
                <span className="feature-icon">üîê</span>
                <div>
                  <h4>Chiffrement bout-en-bout</h4>
                  <p>Vos messages sont chiffr√©s avant de quitter votre appareil</p>
                </div>
              </div>
              
              <div className="feature">
                <span className="feature-icon">üåê</span>
                <div>
                  <h4>D√©centralis√©</h4>
                  <p>Pas de serveur central, connexion directe entre pairs</p>
                </div>
              </div>
              
              <div className="feature">
                <span className="feature-icon">üéÆ</span>
                <div>
                  <h4>R√©compenses</h4>
                  <p>Gagnez des croquettes en contribuant au r√©seau</p>
                </div>
              </div>
            </div>
            
            <button 
              className="btn btn-primary btn-large"
              onClick={handleNextStep}
            >
              Commencer la configuration
            </button>
          </div>
        );

      case 2:
        return (
          <div className="profile-step">
            <h2>Cr√©er votre profil</h2>
            <p>Choisissez un nom d'affichage et un mot de passe s√©curis√©</p>
            
            <div className="form-group">
              <label htmlFor="profile-name">Nom d'affichage</label>
              <input
                id="profile-name"
                type="text"
                value={state.profileName}
                onChange={(e) => setState(prev => ({ ...prev, profileName: e.target.value }))}
                placeholder="Votre nom dans Miaou"
                maxLength={50}
              />
              <small>Ce nom sera visible par vos contacts</small>
            </div>
            
            <div className="form-group">
              <label htmlFor="password">Mot de passe</label>
              <input
                id="password"
                type="password"
                value={state.password}
                onChange={(e) => setState(prev => ({ ...prev, password: e.target.value }))}
                placeholder="Mot de passe s√©curis√©"
              />
              <PasswordStrengthIndicator password={state.password} />
            </div>
            
            <div className="form-group">
              <label htmlFor="confirm-password">Confirmer le mot de passe</label>
              <input
                id="confirm-password"
                type="password"
                value={state.confirmPassword}
                onChange={(e) => setState(prev => ({ ...prev, confirmPassword: e.target.value }))}
                placeholder="Retapez votre mot de passe"
              />
              {state.confirmPassword && state.password !== state.confirmPassword && (
                <small className="error">Les mots de passe ne correspondent pas</small>
              )}
            </div>
            
            <div className="step-actions">
              <button className="btn btn-secondary" onClick={handlePrevStep}>
                Retour
              </button>
              <button 
                className="btn btn-primary"
                onClick={handleNextStep}
                disabled={!state.profileName || !state.password || state.password !== state.confirmPassword}
              >
                Continuer
              </button>
            </div>
          </div>
        );

      case 3:
        return (
          <div className="security-step">
            <h2>S√©curisation de votre profil</h2>
            
            <SecurityExplanation />
            
            <div className="seed-phrase-section">
              <h3>Phrase de r√©cup√©ration</h3>
              <p>
                Cette phrase vous permettra de r√©cup√©rer votre profil si vous perdez l'acc√®s √† cet appareil. 
                <strong>Notez-la dans un endroit s√ªr et ne la partagez jamais.</strong>
              </p>
              
              {state.seedPhrase.length === 0 ? (
                <button 
                  className="btn btn-secondary"
                  onClick={generateSeedPhrase}
                >
                  G√©n√©rer la phrase de r√©cup√©ration
                </button>
              ) : (
                <div className="seed-phrase-display">
                  <div className="seed-phrase-grid">
                    {state.seedPhrase.map((word, index) => (
                      <div key={index} className="seed-word">
                        <span className="seed-number">{index + 1}</span>
                        <span className="seed-text">{word}</span>
                      </div>
                    ))}
                  </div>
                  
                  <div className="seed-phrase-actions">
                    <button className="btn btn-outline" onClick={generateSeedPhrase}>
                      G√©n√©rer une nouvelle phrase
                    </button>
                    <button className="btn btn-outline">
                      üìÑ Imprimer
                    </button>
                  </div>
                  
                  <div className="security-warning">
                    <div className="warning-icon">‚ö†Ô∏è</div>
                    <div>
                      <strong>Important :</strong> Cette phrase donne acc√®s complet √† votre profil. 
                      Ne la stockez jamais num√©riquement (capture d'√©cran, fichier, etc.). 
                      √âcrivez-la sur papier et conservez-la en s√©curit√©.
                    </div>
                  </div>
                </div>
              )}
            </div>
            
            <div className="step-actions">
              <button className="btn btn-secondary" onClick={handlePrevStep}>
                Retour
              </button>
              <button 
                className="btn btn-primary"
                onClick={handleNextStep}
                disabled={state.seedPhrase.length === 0}
              >
                J'ai sauvegard√© ma phrase
              </button>
            </div>
          </div>
        );

      // ... autres steps
    }
  };

  return (
    <div className="onboarding-wizard">
      <div className="onboarding-container">
        <StepIndicator steps={steps} currentStep={state.step} />
        
        <div className="onboarding-content">
          {renderStep()}
        </div>
      </div>
    </div>
  );
};
```

---

## üìä M√©triques et Crit√®res de Succ√®s

### **KPIs UX/UI**
- ‚úÖ **Temps d'onboarding < 5 minutes** (utilisateur moyen)
- ‚úÖ **Score accessibilit√© >= 95%** (Lighthouse)
- ‚úÖ **Performance web >= 90%** (Core Web Vitals)
- ‚úÖ **Responsive design** 100% √©crans (mobile √† 4K)
- ‚úÖ **Support multilingue** (fran√ßais, anglais minimum)

### **KPIs Application Desktop**
- ‚úÖ **Temps de d√©marrage < 3s** (SSD)
- ‚úÖ **Utilisation m√©moire < 200MB** (idle)
- ‚úÖ **Notifications syst√®me** fonctionnelles
- ‚úÖ **Raccourcis clavier** complets
- ‚úÖ **Multi-fen√™tres** support

### **KPIs PWA Web**
- ‚úÖ **Fonctionnement offline** de base
- ‚úÖ **Installation PWA** sur mobile/desktop
- ‚úÖ **Performance WebAssembly** proche native
- ‚úÖ **Notifications push** cross-platform

---

## üöÄ Livrables de la Version

### **üì¶ Applications compl√®tes**
- `Miaou Desktop` : Application native Windows/macOS/Linux
- `Miaou Web` : PWA avec WebAssembly
- `Serveur web int√©gr√©` : Site vitrine et documentation

### **üé® Assets et design**
- Design system complet avec composants
- Ic√¥nes et illustrations coh√©rentes
- Th√®mes clair/sombre adaptatifs
- Animations et micro-interactions

### **üìö Documentation utilisateur**
- Guide de d√©marrage illustr√©
- Tutoriels vid√©o int√©gr√©s
- FAQ interactive
- Centre d'aide contextuel

---

## üóìÔ∏è Pr√©paration v0.5.0

Cette version pr√©pare la **v0.5.0 "Chat de Goutti√®re"** qui ajoutera :
- Ponts vers protocoles ouverts (Matrix, XMPP, IRC)
- Ponts messageries populaires (WhatsApp, Signal, Telegram)
- Fonctions sociales int√©gr√©es
- Invitations cross-platform automatis√©es

**L'UX polie de la v0.4.0 s√©duira les utilisateurs** - la v0.5.0 les connectera partout ! üåâ

---

*Le toilettage est termin√©... Miaou brille maintenant de mille feux dans sa robe d'apparat !* üê±‚ú®