# Analyse d eGPT-5 => Plan Phase 2 en 3 incréments livrables

## Incrément A — Transport & découverte “MVP”

**But :** établir un pipe de données P2P fiable partout, avec fallback, et une découverte locale + bootstrap.

1. **Abstraction transport**

   * Crée `miaou-network/transport` avec un **trait** unique :

     ```rust
     /// Transport for reliable, ordered byte frames.
     #[async_trait::async_trait]
     pub trait Transport: Send + Sync {
         async fn connect(&self, peer: &PeerInfo) -> Result<Conn, TransportError>;
         async fn accept(&self) -> Result<Conn, TransportError>;
     }

     pub struct Conn { /* read_frame(), write_frame(), rtt(), peer_id(), ... */ }
     ```
   * Implémente 2 backends :

     * `transport-webrtc` (desktop/server) via le crate **`webrtc`** (Pion porté en Rust : DataChannel + ICE/STUN/TURN). ([Docs.rs][1], [GitHub][2])
     * `transport-wasm` (web) via bindings JS (WebRTC natif) — même trait, derrière `wasm-bindgen`.
   * Garde un **fallback TLS/TCP** simple (quand TURN indisponible ou pas de WebRTC possible).

2. **NAT traversal & config**

   * Expose un `IceConfig { stun: Vec<url>, turn: Vec<TurnServer> }` et des helpers de priorisation candidates (RFC 8445). Le crate `webrtc` a déjà **RTCIceServer** & co. ([Docs.rs][3])

3. **Découverte**

   * `discovery-mdns` pour LAN (service `_miaou._udp.local` ou `_miaou._tcp.local`), via un crate Rust mDNS (par ex. **`libmdns`** / **`mdns`** / **`simple-mdns`** selon ce qui marche le mieux dans ton environnement Tokio). ([Docs.rs][4])
   * `discovery-bootstrap` (liste de nœuds seed) + **ajout manuel** par URI.
   * **DHT** en “stub” (interfaces seulement), tu l’implémenteras en v0.3+.

4. **Framing binaire minimal**

   * Définis un **frame** *strictement* length-prefixed (u32 big-endian) + `kind (u8)` + `version (u8)` + `payload`.
   * ⚠️ **Retire le checksum BLAKE3** dans le frame réseau : l’AEAD du message applicatif et/ou DTLS/SRTP du canal **garantit déjà l’intégrité**. Garde BLAKE3 uniquement en **couche stockage** (si besoin).
   * Bénéfice : API plus simple, moins d’attaques de doublons d’intégrité.

5. **CLI**

   * Ajoute `miaou net start-discovery`, `net list-peers`, `net connect --peer …`, `net info`.

**Tests/KPIs à viser**

* Découverte LAN < 30 s, connect P2P < 10 s, fallback TURN < 20 s.
* RTT reporté par `Conn::rtt()` et testé en CI (smoke).
* Tests d’intégration “2 nœuds” (un initiateur, un récepteur) via DataChannel.
* Bench de latence “ping/pong” dans `benches/`.

> Références : ton dépôt (arbo & dossiers réseau) et l’exécution Actions qui prépare ces jobs multi-cibles. ([GitHub][5])

---

## Incrément B — Handshake & session (E2E)

**But :** établir une **clé de session** une fois le transport ouvert.

1. **X3DH-like + Double Ratchet**

   * Si tu veux rester *“Signal-like”* :

     * X25519 (éphémère/long-terme), HKDF, puis **Double Ratchet** pour PFS.
     * En Rust, tu peux soit intégrer **`double-ratchet`** (lib dédiée) soit encapsuler tes primitives existantes. ([Docs.rs][6])
   * Option “officielle” : **libsignal** (mais c’est un gros monolithe, bindings et maintenance plus lourds ; à peser). ([GitHub][7])

2. **API**

   ```rust
   pub struct Session { /* encrypt(), decrypt(), rekey_on_receive(), ... */ }

   pub async fn x3dh_handshake(conn: &mut Conn, local_id: &Identity, peer_hint: &PeerHint)
       -> Result<Session, HandshakeError>;
   ```

3. **Sécurité pragmatique**

   * **Domain separation** sur HKDF/labels (`"miaou/v0.2/handshake"`), AAD obligatoire côté AEAD (déjà posé en v0.1).
   * **No custom MAC** dans le frame réseau (intégrité déjà couverte plus haut).

**Tests**

* KAT/Property : `decrypt(encrypt(m)) == m`, *AAD mismatch ⇒ Err*, gestion messages hors ordre (ratchet).
* Test d’interop : 2 processus (ou 2 jobs CI) se handshake & échangent 100 messages.

---

## Incrément C — Messagerie de base & offline

**But :** envoyer/recevoir un message texte de manière fiable et résistante aux déconnexions.

1. **Message bus**

   * `messaging-core` avec queue sortante, retry/backoff, accusés réception.
   * **Offline store** (déjà amorcé en v0.1) : sérialisation chiffrée des `PendingMessage`.

2. **Policies**

   * TTL messages, anti-replay (ID monotone/nonce), padding optionnel, “sealed sender” **à préparer** (patch plus tard).

3. **CLI**

   * `net send --to <peer> --message "..."`, `history`, `diagnostics` (STUN/TURN/DNS/throughput).

**KPIs**

* Taux de delivery > 99.5 % (avec retries), reconnexion < 5 s, latence < 100 ms P2P / < 300 ms via relais.

---

# Relecture de ton fichier **v0.2.0 “Radar à Moustaches”**

Globalement j’adore le storytelling, et techniquement tu couvres les bons blocs.
Je propose ces **ajustements concrets** pour éviter les zones à risque et cadrer la portée :

1. **Pile réseau (schéma)**

   * Indique explicitement : *“Desktop/Server : webrtc-rs ; Web : WebRTC natif via wasm-bindgen ; Fallback : TLS/TCP (rustls + tokio).”*
   * Ajoute une mention “**SCTP DataChannel**” (c’est ce que fournit la lib Rust WebRTC). ([Docs.rs][1])

2. **Découverte**

   * Mentionne **un** crate mDNS cible (par ex. `libmdns`/`mdns`) et précise “LAN only ; DHT ultérieure”. Ça évite d’over-promettre la DHT tout de suite. ([Docs.rs][4])

3. **Protocole (framing)**

   * **Retire `checksum`** du `MiaouFrame` : l’intégrité est assurée par AEAD (couche session) et/ou DTLS/SRTP (couche DataChannel). Garde `version`, `type`, `sequence`, `timestamp`, `payload_len`.
   * Déplace BLAKE3 vers **stockage repos** et/ou hashes d’index, pas sur le wire.

4. **Handshake**

   * Réécris l’algo en “X3DH-like (X25519 + Ed25519) → HKDF → Double Ratchet”, et **note** que l’impl Rust WebRTC chiffre déjà le canal (DTLS/SRTP), mais que **le chiffrement E2E au-dessus** reste obligatoire.
   * Laisse **MLS** pour une v≥0.4 (groupes).

5. **CLI**

   * Les commandes listées sont parfaites. Ajoute `net selftest` qui :

     * Résout STUN, récolte candidats ICE, ouvre un loopback DataChannel, mesure RTT, imprime la config active (serveurs, policy).

6. **Livrables**

   * Ajoute `miaou-webrtc-demo` (binaire d’intégration point-à-point) pour les tests manuels : `--role initiator|responder --peer <offer.json>`.

7. **CI**

   * **Jobs dédiés** :

     * `test-transport-webrtc` (Linux) avec **webrtc-rs** (pas besoin d’A/V, juste DataChannel). ([GitHub][2])
     * `test-discovery-mdns` (peut être flaky en runners — mock/feature “loopback”).
     * `e2e-two-nodes` avec `tmux`/`timeout` : démarre 2 binaires, échange 10 messages, vérifie RTT < X ms.
   * Publie artefacts : `offer.sdp`/`answer.sdp` pour debug si e2e échoue.

---

# “Definition of Done” Phase 2

* **Transport** : Trait + impl WebRTC desktop (DataChannel), WASM wrapper, fallback TLS/TCP.
* **ICE** : STUN/TURN configurable, collecte & tri candidats, connexion établie dans les SLA.
* **Découverte** : mDNS (LAN) + bootstrap list + ajout manuel.
* **Handshake** : X3DH-like + Double Ratchet minimal, labels HKDF versionnés. ([Docs.rs][6])
* **Messagerie** : send/receive texte, ACK, retry offline, historique local chiffré.
* **CLI** : `start-discovery`, `list-peers`, `connect`, `send`, `history`, `network-info`, `diagnostics`, `selftest`.
* **Tests** : unit + property + e2e 2-process + bench ping/pong ; CI verte sur Linux.
* **Docs** : README “Phase 2 – surface minimale”, ADR “Choice of WebRTC.rs vs WASM WebRTC”.

---

## Extras (pièges évités)

* **Checksum dans le frame** : doublonne et peut induire des fausses garanties → supprimé.
* **DHT** : garde ça pour v0.3+ (sinon tu vas te battre avec le NAT & churn tout de suite).
* **Interop mobile/web** : WebAssembly utilise l’API WebRTC du navigateur ; desktop utilise `webrtc` crate → même **trait Transport** au-dessus. ([Docs.rs][1])

---


[1]: https://docs.rs/webrtc/latest/webrtc/?utm_source=chatgpt.com "webrtc - Rust - Docs.rs"
[2]: https://github.com/webrtc-rs/webrtc?utm_source=chatgpt.com "webrtc-rs/webrtc: A pure Rust implementation of WebRTC - GitHub"
[3]: https://docs.rs/webrtc/latest/webrtc/ice_transport/ice_server/?utm_source=chatgpt.com "webrtc::ice_transport::ice_server - Rust - Docs.rs"
[4]: https://docs.rs/crate/libmdns/latest?utm_source=chatgpt.com "libmdns 0.9.1 - Docs.rs"
[5]: https://github.com/yrbane/miaou/tree/v0.1.0-premiere-griffe "GitHub - yrbane/miaou at v0.1.0-premiere-griffe"
[6]: https://docs.rs/double-ratchet?utm_source=chatgpt.com "double_ratchet - Rust - Docs.rs"
[7]: https://github.com/signalapp/libsignal?utm_source=chatgpt.com "GitHub - signalapp/libsignal: Home to the Signal Protocol as well as ..."
