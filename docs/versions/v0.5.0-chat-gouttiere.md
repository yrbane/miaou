# üê± Version 0.5.0 "Chat de Goutti√®re"
## *Naviguer entre tous les territoires*

> **Phase 5 : Interop√©rabilit√© et ponts** - Connexion avec l'√©cosyst√®me existant

---

## üéØ Vision de cette version

Le **Chat de Goutti√®re** fait de Miaou le hub central de toutes vos communications. Comme un chat des rues qui conna√Æt tous les chemins et peut se faufiler partout, cette version connecte Miaou √† l'ensemble de l'√©cosyst√®me de messagerie existant, unifiant vos conversations dispers√©es.

**Motto :** *"Un seul chat pour les gouverner tous"*

---

## üåâ Ponts vers Protocoles Ouverts

### **Architecture de bridges s√©curis√©s**
```rust
// Architecture g√©n√©rique pour tous les bridges
pub trait MessageBridge: Send + Sync {
    async fn initialize(&mut self, config: BridgeConfig) -> Result<(), BridgeError>;
    async fn connect(&mut self) -> Result<(), BridgeError>;
    async fn disconnect(&mut self) -> Result<(), BridgeError>;
    
    // Envoi de messages
    async fn send_message(&mut self, msg: UnifiedMessage) -> Result<MessageId, BridgeError>;
    
    // R√©ception de messages (stream)
    fn message_stream(&self) -> Pin<Box<dyn Stream<Item = UnifiedMessage> + Send>>;
    
    // Gestion des contacts
    async fn get_contacts(&self) -> Result<Vec<Contact>, BridgeError>;
    async fn sync_contacts(&mut self) -> Result<(), BridgeError>;
    
    // M√©tadonn√©es du bridge
    fn get_info(&self) -> BridgeInfo;
    fn get_capabilities(&self) -> BridgeCapabilities;
}

#[derive(Debug, Clone)]
pub struct UnifiedMessage {
    pub id: MessageId,
    pub conversation_id: ConversationId,
    pub sender: ContactId,
    pub recipient: ContactId,
    pub content: MessageContent,
    pub timestamp: DateTime<Utc>,
    pub bridge_metadata: BridgeMetadata,
    pub encryption_info: Option<EncryptionInfo>,
}

#[derive(Debug, Clone)]
pub enum MessageContent {
    Text(String),
    Image { data: Vec<u8>, mime_type: String, caption: Option<String> },
    File { data: Vec<u8>, filename: String, mime_type: String },
    Audio { data: Vec<u8>, duration_ms: u32 },
    Video { data: Vec<u8>, duration_ms: u32, thumbnail: Option<Vec<u8>> },
    Location { latitude: f64, longitude: f64, address: Option<String> },
    Reaction { target_message_id: MessageId, emoji: String },
    System(SystemMessage),
}

pub struct BridgeManager {
    bridges: HashMap<BridgeId, Box<dyn MessageBridge>>,
    message_router: MessageRouter,
    encryption_layer: BridgeEncryptionLayer,
    conversation_mapper: ConversationMapper,
}

impl BridgeManager {
    pub async fn register_bridge(&mut self, bridge: Box<dyn MessageBridge>) -> Result<BridgeId, BridgeError> {
        let bridge_info = bridge.get_info();
        let bridge_id = BridgeId::new(&bridge_info.protocol_name);
        
        // Initialiser le bridge avec isolation s√©curis√©e
        let mut isolated_bridge = IsolatedBridge::new(bridge);
        isolated_bridge.initialize(bridge_info.default_config).await?;
        
        self.bridges.insert(bridge_id.clone(), Box::new(isolated_bridge));
        
        // Configurer le routage des messages
        self.message_router.add_bridge_route(&bridge_id, &bridge_info.supported_message_types);
        
        Ok(bridge_id)
    }
    
    pub async fn send_unified_message(&mut self, msg: UnifiedMessage) -> Result<(), BridgeError> {
        // D√©terminer le bridge appropri√© selon le destinataire
        let bridge_id = self.conversation_mapper.get_bridge_for_contact(&msg.recipient)?;
        
        let bridge = self.bridges.get_mut(&bridge_id)
            .ok_or(BridgeError::BridgeNotFound(bridge_id))?;
        
        // Chiffrer le message avant passage au bridge
        let encrypted_msg = self.encryption_layer.encrypt_for_bridge(&msg, &bridge_id).await?;
        
        // Envoyer via le bridge
        bridge.send_message(encrypted_msg).await?;
        
        // Logger pour audit
        self.log_bridge_activity(&bridge_id, &msg.id, BridgeActivity::MessageSent);
        
        Ok(())
    }
    
    pub async fn start_message_listening(&mut self) -> Result<(), BridgeError> {
        for (bridge_id, bridge) in &self.bridges {
            let bridge_stream = bridge.message_stream();
            let encryption_layer = self.encryption_layer.clone();
            let message_router = self.message_router.clone();
            let bridge_id = bridge_id.clone();
            
            tokio::spawn(async move {
                while let Some(msg) = bridge_stream.next().await {
                    // D√©chiffrer le message re√ßu
                    match encryption_layer.decrypt_from_bridge(&msg, &bridge_id).await {
                        Ok(decrypted_msg) => {
                            // Router vers Miaou core
                            if let Err(e) = message_router.route_inbound_message(decrypted_msg).await {
                                eprintln!("‚ùå Erreur routage message depuis {}: {}", bridge_id, e);
                            }
                        },
                        Err(e) => {
                            eprintln!("‚ùå Erreur d√©chiffrement message depuis {}: {}", bridge_id, e);
                        }
                    }
                }
            });
        }
        
        Ok(())
    }
}
```

### **Bridge Matrix (protocole ouvert)**
```rust
pub struct MatrixBridge {
    client: matrix_sdk::Client,
    room_mapper: HashMap<matrix_sdk::RoomId, ConversationId>,
    sync_token: Option<String>,
    encryption_keys: HashMap<matrix_sdk::UserId, Vec<u8>>,
}

impl MatrixBridge {
    pub async fn new(homeserver_url: &str) -> Result<Self, MatrixBridgeError> {
        let client = matrix_sdk::Client::new_from_url(Url::parse(homeserver_url)?).await?;
        
        Ok(MatrixBridge {
            client,
            room_mapper: HashMap::new(),
            sync_token: None,
            encryption_keys: HashMap::new(),
        })
    }
}

#[async_trait]
impl MessageBridge for MatrixBridge {
    async fn initialize(&mut self, config: BridgeConfig) -> Result<(), BridgeError> {
        let matrix_config = config.as_matrix_config()?;
        
        // Authentification
        match matrix_config.auth_method {
            MatrixAuthMethod::Password { username, password } => {
                self.client.login(&username, &password, None, Some("Miaou Bridge")).await?;
            },
            MatrixAuthMethod::AccessToken { token } => {
                // Utiliser un token d'acc√®s existant
                self.client.restore_login(matrix_sdk::Session {
                    access_token: token,
                    user_id: matrix_config.user_id.parse()?,
                    device_id: matrix_config.device_id.into(),
                }).await?;
            }
        }
        
        // Configurer le chiffrement E2EE Matrix
        if matrix_config.enable_encryption {
            self.setup_matrix_encryption().await?;
        }
        
        // Synchroniser les rooms existantes
        self.sync_rooms().await?;
        
        Ok(())
    }
    
    async fn connect(&mut self) -> Result<(), BridgeError> {
        // D√©marrer la synchronisation Matrix
        let sync_settings = matrix_sdk::SyncSettings::default()
            .token(self.sync_token.clone());
        
        self.client.sync_once(sync_settings).await?;
        
        Ok(())
    }
    
    async fn send_message(&mut self, msg: UnifiedMessage) -> Result<MessageId, BridgeError> {
        // Mapper la conversation Miaou vers une room Matrix
        let room_id = self.get_or_create_room_for_conversation(&msg.conversation_id).await?;
        let room = self.client.get_joined_room(&room_id)
            .ok_or(BridgeError::ConversationNotFound)?;
        
        // Convertir le contenu Miaou vers Matrix
        let matrix_content = self.convert_to_matrix_content(&msg.content)?;
        
        // Envoyer le message
        let response = room.send(matrix_content, None).await?;
        
        // Retourner l'ID du message Matrix
        Ok(MessageId::from(response.event_id.to_string()))
    }
    
    fn message_stream(&self) -> Pin<Box<dyn Stream<Item = UnifiedMessage> + Send>> {
        let (tx, rx) = tokio::sync::mpsc::unbounded_channel();
        let client = self.client.clone();
        let room_mapper = self.room_mapper.clone();
        
        tokio::spawn(async move {
            let mut sync_stream = client.sync_stream(matrix_sdk::SyncSettings::default()).await;
            
            while let Some(sync_response) = sync_stream.next().await {
                for (room_id, room_events) in sync_response.rooms.join {
                    for event in room_events.timeline.events {
                        if let matrix_sdk::events::AnyMessageEvent::RoomMessage(msg_event) = event.event {
                            // Convertir l'√©v√©nement Matrix en UnifiedMessage
                            if let Some(unified_msg) = convert_matrix_event_to_unified(
                                &msg_event, 
                                &room_id, 
                                &room_mapper
                            ).await {
                                if tx.send(unified_msg).is_err() {
                                    break; // Le receiver a √©t√© ferm√©
                                }
                            }
                        }
                    }
                }
            }
        });
        
        Box::pin(tokio_stream::wrappers::UnboundedReceiverStream::new(rx))
    }
    
    async fn get_contacts(&self) -> Result<Vec<Contact>, BridgeError> {
        let mut contacts = Vec::new();
        
        // R√©cup√©rer tous les utilisateurs des rooms jointes
        for room in self.client.joined_rooms() {
            for member in room.members().await? {
                contacts.push(Contact {
                    id: ContactId::from(member.user_id().to_string()),
                    display_name: member.display_name().unwrap_or(member.user_id().localpart()).to_string(),
                    avatar_url: member.avatar_url().map(|url| url.to_string()),
                    bridge_id: BridgeId::Matrix,
                    bridge_specific_data: Some(json!({
                        "matrix_user_id": member.user_id().to_string(),
                        "power_level": member.power_level(),
                        "presence": member.presence().map(|p| format!("{:?}", p)),
                    })),
                });
            }
        }
        
        Ok(contacts)
    }
    
    fn get_info(&self) -> BridgeInfo {
        BridgeInfo {
            protocol_name: "Matrix".to_string(),
            version: "1.0".to_string(),
            capabilities: BridgeCapabilities {
                supports_encryption: true,
                supports_media: true,
                supports_groups: true,
                supports_typing_indicators: true,
                supports_read_receipts: true,
                max_message_size: 65536, // Matrix limit
                supported_media_types: vec![
                    "image/*".to_string(),
                    "video/*".to_string(),
                    "audio/*".to_string(),
                    "application/*".to_string(),
                ],
            },
            default_config: BridgeConfig::Matrix(MatrixConfig::default()),
        }
    }
}
```

### **Bridge XMPP (Jabber)**
```rust
pub struct XMPPBridge {
    client: xmpp::Client,
    jid: xmpp::Jid,
    contacts: HashMap<xmpp::Jid, Contact>,
    message_handler: XMPPMessageHandler,
}

#[async_trait]
impl MessageBridge for XMPPBridge {
    async fn initialize(&mut self, config: BridgeConfig) -> Result<(), BridgeError> {
        let xmpp_config = config.as_xmpp_config()?;
        
        // Configuration client XMPP
        self.jid = xmpp_config.jid.parse()?;
        self.client = xmpp::Client::new(self.jid.clone(), &xmpp_config.password).await?;
        
        // Configurer les handlers
        self.setup_message_handlers().await?;
        
        // Se connecter et authentifier
        self.client.connect().await?;
        
        // R√©cup√©rer la liste de contacts (roster)
        self.sync_roster().await?;
        
        Ok(())
    }
    
    async fn send_message(&mut self, msg: UnifiedMessage) -> Result<MessageId, BridgeError> {
        // Convertir contact Miaou vers JID XMPP
        let recipient_jid = self.get_jid_for_contact(&msg.recipient)?;
        
        // Cr√©er message XMPP
        let xmpp_message = match msg.content {
            MessageContent::Text(text) => {
                xmpp::Element::builder("message")
                    .attr("to", recipient_jid.to_string())
                    .attr("type", "chat")
                    .attr("id", msg.id.to_string())
                    .append(
                        xmpp::Element::builder("body")
                            .append(text)
                    )
                    .build()
            },
            MessageContent::Image { data, mime_type, caption } => {
                // Utiliser XEP-0363 (HTTP File Upload) pour les images
                self.send_media_via_http_upload(&data, &mime_type, caption.as_deref(), &recipient_jid).await?
            },
            _ => return Err(BridgeError::UnsupportedMessageType),
        };
        
        // Envoyer via XMPP
        self.client.send_stanza(xmpp_message).await?;
        
        Ok(msg.id)
    }
    
    async fn get_contacts(&self) -> Result<Vec<Contact>, BridgeError> {
        let mut contacts = Vec::new();
        
        // R√©cup√©rer le roster XMPP
        let roster_items = self.client.get_roster().await?;
        
        for item in roster_items {
            contacts.push(Contact {
                id: ContactId::from(item.jid.to_string()),
                display_name: item.name.unwrap_or_else(|| item.jid.node().unwrap_or("Unknown").to_string()),
                avatar_url: None, // N√©cessiterait XEP-0153 (vCard-Based Avatars)
                bridge_id: BridgeId::XMPP,
                bridge_specific_data: Some(json!({
                    "jid": item.jid.to_string(),
                    "subscription": format!("{:?}", item.subscription),
                    "groups": item.groups,
                })),
            });
        }
        
        Ok(contacts)
    }
}
```

---

## üì± Ponts Messageries Populaires

### **Bridge WhatsApp (via WhatsApp Business API)**
```rust
pub struct WhatsAppBridge {
    api_client: WhatsAppBusinessClient,
    phone_number_id: String,
    webhook_verifier: WebhookVerifier,
    media_uploader: MediaUploader,
}

impl WhatsAppBridge {
    pub async fn new(config: WhatsAppConfig) -> Result<Self, WhatsAppBridgeError> {
        let api_client = WhatsAppBusinessClient::new(
            &config.access_token,
            &config.business_account_id
        );
        
        // V√©rifier la validit√© des credentials
        api_client.verify_credentials().await?;
        
        Ok(WhatsAppBridge {
            api_client,
            phone_number_id: config.phone_number_id,
            webhook_verifier: WebhookVerifier::new(&config.webhook_verify_token),
            media_uploader: MediaUploader::new(&config.access_token),
        })
    }
}

#[async_trait]
impl MessageBridge for WhatsAppBridge {
    async fn send_message(&mut self, msg: UnifiedMessage) -> Result<MessageId, BridgeError> {
        // Extraire le num√©ro de t√©l√©phone du contact
        let recipient_phone = self.extract_phone_number(&msg.recipient)?;
        
        let whatsapp_message = match msg.content {
            MessageContent::Text(text) => {
                WhatsAppMessage::Text {
                    to: recipient_phone,
                    text: WhatsAppTextMessage {
                        body: text,
                        preview_url: false,
                    }
                }
            },
            
            MessageContent::Image { data, mime_type, caption } => {
                // Upload de l'image vers WhatsApp
                let media_id = self.media_uploader.upload_image(&data, &mime_type).await?;
                
                WhatsAppMessage::Image {
                    to: recipient_phone,
                    image: WhatsAppImageMessage {
                        id: media_id,
                        caption,
                    }
                }
            },
            
            MessageContent::File { data, filename, mime_type } => {
                let media_id = self.media_uploader.upload_document(&data, &filename, &mime_type).await?;
                
                WhatsAppMessage::Document {
                    to: recipient_phone,
                    document: WhatsAppDocumentMessage {
                        id: media_id,
                        filename: Some(filename),
                        caption: None,
                    }
                }
            },
            
            MessageContent::Audio { data, .. } => {
                let media_id = self.media_uploader.upload_audio(&data).await?;
                
                WhatsAppMessage::Audio {
                    to: recipient_phone,
                    audio: WhatsAppAudioMessage {
                        id: media_id,
                    }
                }
            },
            
            MessageContent::Location { latitude, longitude, address } => {
                WhatsAppMessage::Location {
                    to: recipient_phone,
                    location: WhatsAppLocationMessage {
                        latitude,
                        longitude,
                        name: address.clone(),
                        address,
                    }
                }
            },
            
            _ => return Err(BridgeError::UnsupportedMessageType),
        };
        
        // Envoyer via l'API WhatsApp Business
        let response = self.api_client.send_message(&whatsapp_message).await?;
        
        Ok(MessageId::from(response.messages[0].id.clone()))
    }
    
    fn message_stream(&self) -> Pin<Box<dyn Stream<Item = UnifiedMessage> + Send>> {
        // WhatsApp utilise des webhooks pour les messages entrants
        // Cette stream √©coute sur un endpoint HTTP local
        let (tx, rx) = tokio::sync::mpsc::unbounded_channel();
        let webhook_verifier = self.webhook_verifier.clone();
        
        tokio::spawn(async move {
            // D√©marrer un serveur HTTP pour recevoir les webhooks
            let app = axum::Router::new()
                .route("/webhook", axum::routing::post(handle_whatsapp_webhook))
                .route("/webhook", axum::routing::get(verify_whatsapp_webhook))
                .with_state((tx, webhook_verifier));
            
            let listener = tokio::net::TcpListener::bind("0.0.0.0:8080").await.unwrap();
            axum::serve(listener, app).await.unwrap();
        });
        
        Box::pin(tokio_stream::wrappers::UnboundedReceiverStream::new(rx))
    }
    
    fn get_capabilities(&self) -> BridgeCapabilities {
        BridgeCapabilities {
            supports_encryption: false, // WhatsApp g√®re √ßa c√¥t√© serveur
            supports_media: true,
            supports_groups: true,
            supports_typing_indicators: false,
            supports_read_receipts: true,
            max_message_size: 4096, // Limite WhatsApp Business API
            supported_media_types: vec![
                "image/jpeg".to_string(),
                "image/png".to_string(),
                "audio/mpeg".to_string(),
                "audio/ogg".to_string(),
                "video/mp4".to_string(),
                "application/pdf".to_string(),
            ],
        }
    }
}

// Handler webhook pour messages entrants WhatsApp
async fn handle_whatsapp_webhook(
    State((tx, verifier)): State<(UnboundedSender<UnifiedMessage>, WebhookVerifier)>,
    headers: HeaderMap,
    body: Bytes,
) -> impl IntoResponse {
    // V√©rifier la signature du webhook
    if let Some(signature) = headers.get("X-Hub-Signature-256") {
        if !verifier.verify_signature(&body, signature.to_str().unwrap_or("")) {
            return StatusCode::UNAUTHORIZED;
        }
    } else {
        return StatusCode::UNAUTHORIZED;
    }
    
    // Parser le payload WhatsApp
    let webhook_payload: WhatsAppWebhookPayload = match serde_json::from_slice(&body) {
        Ok(payload) => payload,
        Err(_) => return StatusCode::BAD_REQUEST,
    };
    
    // Convertir les messages WhatsApp en UnifiedMessage
    for entry in webhook_payload.entry {
        for change in entry.changes {
            if let WhatsAppChange::Messages { value } = change {
                for message in value.messages {
                    if let Some(unified_msg) = convert_whatsapp_to_unified(&message, &value.metadata).await {
                        if tx.send(unified_msg).is_err() {
                            eprintln!("‚ùå Erreur envoi message WhatsApp vers Miaou");
                        }
                    }
                }
            }
        }
    }
    
    StatusCode::OK
}
```

### **Bridge Signal (via libsignal-client)**
```rust
pub struct SignalBridge {
    signal_client: SignalClient,
    identity_store: IdentityKeyStore,
    session_store: SessionStore,
    prekey_store: PreKeyStore,
    account_manager: AccountManager,
}

impl SignalBridge {
    pub async fn new(config: SignalConfig) -> Result<Self, SignalBridgeError> {
        // Initialiser les stores Signal
        let identity_store = SqliteIdentityKeyStore::new(&config.db_path).await?;
        let session_store = SqliteSessionStore::new(&config.db_path).await?;
        let prekey_store = SqlitePreKeyStore::new(&config.db_path).await?;
        
        // Cr√©er le client Signal
        let signal_client = SignalClient::new(
            &config.signal_server_url,
            &config.user_uuid,
            &config.password,
            identity_store.clone(),
            session_store.clone(),
            prekey_store.clone(),
        ).await?;
        
        let account_manager = AccountManager::new(
            &signal_client,
            identity_store.clone(),
        );
        
        Ok(SignalBridge {
            signal_client,
            identity_store,
            session_store,
            prekey_store,
            account_manager,
        })
    }
}

#[async_trait]
impl MessageBridge for SignalBridge {
    async fn initialize(&mut self, config: BridgeConfig) -> Result<(), BridgeError> {
        let signal_config = config.as_signal_config()?;
        
        // Enregistrement/authentification avec le serveur Signal
        if signal_config.needs_registration {
            self.register_with_signal(&signal_config.phone_number).await?;
        } else {
            self.authenticate_with_signal().await?;
        }
        
        // G√©n√©rer et uploader les prekeys
        self.generate_and_upload_prekeys().await?;
        
        // D√©marrer l'√©coute des messages
        self.start_message_listener().await?;
        
        Ok(())
    }
    
    async fn send_message(&mut self, msg: UnifiedMessage) -> Result<MessageId, BridgeError> {
        // R√©soudre l'adresse Signal du destinataire
        let recipient_address = self.resolve_signal_address(&msg.recipient).await?;
        
        // Cr√©er le message Signal
        let signal_content = match msg.content {
            MessageContent::Text(text) => {
                DataMessage {
                    body: Some(text),
                    timestamp: Some(msg.timestamp.timestamp_millis() as u64),
                    ..Default::default()
                }
            },
            
            MessageContent::Image { data, mime_type, caption } => {
                // Upload de l'attachment
                let attachment_pointer = self.upload_attachment(&data, &mime_type).await?;
                
                DataMessage {
                    body: caption,
                    attachments: vec![attachment_pointer],
                    timestamp: Some(msg.timestamp.timestamp_millis() as u64),
                    ..Default::default()
                }
            },
            
            MessageContent::Reaction { target_message_id, emoji } => {
                let reaction = Reaction {
                    emoji: Some(emoji),
                    author_uuid: Some(self.get_local_uuid().await?),
                    target_author_uuid: Some(self.get_message_author(&target_message_id).await?),
                    target_sent_timestamp: Some(self.get_message_timestamp(&target_message_id).await?),
                    ..Default::default()
                };
                
                DataMessage {
                    reaction: Some(reaction),
                    timestamp: Some(msg.timestamp.timestamp_millis() as u64),
                    ..Default::default()
                }
            },
            
            _ => return Err(BridgeError::UnsupportedMessageType),
        };
        
        // Chiffrer et envoyer via Signal
        let encrypted_message = self.encrypt_message(&signal_content, &recipient_address).await?;
        let response = self.signal_client.send_message(&recipient_address, &encrypted_message).await?;
        
        Ok(MessageId::from(response.timestamp.to_string()))
    }
    
    async fn encrypt_message(
        &self, 
        content: &DataMessage, 
        recipient: &ProtocolAddress
    ) -> Result<Vec<u8>, SignalError> {
        // Utiliser libsignal pour le chiffrement E2EE
        let session_cipher = SessionCipher::new(
            &self.session_store,
            &self.prekey_store,
            &self.identity_store,
            recipient,
        );
        
        let serialized_content = content.encode_to_vec();
        let ciphertext = session_cipher.encrypt(&serialized_content).await?;
        
        Ok(ciphertext.serialize())
    }
    
    fn get_capabilities(&self) -> BridgeCapabilities {
        BridgeCapabilities {
            supports_encryption: true, // Signal a son propre E2EE
            supports_media: true,
            supports_groups: true,
            supports_typing_indicators: true,
            supports_read_receipts: true,
            max_message_size: 65536,
            supported_media_types: vec![
                "image/*".to_string(),
                "video/*".to_string(),
                "audio/*".to_string(),
                "application/*".to_string(),
            ],
        }
    }
}
```

---

## üìß Syst√®me d'Invitations Cross-Platform

### **Gestionnaire d'invitations unifi√©**
```rust
pub struct CrossPlatformInviter {
    bridges: Arc<BridgeManager>,
    invitation_templates: InvitationTemplateManager,
    campaign_tracker: CampaignTracker,
    platform_analyzers: HashMap<Platform, Box<dyn PlatformAnalyzer>>,
}

impl CrossPlatformInviter {
    pub async fn send_smart_invitation(
        &mut self, 
        invitation_request: InvitationRequest
    ) -> Result<InvitationCampaign, InvitationError> {
        // 1. Analyser le contact pour d√©terminer les meilleures plateformes
        let contact_analysis = self.analyze_contact(&invitation_request.contact).await?;
        
        // 2. Planifier une campagne multi-plateforme
        let campaign = self.plan_invitation_campaign(&contact_analysis, &invitation_request).await?;
        
        // 3. Ex√©cuter la campagne avec timing optimal
        self.execute_campaign(&campaign).await?;
        
        // 4. Suivre les m√©triques de conversion
        self.campaign_tracker.start_tracking(&campaign).await?;
        
        Ok(campaign)
    }
    
    async fn analyze_contact(&self, contact: &ContactInfo) -> Result<ContactAnalysis, InvitationError> {
        let mut available_platforms = Vec::new();
        let mut platform_preferences = HashMap::new();
        
        // Analyser selon le type de contact
        match contact {
            ContactInfo::Email(email) => {
                available_platforms.push(Platform::Email);
                
                // D√©tecter plateformes probables selon le domaine email
                if email.ends_with("@gmail.com") || email.ends_with("@googlemail.com") {
                    platform_preferences.insert(Platform::Email, 0.9);
                    platform_preferences.insert(Platform::WhatsApp, 0.7); // Probable Android
                }
                
                if email.ends_with("@icloud.com") || email.ends_with("@me.com") {
                    platform_preferences.insert(Platform::Email, 0.9);
                    // platform_preferences.insert(Platform::iMessage, 0.8); // iOS user
                }
            },
            
            ContactInfo::Phone(phone) => {
                available_platforms.extend([Platform::SMS, Platform::WhatsApp, Platform::Telegram]);
                
                // Analyser le format du num√©ro pour d√©tecter le pays/r√©gion
                let country_code = extract_country_code(phone)?;
                
                match country_code.as_str() {
                    "+33" | "+49" | "+39" => { // Europe - WhatsApp tr√®s populaire
                        platform_preferences.insert(Platform::WhatsApp, 0.9);
                        platform_preferences.insert(Platform::Telegram, 0.6);
                        platform_preferences.insert(Platform::SMS, 0.4);
                    },
                    "+1" => { // US/Canada - plus de diversit√©
                        platform_preferences.insert(Platform::SMS, 0.8);
                        platform_preferences.insert(Platform::WhatsApp, 0.6);
                        // platform_preferences.insert(Platform::iMessage, 0.5);
                    },
                    "+86" => { // Chine - WeChat dominant
                        platform_preferences.insert(Platform::SMS, 0.7);
                        // platform_preferences.insert(Platform::WeChat, 0.9);
                    },
                    _ => {
                        platform_preferences.insert(Platform::WhatsApp, 0.7);
                        platform_preferences.insert(Platform::SMS, 0.6);
                    }
                }
            },
            
            ContactInfo::SocialMedia { platform, handle } => {
                available_platforms.push(platform.clone());
                platform_preferences.insert(platform.clone(), 1.0);
                
                // Cross-platform inference
                match platform {
                    Platform::Instagram => {
                        platform_preferences.insert(Platform::WhatsApp, 0.8); // Meta ecosystem
                    },
                    Platform::Twitter => {
                        platform_preferences.insert(Platform::Telegram, 0.6); // Tech-savvy users
                    },
                    _ => {}
                }
            },
            
            ContactInfo::Matrix(matrix_id) => {
                available_platforms.push(Platform::Matrix);
                platform_preferences.insert(Platform::Matrix, 1.0);
                
                // Les utilisateurs Matrix sont souvent tech-savvy
                platform_preferences.insert(Platform::Signal, 0.8);
                platform_preferences.insert(Platform::XMPP, 0.6);
            }
        }
        
        Ok(ContactAnalysis {
            available_platforms,
            platform_preferences,
            estimated_tech_level: self.estimate_tech_level(contact),
            optimal_contact_times: self.get_optimal_contact_times(contact).await?,
        })
    }
    
    async fn plan_invitation_campaign(
        &self, 
        analysis: &ContactAnalysis, 
        request: &InvitationRequest
    ) -> Result<InvitationCampaign, InvitationError> {
        let mut campaign_steps = Vec::new();
        
        // Trier les plateformes par probabilit√© de succ√®s
        let mut platforms: Vec<_> = analysis.platform_preferences.iter().collect();
        platforms.sort_by(|a, b| b.1.partial_cmp(a.1).unwrap());
        
        // Planifier la s√©quence d'invitations
        for (i, (platform, probability)) in platforms.iter().enumerate() {
            if *probability > 0.5 { // Seuil minimum
                let delay = if i == 0 { 
                    Duration::seconds(0) // Premi√®re invitation imm√©diate
                } else { 
                    Duration::days(2 * i as i64) // Espacement progressif
                };
                
                campaign_steps.push(CampaignStep {
                    platform: (*platform).clone(),
                    delay,
                    template: self.select_template_for_platform(platform, &analysis.estimated_tech_level)?,
                    expected_success_probability: *probability,
                });
            }
        }
        
        // Ajuster selon les pr√©f√©rences de l'exp√©diteur
        if let Some(preferred_platform) = &request.preferred_platform {
            // Prioriser la plateforme pr√©f√©r√©e
            campaign_steps.sort_by_key(|step| {
                if &step.platform == preferred_platform { 0 } else { 1 }
            });
        }
        
        Ok(InvitationCampaign {
            id: CampaignId::new(),
            steps: campaign_steps,
            contact: request.contact.clone(),
            referral_code: request.referral_code.clone(),
            created_at: Utc::now(),
            status: CampaignStatus::Planned,
        })
    }
    
    async fn execute_campaign(&mut self, campaign: &InvitationCampaign) -> Result<(), InvitationError> {
        for (index, step) in campaign.steps.iter().enumerate() {
            // Attendre le d√©lai sp√©cifi√©
            if step.delay > Duration::zero() {
                tokio::time::sleep(step.delay.to_std().unwrap()).await;
            }
            
            // V√©rifier si la campagne doit continuer
            if self.should_stop_campaign(&campaign.id).await? {
                break; // L'utilisateur a d√©j√† rejoint via une invitation pr√©c√©dente
            }
            
            // Cr√©er l'invitation personnalis√©e
            let invitation = Invitation {
                campaign_id: campaign.id.clone(),
                step_index: index,
                platform: step.platform.clone(),
                contact: campaign.contact.clone(),
                referral_code: campaign.referral_code.clone(),
                template: step.template.clone(),
                personal_message: self.generate_personal_message(&step, index).await?,
            };
            
            // Envoyer l'invitation via le bridge appropri√©
            match self.send_invitation_via_bridge(&invitation).await {
                Ok(result) => {
                    self.campaign_tracker.record_step_success(&campaign.id, index, &result).await?;
                    
                    // Si c'est un canal temps-r√©el (WhatsApp, Telegram), surveiller la r√©ponse
                    if step.platform.supports_real_time_responses() {
                        self.setup_response_monitoring(&invitation).await?;
                    }
                },
                Err(e) => {
                    self.campaign_tracker.record_step_failure(&campaign.id, index, &e).await?;
                    eprintln!("‚ö†Ô∏è √âchec invitation {} √©tape {}: {}", campaign.id, index, e);
                }
            }
        }
        
        Ok(())
    }
    
    async fn send_invitation_via_bridge(&mut self, invitation: &Invitation) -> Result<InvitationResult, InvitationError> {
        let bridge_id = BridgeId::from_platform(&invitation.platform);
        
        // Cr√©er le message d'invitation personnalis√©
        let invitation_message = self.create_invitation_message(invitation)?;
        
        // Envoyer via le bridge appropri√©
        let message_id = self.bridges.send_unified_message(invitation_message).await?;
        
        Ok(InvitationResult {
            message_id,
            platform: invitation.platform.clone(),
            estimated_delivery_time: self.estimate_delivery_time(&invitation.platform),
            tracking_url: self.generate_tracking_url(invitation)?,
        })
    }
}

#[derive(Debug, Clone)]
pub struct InvitationTemplate {
    pub subject: Option<String>, // Pour email
    pub content: String,
    pub call_to_action: String,
    pub tech_level: TechLevel,
    pub tone: MessageTone,
}

impl InvitationTemplateManager {
    pub fn get_template(&self, platform: &Platform, tech_level: &TechLevel) -> InvitationTemplate {
        match (platform, tech_level) {
            (Platform::Email, TechLevel::Beginner) => InvitationTemplate {
                subject: Some("üê± {referrer_name} t'invite sur Miaou - messagerie priv√©e".to_string()),
                content: r#"
Salut !

{referrer_name} t'invite √† rejoindre Miaou, une messagerie qui respecte ta vie priv√©e.

üîê Tes messages sont chiffr√©s et personne d'autre ne peut les lire
üåç Pas de serveur central qui espionne tes conversations  
üéÅ Tu re√ßois 100 croquettes de bienvenue en rejoignant avec ce code

üéØ Ton code de parrainage : {referral_code}

Pour commencer :
1. T√©l√©charge Miaou sur ton ordinateur ou t√©l√©phone
2. Utilise le code {referral_code} lors de l'inscription
3. Commence √† discuter en toute s√©curit√© !

üëâ T√©l√©charger : {download_link}

{personal_message}

√Ä bient√¥t sur Miaou ! üê±

P.S. : Si tu as des questions, r√©ponds simplement √† cet email.
                "#.trim().to_string(),
                call_to_action: "T√©l√©charger Miaou".to_string(),
                tech_level: TechLevel::Beginner,
                tone: MessageTone::Friendly,
            },
            
            (Platform::WhatsApp, TechLevel::Intermediate) => InvitationTemplate {
                subject: None,
                content: r#"
Hey ! üëã

J'utilise Miaou pour mes messages priv√©s et c'est top ! 

üîê Chiffr√© de bout en bout (comme WhatsApp mais en mieux)
üåç D√©centralis√© (pas de Meta qui lit tout)
üéÆ Tu gagnes des croquettes en participant

Code parrainage : *{referral_code}*

{download_link}

{personal_message}

√áa te dit d'essayer ? üê±
                "#.trim().to_string(),
                call_to_action: "Installer Miaou".to_string(),
                tech_level: TechLevel::Intermediate,
                tone: MessageTone::Casual,
            },
            
            (Platform::Matrix, TechLevel::Expert) => InvitationTemplate {
                subject: None,
                content: r#"
Salut !

Je teste Miaou, une messagerie P2P en Rust avec chiffrement Signal Protocol.

- E2EE par d√©faut avec Perfect Forward Secrecy
- R√©seau d√©centralis√© sans point de failure unique  
- Interop√©rabilit√© Matrix/XMPP/IRC
- Architecture modulaire avec ~70 crates
- √âconomie tokenis√©e pour l'anti-spam

Referral code: `{referral_code}`

Repo: https://github.com/miaou-chat/miaou
Builds: {download_link}

{personal_message}

Feedback welcome! ü¶Ä
                "#.trim().to_string(),
                call_to_action: "git clone && cargo build".to_string(),
                tech_level: TechLevel::Expert,
                tone: MessageTone::Technical,
            },
            
            _ => self.get_default_template(platform),
        }
    }
}
```

---

## üì± Fonctions Sociales Int√©gr√©es

### **Agr√©gateur de contenu social**
```rust
pub struct SocialAggregator {
    platform_feeds: HashMap<SocialPlatform, Box<dyn SocialFeed>>,
    content_cache: ContentCache,
    privacy_filter: PrivacyFilter,
    user_preferences: UserPreferences,
}

#[derive(Debug, Clone)]
pub enum SocialPlatform {
    Mastodon,
    Twitter,
    Reddit,
    LinkedIn,
    Instagram,
    Facebook,
    YouTube,
    GitHub,
}

pub trait SocialFeed: Send + Sync {
    async fn authenticate(&mut self, credentials: SocialCredentials) -> Result<(), SocialError>;
    async fn get_timeline(&self, params: TimelineParams) -> Result<Vec<SocialPost>, SocialError>;
    async fn get_user_posts(&self, user_id: &str, limit: usize) -> Result<Vec<SocialPost>, SocialError>;
    async fn search_posts(&self, query: &str, filters: SearchFilters) -> Result<Vec<SocialPost>, SocialError>;
    fn get_platform_info(&self) -> SocialPlatformInfo;
}

#[derive(Debug, Clone)]
pub struct SocialPost {
    pub id: String,
    pub platform: SocialPlatform,
    pub author: SocialAuthor,
    pub content: SocialContent,
    pub timestamp: DateTime<Utc>,
    pub engagement: EngagementMetrics,
    pub privacy_level: PrivacyLevel,
    pub metadata: PostMetadata,
}

impl SocialAggregator {
    pub async fn create_unified_feed(&self, user_id: &UserId) -> Result<UnifiedFeed, SocialError> {
        let preferences = self.user_preferences.get_preferences(user_id).await?;
        let mut all_posts = Vec::new();
        
        // Collecter les posts de chaque plateforme configur√©e
        for (platform, feed) in &self.platform_feeds {
            if preferences.enabled_platforms.contains(platform) {
                match feed.get_timeline(TimelineParams {
                    limit: preferences.posts_per_platform,
                    since: preferences.last_sync_time,
                    include_retweets: preferences.include_shares,
                    include_replies: preferences.include_replies,
                }).await {
                    Ok(posts) => {
                        // Filtrer selon les pr√©f√©rences de confidentialit√©
                        let filtered_posts = self.privacy_filter.filter_posts(&posts, &preferences.privacy_settings);
                        all_posts.extend(filtered_posts);
                    },
                    Err(e) => {
                        eprintln!("‚ö†Ô∏è Erreur r√©cup√©ration posts {} : {}", platform, e);
                    }
                }
            }
        }
        
        // Trier par pertinence et fra√Æcheur
        all_posts.sort_by(|a, b| {
            let score_a = self.calculate_relevance_score(a, &preferences);
            let score_b = self.calculate_relevance_score(b, &preferences);
            score_b.partial_cmp(&score_a).unwrap_or(std::cmp::Ordering::Equal)
        });
        
        // Limiter au nombre souhait√©
        all_posts.truncate(preferences.max_total_posts);
        
        Ok(UnifiedFeed {
            posts: all_posts,
            generated_at: Utc::now(),
            next_refresh: Utc::now() + Duration::minutes(preferences.refresh_interval_minutes),
        })
    }
    
    pub async fn publish_to_platforms(
        &mut self,
        content: &SocialContent,
        target_platforms: &[SocialPlatform],
        scheduling: PublishingSchedule,
    ) -> Result<PublishingResult, SocialError> {
        let mut results = HashMap::new();
        
        for platform in target_platforms {
            if let Some(feed) = self.platform_feeds.get_mut(platform) {
                // Adapter le contenu selon la plateforme
                let adapted_content = self.adapt_content_for_platform(content, platform)?;
                
                // Planifier ou publier imm√©diatement
                let result = match &scheduling {
                    PublishingSchedule::Immediate => {
                        self.publish_immediately(feed.as_mut(), &adapted_content).await
                    },
                    PublishingSchedule::Delayed { publish_at } => {
                        self.schedule_publication(platform, &adapted_content, *publish_at).await
                    },
                    PublishingSchedule::Optimal => {
                        let optimal_time = self.calculate_optimal_posting_time(platform).await?;
                        self.schedule_publication(platform, &adapted_content, optimal_time).await
                    },
                };
                
                results.insert(platform.clone(), result);
            }
        }
        
        Ok(PublishingResult {
            results,
            published_at: Utc::now(),
        })
    }
    
    fn calculate_relevance_score(&self, post: &SocialPost, preferences: &UserPreferences) -> f64 {
        let mut score = 0.0;
        
        // Score de fra√Æcheur (d√©cro√Æt avec le temps)
        let age_hours = (Utc::now() - post.timestamp).num_hours() as f64;
        let freshness_score = 1.0 / (1.0 + age_hours / 24.0); // D√©croissance exponentielle
        score += freshness_score * 0.3;
        
        // Score d'engagement
        let engagement_score = (post.engagement.likes as f64).log10() / 10.0 + 
                              (post.engagement.shares as f64).log10() / 5.0 +
                              (post.engagement.comments as f64).log10() / 8.0;
        score += engagement_score.min(1.0) * 0.4;
        
        // Score de pertinence selon mots-cl√©s
        let content_text = format!("{} {}", post.content.text.as_ref().unwrap_or(&String::new()), post.content.summary.as_ref().unwrap_or(&String::new()));
        for keyword in &preferences.interest_keywords {
            if content_text.to_lowercase().contains(&keyword.to_lowercase()) {
                score += 0.2;
            }
        }
        
        // P√©nalit√© pour contenus ind√©sirables
        for blocked_word in &preferences.blocked_keywords {
            if content_text.to_lowercase().contains(&blocked_word.to_lowercase()) {
                score -= 0.5;
            }
        }
        
        // Bonus pour auteurs suivis/pr√©f√©r√©s
        if preferences.preferred_authors.contains(&post.author.id) {
            score += 0.3;
        }
        
        score.max(0.0).min(2.0)
    }
}

// Impl√©mentation Mastodon feed
pub struct MastodonFeed {
    client: mastodon_async::Mastodon,
    instance_url: String,
}

#[async_trait]
impl SocialFeed for MastodonFeed {
    async fn authenticate(&mut self, credentials: SocialCredentials) -> Result<(), SocialError> {
        let mastodon_creds = credentials.as_mastodon_credentials()?;
        
        let registration = Registration::new(&self.instance_url)
            .client_name("Miaou Social Aggregator")
            .scopes(Scopes::read_all())
            .website("https://miaou.chat")
            .build()
            .await?;
        
        let mastodon = registration.authorize_token(&mastodon_creds.access_token).await?;
        self.client = mastodon;
        
        Ok(())
    }
    
    async fn get_timeline(&self, params: TimelineParams) -> Result<Vec<SocialPost>, SocialError> {
        let mut timeline_params = mastodon_async::TimelineOptions::default();
        timeline_params.limit = Some(params.limit as u64);
        
        if let Some(since_id) = params.since_id {
            timeline_params.since_id = Some(since_id);
        }
        
        let statuses = self.client.get_home_timeline(timeline_params).await?;
        
        let posts = statuses.into_iter().map(|status| {
            SocialPost {
                id: status.id,
                platform: SocialPlatform::Mastodon,
                author: SocialAuthor {
                    id: status.account.id,
                    username: status.account.username,
                    display_name: status.account.display_name,
                    avatar_url: status.account.avatar,
                },
                content: SocialContent {
                    text: Some(strip_html_tags(&status.content)),
                    html: Some(status.content),
                    media_attachments: status.media_attachments.into_iter().map(|media| {
                        MediaAttachment {
                            url: media.url,
                            media_type: match media.r#type {
                                mastodon_async::entities::attachment::MediaType::Image => MediaType::Image,
                                mastodon_async::entities::attachment::MediaType::Video => MediaType::Video,
                                mastodon_async::entities::attachment::MediaType::Audio => MediaType::Audio,
                                _ => MediaType::Unknown,
                            },
                            description: media.description,
                        }
                    }).collect(),
                    summary: None,
                },
                timestamp: status.created_at,
                engagement: EngagementMetrics {
                    likes: status.favourites_count.unwrap_or(0) as u32,
                    shares: status.reblogs_count.unwrap_or(0) as u32,
                    comments: status.replies_count.unwrap_or(0) as u32,
                },
                privacy_level: match status.visibility {
                    mastodon_async::Visibility::Public => PrivacyLevel::Public,
                    mastodon_async::Visibility::Unlisted => PrivacyLevel::Unlisted,
                    mastodon_async::Visibility::Private => PrivacyLevel::FollowersOnly,
                    mastodon_async::Visibility::Direct => PrivacyLevel::Direct,
                },
                metadata: PostMetadata {
                    language: status.language,
                    sensitive: status.sensitive.unwrap_or(false),
                    spoiler_text: status.spoiler_text,
                    tags: status.tags.into_iter().map(|tag| tag.name).collect(),
                },
            }
        }).collect();
        
        Ok(posts)
    }
    
    fn get_platform_info(&self) -> SocialPlatformInfo {
        SocialPlatformInfo {
            name: "Mastodon".to_string(),
            max_post_length: 500, // Varie selon l'instance
            supports_media: true,
            supports_polls: true,
            supports_threads: true,
            rate_limits: RateLimits {
                posts_per_hour: 60,
                requests_per_minute: 30,
            },
        }
    }
}
```

---

## üìä M√©triques et Crit√®res de Succ√®s

### **KPIs Bridges**
- ‚úÖ **Bridge Matrix** fonctionnel avec E2EE pr√©serv√©
- ‚úÖ **Bridge XMPP** compatible serveurs majeurs
- ‚úÖ **Bridge WhatsApp Business** avec webhooks
- ‚úÖ **Bridge Signal** avec libsignal-client
- ‚úÖ **Isolation s√©curis√©e** entre bridges
- ‚úÖ **Conversion de formats** sans perte d'information

### **KPIs Invitations**
- ‚úÖ **D√©tection automatique** plateformes optimales
- ‚úÖ **Campagnes multi-√©tapes** avec timing intelligent
- ‚úÖ **Taux de conversion >= 15%** (vs 5% industrie)
- ‚úÖ **Templates adaptatifs** selon niveau technique
- ‚úÖ **Tracking complet** du funnel d'acquisition

### **KPIs Fonctions Sociales**
- ‚úÖ **Agr√©gation >= 5 plateformes** sociales
- ‚úÖ **Publication cross-platform** automatis√©e
- ‚úÖ **Filtrage intelligent** par pr√©f√©rences
- ‚úÖ **Isolation compl√®te** donn√©es sociales/messagerie

---

## üöÄ Livrables de la Version

### **üì¶ Nouveaux modules**
- `libmiaou-bridges` : Framework de bridges universel
- `libmiaou-matrix` : Bridge Matrix complet
- `libmiaou-xmpp` : Bridge XMPP/Jabber
- `libmiaou-whatsapp` : Bridge WhatsApp Business
- `libmiaou-signal` : Bridge Signal
- `libmiaou-social` : Agr√©gateur social
- `libmiaou-invitations` : Syst√®me d'invitations intelligent

### **üåâ Bridges fonctionnels**
- Matrix avec E2EE pr√©serv√©
- XMPP avec support multi-serveurs
- WhatsApp Business avec webhooks
- Signal avec libsignal-client
- Discord via API (optionnel)

### **üì± Fonctionnalit√©s sociales**
- Agr√©gation Mastodon, Twitter, Reddit
- Publication cross-platform
- Fil d'actualit√©s unifi√©
- Isolation totale donn√©es priv√©es/publiques

---

## üóìÔ∏è Pr√©paration v0.6.0

Cette version pr√©pare la **v0.6.0 "Neuf Vies"** qui ajoutera :
- Partage de fichiers P2P avec chunking
- Communications audio/vid√©o WebRTC chiffr√©es
- Groupes et channels avec mod√©ration
- M√©canismes anti-censure et r√©sistance

**L'interop√©rabilit√© de la v0.5.0 connecte tous les territoires** - la v0.6.0 rendra Miaou indestructible ! üõ°Ô∏è

---

*Le chat de goutti√®re a explor√© tous les territoires... Miaou unit maintenant tous les mondes de la communication !* üê±üåç