# 🐱 Version 0.1.0 "Première Griffe"
## *Quand le chaton montre ses crocs*

> **Phase 1 : Fondations techniques** - Établir l'infrastructure de base sécurisée et modulaire

---

## 🎯 Vision de cette version

La **Première Griffe** représente le moment où Miaou passe de l'idée au premier prototype fonctionnel. Cette version pose les fondations technologiques incontournables : sécurité cryptographique, architecture modulaire et qualité de code irréprochable.

**Motto :** *"Sortir les griffes sur la complexité technique"*

---

## 🏗️ Architecture et Infrastructure

### **📦 Structure modulaire (Crates Rust)**
```
miaou-core/
├── 🔐 crypto/
│   ├── crypto-primitives/     # Wrappers ring + RustCrypto
│   ├── crypto-keyring/        # Gestion clés ed25519-dalek
│   ├── crypto-encryption/     # Chiffrement libsignal-protocol
│   ├── crypto-signature/      # Signatures Ed25519
│   └── crypto-hashing/        # SHA-3, BLAKE3, Argon2
├── 📦 core/
│   ├── miaou-types/          # Types de base et structures
│   ├── miaou-config/         # Configuration et profils
│   ├── miaou-storage/        # Stockage local sécurisé
│   └── miaou-protocol/       # Définition protocole Miaou
├── 🌐 network/
│   ├── network-discovery/    # Découverte pairs (préparation)
│   ├── network-protocol/     # Protocole réseau de base
│   └── network-transport/    # Transport sécurisé TLS
└── 🧪 testing/
    ├── test-framework/       # Framework tests personnalisé
    ├── test-crypto/          # Tests cryptographiques KAT
    └── test-mocks/           # Mocks et fixtures
```

### **🔌 Interfaces et Traits (Object-Safe, AAD obligatoire)**

**Corrections appliquées :**
- Tous les traits avec `&self` pour l'object safety
- AAD (Associated Authenticated Data) obligatoire pour AEAD
- Retour `Result<(), CryptoError>` pour `verify` (pas de masquage d'erreurs)
- Types opaques pour les clés (pas de Debug, Zeroize sur drop)
- Stockage typé pour éviter les collisions de clés string

```rust
/// 🔐 Fournit des primitives cryptographiques de haut niveau (AEAD, signatures)
/// ⚠️ Implémentations basées EXCLUSIVEMENT sur des bibliothèques auditées
pub trait CryptoProvider: Send + Sync {
    /// Chiffre avec XChaCha20-Poly1305 et AAD obligatoires
    /// - `aad`: données associées (version protocole, type message, flags)
    /// - Génère automatiquement un nonce 192-bit aléatoire
    fn seal(
        &self,
        key: &AeadKeyRef,
        aad: &[u8],  // OBLIGATOIRE - jamais vide
        plaintext: &[u8],
        rng: &mut dyn rand_core::RngCore,
    ) -> Result<SealedData, CryptoError>;

    /// Déchiffre et authentifie ; échoue si tag/nonce/AAD invalide
    fn open(
        &self,
        key: &AeadKeyRef,
        aad: &[u8],  // DOIT correspondre exactement au seal
        sealed: &SealedData,
    ) -> Result<Vec<u8>, CryptoError>;

    /// Signe avec Ed25519 (signature 64 bytes)
    fn sign(&self, sk: &SigningKeyRef, msg: &[u8]) -> Result<Signature, CryptoError>;

    /// Vérifie signature Ed25519 - RETOURNE ERREUR (pas bool)
    fn verify(&self, pk: &VerifyingKeyRef, msg: &[u8], sig: &Signature) -> Result<(), CryptoError>;
}

/// 🔑 Génère et gère le matériel cryptographique (object-safe)
pub trait KeyMaterial: Send + Sync {
    fn generate_identity(&self, rng: &mut dyn rand_core::RngCore) -> Result<IdentityKeys, CryptoError>;
    fn rotate_session_key(&self, rng: &mut dyn rand_core::RngCore) -> Result<AeadKey, CryptoError>;
}

/// 🗂️ Gestion des profils utilisateur (object-safe)
pub trait ProfileManager: Send + Sync {
    fn create_profile(&self, name: &str, password: &secrecy::SecretString) -> Result<ProfileId, ProfileError>;
    fn load_profile(&self, id: &ProfileId, password: &secrecy::SecretString) -> Result<Profile, ProfileError>;
    fn list_profiles(&self) -> Vec<ProfileInfo>;
    fn delete_profile(&self, id: &ProfileId) -> Result<(), ProfileError>;
}

/// 🗄️ Stockage sécurisé typé (évite collisions de clés string)
pub trait SecureStorage: Send + Sync {
    fn store(&self, namespace: Namespace, key: KeyId, data: &[u8]) -> Result<(), StorageError>;
    fn retrieve(&self, namespace: Namespace, key: KeyId) -> Result<Option<Vec<u8>>, StorageError>;
    fn delete(&self, namespace: Namespace, key: KeyId) -> Result<(), StorageError>;
    fn exists(&self, namespace: Namespace, key: KeyId) -> bool;
}

/// 📦 Types opaques sécurisés
#[derive(ZeroizeOnDrop)]
pub struct AeadKeyRef(Zeroizing<[u8; 32]>);

#[derive(ZeroizeOnDrop)]
pub struct SigningKeyRef(Zeroizing<[u8; 32]>);

pub struct VerifyingKeyRef([u8; 32]);

/// 📋 Données scellées avec nonce intégré
#[derive(Clone)]
pub struct SealedData {
    pub nonce: [u8; 24],     // XChaCha20 nonce 192-bit
    pub ciphertext: Vec<u8>, // Tag Poly1305 inclus
}

/// 🆔 Types typés pour le stockage
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Namespace {
    Profiles,
    Sessions,
    Config,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct KeyId(String);
```

---

## 🔐 Implémentation Cryptographique

### **Stack cryptographique cohérente (Option A : RustCrypto + Dalek)**

**Pourquoi cette stratégie :**
- Évite le mélange ring + dalek + RustCrypto qui cause des incompatibilités d'API
- Types cohérents pour nonces, clés, tags entre les crates
- XChaCha20-Poly1305 avec nonces 24 bytes pour réduire les risques de collision
- APIs object-safe avec `&self` pour le dynamic dispatch

```toml
[workspace.dependencies]
# 🔐 Cryptographie cohérente (Option A : RustCrypto + Dalek)
# AEAD avec XChaCha20 (nonces 192-bit, moins de contraintes d'unicité)
chacha20poly1305 = { version = "0.10", default-features = false, features = ["alloc", "rand_core", "xchacha20poly1305"] }

# Signatures et ECDH via Dalek (performance + audit)
ed25519-dalek = { version = "2", features = ["rand_core", "zeroize"] }
x25519-dalek = { version = "2", features = ["static_secrets"] }

# KDF et hachage
hkdf = "0.12"                   # HKDF pour dérivations session
blake3 = { version = "1", features = ["zeroize"] }
argon2 = "0.5"                  # Dérivation mots de passe

# Transport sécurisé (mis à jour)
rustls = { version = "0.23", default-features = true }  # TLS 1.3 + provider aws-lc-rs
tokio = { version = "1", features = ["rt-multi-thread", "macros", "net"] }

# Sécurité et gestion des secrets
zeroize = "1.7"                 # Nettoyage mémoire automatique
subtle = "2.5"                  # Opérations constant-time
secrecy = "0.8"                 # Gestion sécurisée des secrets
rand_core = "0.6"               # CSPRNG unifié

# Sérialisation et utilitaires
serde = { version = "1", features = ["derive"] }
serde_json = "1.0"              # Format JSON pour headers
hex = "0.4"                     # Encodage hexadécimal
thiserror = "1"
```

### **Algorithmes et Standards (cohérents)**
- **Chiffrement symétrique** : **XChaCha20-Poly1305** (AEAD étendu, nonces 192-bit)
  - Moins de contraintes d'unicité des nonces vs ChaCha20-Poly1305
  - Compatible avec déploiements distribués sans coordination
- **Signatures** : **Ed25519** (RFC 8032, courbes elliptiques)
- **Échange de clés** : **X25519** (RFC 7748, ECDH)
- **Hachage** : **BLAKE3** (ultra-rapide, zeroize, arbre Merkle)
- **Dérivation clés** : **Argon2id** (mots de passe) + **HKDF** (sessions)
- **Transport** : **TLS 1.3** (RFC 8446) via rustls 0.23 + aws-lc-rs provider

### **Sécurité par design**
```rust
// Zeroization automatique des secrets
#[derive(Zeroize, ZeroizeOnDrop)]
pub struct PrivateKey([u8; 32]);

// Pas de Debug sur les secrets
impl fmt::Debug for PrivateKey {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "PrivateKey([REDACTED])")
    }
}

// Comparaisons constant-time obligatoires
use subtle::ConstantTimeEq;
pub fn verify_signature(sig: &[u8], expected: &[u8]) -> bool {
    sig.ct_eq(expected).into()
}

// Validation stricte des entrées
pub fn parse_message(data: &[u8]) -> Result<Message, ParseError> {
    if data.len() < MIN_SIZE || data.len() > MAX_SIZE {
        return Err(ParseError::InvalidSize);
    }
    validate_format(data)?;
    safe_deserialize(data)
}
```

---

## 🧪 Qualité et Tests (Non-négociables)

### **Standards de qualité (adaptés v0.1)**
- **Couverture >= 90%** : Mesurée avec cargo-tarpaulin sur périmètre v0.1
- **Tests KAT** : Known Answer Tests avec vecteurs **IETF RFC 8439** (ChaCha20-Poly1305)
- **Tests de propriétés** : Avec proptest pour roundtrip encrypt/decrypt
- **Fuzzing ciblé** : Sur parseurs présents uniquement (pas de fuzz aveugle)
- **Linting strict** : clippy pedantic + deny warnings
- **Audit sécurité** : cargo-audit + cargo-deny (licences + advisories)

### **Framework de tests personnalisé**
```rust
// Tests crypto avec vecteurs IETF officiels (RFC 8439)
#[test]
fn test_xchacha20_poly1305_kat() {
    // Vecteurs de test XChaCha20-Poly1305 depuis draft IETF
    let test_vectors = load_ietf_vectors("xchacha20poly1305_ietf.json");
    for vector in test_vectors {
        let result = encrypt_xchacha20poly1305(
            &vector.key,     // 32 bytes
            &vector.nonce,   // 24 bytes (XChaCha)
            &vector.aad,     // Associated data (obligatoire)
            &vector.plaintext
        );
        assert_eq!(result.unwrap(), vector.expected_ciphertext);
    }
}

// Tests de propriétés pour encrypt/decrypt
proptest! {
    #[test]
    fn encrypt_decrypt_roundtrip(
        plaintext in any::<Vec<u8>>(),
        key in prop::array::uniform32(any::<u8>()),
        nonce in prop::array::uniform12(any::<u8>())
    ) {
        let encrypted = encrypt_message(&plaintext, &key, &nonce)?;
        let decrypted = decrypt_message(&encrypted, &key)?;
        prop_assert_eq!(plaintext, decrypted);
    }
}

// Fuzzing pour parseurs
#[cfg(test)]
mod fuzz_tests {
    use super::*;
    
    #[test]
    fn fuzz_message_parser() {
        use arbitrary::*;
        let data = generate_random_bytes(0..10000);
        // Ne doit jamais paniquer, même avec données malformées
        let _ = parse_message(&data);
    }
}
```

### **Pipeline CI/CD**
```yaml
# .github/workflows/quality.yml
name: Quality Gates
on: [push, pull_request]

jobs:
  tests:
    runs-on: ubuntu-latest
    steps:
      - name: Run tests
        run: cargo test --all-features
      
  coverage:
    runs-on: ubuntu-latest
    steps:
      - name: Coverage check
        run: |
          cargo tarpaulin --verbose --timeout 120
          # Fail si < 90%
          
  security:
    runs-on: ubuntu-latest
    steps:
      - name: Audit dependencies
        run: cargo audit
      - name: Lint security
        run: cargo clippy -- -D warnings -D clippy::pedantic
        
  fuzzing:
    runs-on: ubuntu-latest
    steps:
      - name: Install cargo-fuzz
        run: cargo install cargo-fuzz
      - name: Run fuzz tests
        run: cargo fuzz run parser_target -- -max_total_time=300
```

---

## 💬 Fonctionnalités de Base

### **Gestion des profils utilisateur**
```rust
// Création et gestion de profils chiffrés
pub struct ProfileManager {
    storage: Box<dyn SecureStorage>,
    crypto: Box<dyn CryptoEngine>,
}

impl ProfileManager {
    pub fn create_profile(&mut self, name: &str, password: &str) -> Result<ProfileId, ProfileError> {
        // 1. Générer salt unique pour Argon2
        let salt = generate_random_salt();
        
        // 2. Dériver clé de chiffrement depuis mot de passe
        let encryption_key = derive_key_argon2(password, &salt)?;
        
        // 3. Générer paire de clés Ed25519 pour identité
        let keypair = self.crypto.generate_keypair()?;
        
        // 4. Chiffrer clé privée avec clé dérivée
        let encrypted_private_key = encrypt_private_key(&keypair.private, &encryption_key)?;
        
        // 5. Créer profil et stocker de manière sécurisée
        let profile = Profile {
            id: ProfileId::new(),
            name: name.to_string(),
            public_key: keypair.public,
            encrypted_private_key,
            salt,
            created_at: Utc::now(),
        };
        
        self.storage.store(&profile.id.to_string(), &profile.serialize()?)?;
        Ok(profile.id)
    }
}
```

### **Stockage local sécurisé**
```rust
// Implementation SQLite chiffrée pour stockage
pub struct EncryptedStorage {
    db_path: PathBuf,
    encryption_key: [u8; 32],
}

impl SecureStorage for EncryptedStorage {
    fn store(&mut self, key: &str, data: &[u8]) -> Result<(), StorageError> {
        // 1. Chiffrer données avec ChaCha20-Poly1305
        let nonce = generate_random_nonce();
        let encrypted = encrypt_chacha20poly1305(data, &self.encryption_key, &nonce)?;
        
        // 2. Stocker dans SQLite avec nonce
        let conn = Connection::open(&self.db_path)?;
        conn.execute(
            "INSERT OR REPLACE INTO secure_storage (key, nonce, data) VALUES (?1, ?2, ?3)",
            params![key, nonce.as_slice(), encrypted.as_slice()]
        )?;
        
        Ok(())
    }
    
    fn retrieve(&self, key: &str) -> Result<Vec<u8>, StorageError> {
        let conn = Connection::open(&self.db_path)?;
        let mut stmt = conn.prepare(
            "SELECT nonce, data FROM secure_storage WHERE key = ?1"
        )?;
        
        let (nonce, encrypted_data): (Vec<u8>, Vec<u8>) = stmt
            .query_row(params![key], |row| {
                Ok((row.get(0)?, row.get(1)?))
            })?;
            
        // Déchiffrer et retourner
        let decrypted = decrypt_chacha20poly1305(&encrypted_data, &self.encryption_key, &nonce)?;
        Ok(decrypted)
    }
}
```

### **CLI de base**
```rust
// Interface ligne de commande fonctionnelle
use clap::{Parser, Subcommand};

#[derive(Parser)]
#[command(name = "miaou")]
#[command(about = "🐱 Messagerie décentralisée sécurisée")]
pub struct Cli {
    #[command(subcommand)]
    pub command: Commands,
    
    #[arg(short, long)]
    pub profile: Option<String>,
    
    #[arg(short, long)]
    pub verbose: bool,
}

#[derive(Subcommand)]
pub enum Commands {
    /// Créer un nouveau profil
    CreateProfile {
        #[arg(short, long)]
        name: String,
    },
    
    /// Lister les profils existants
    ListProfiles,
    
    /// Générer une nouvelle paire de clés
    GenerateKeys,
    
    /// Afficher la clé publique du profil
    ShowPublicKey,
    
    /// Tester la connectivité réseau
    NetworkTest,
    
    /// Exécuter les tests de sécurité
    SecurityAudit,
}

// Exemple d'usage CLI
fn main() -> Result<(), Box<dyn std::error::Error>> {
    let cli = Cli::parse();
    
    match cli.command {
        Commands::CreateProfile { name } => {
            println!("🐱 Création du profil '{}'", name);
            let password = prompt_secure_password()?;
            let profile_id = create_profile(&name, &password)?;
            println!("✅ Profil créé : {}", profile_id);
        },
        
        Commands::ShowPublicKey => {
            let profile = load_current_profile()?;
            println!("📋 Clé publique : {}", profile.public_key.to_hex());
            println!("🔗 Lien d'ajout : miaou://add-contact/{}", profile.public_key.to_hex());
        },
        
        Commands::SecurityAudit => {
            println!("🔍 Audit de sécurité en cours...");
            run_crypto_self_tests()?;
            check_dependencies_vulnerabilities()?;
            validate_storage_encryption()?;
            println!("✅ Audit terminé avec succès");
        },
        
        _ => {}
    }
    
    Ok(())
}
```

---

## 📊 Métriques et Critères de Succès (v0.1 réalistes)

### **KPIs Techniques (périmètre v0.1)**
- ✅ **Couverture de tests >= 90%** sur modules crypto/keyring/storage
- ✅ **0 vulnérabilités critiques** (cargo-audit + cargo-deny)
- ✅ **0 warning clippy pedantic** (linting strict)
- ✅ **Tests KAT XChaCha20-Poly1305** (vecteurs IETF RFC 8439)
- ✅ **Tests KAT Ed25519** (vecteurs RFC 8032)
- ✅ **Fuzzing 0 crash** sur parseurs présents
- ✅ **Documentation rustdoc complète** avec exemples

### **KPIs Fonctionnels (MVP v0.1)**
- ✅ **Création profil chiffré** via CLI fonctionnelle
- ✅ **Affichage clé publique** depuis header fichier
- ✅ **Auto-tests crypto** (roundtrip AEAD + signatures)
- ✅ **Stockage fichier chiffré** avec header versioné
- ✅ **Gestion erreurs** avec types thématiques
- ✅ **Zeroization automatique** des secrets

### **KPIs Performance (baselines v0.1)**
- ✅ **Génération identité Ed25519 < 100ms** (p95)
- ✅ **XChaCha20-Poly1305 encrypt < 10ms** pour 1KB (p95)
- ✅ **Dérivation Argon2id < 500ms** (config standard)
- ✅ **Démarrage CLI < 200ms** (temps de boot)
- ✅ **Empreinte mémoire < 20MB** (runtime de base)

---

## 🚀 Livrables de la Version

### **📦 Packages**
- `miaou-cli` : Exécutable CLI fonctionnel
- `libmiaou-core` : Bibliothèque core réutilisable
- `libmiaou-crypto` : Wrappers cryptographiques auditées

### **📚 Documentation**
- **Guide d'installation** et premiers pas
- **Documentation API** complète (rustdoc)
- **Guide développeur** avec exemples de code
- **Spécification cryptographique** détaillée
- **Guide de sécurité** et bonnes pratiques

### **🔧 Outils**
- Scripts de build automatisés
- Pipeline CI/CD opérationnel
- Outils d'audit de sécurité
- Générateurs de tests crypto
- Validators de configuration

---

## 🛡️ Sécurité et Audit

### **Mesures de sécurité implémentées**
- **Isolation mémoire** : Zeroization automatique des secrets
- **Validation stricte** : Tous inputs validés et sanitizés
- **Opérations constant-time** : Prévention timing attacks
- **Stockage chiffré** : Aucune donnée sensible en clair
- **Audit trail** : Journalisation sécurisée des opérations critiques

### **Tests de sécurité (corrigés - sans UB)**

**Problèmes corrigés :**
- Suppression test de lecture mémoire après `drop` (Undefined Behavior)
- Tests timing en CI non fiables → utilisent `subtle::ConstantTimeEq`
- Focus sur tests structurels et vérification d'API

```rust
// Tests de sécurité structurels (sans UB)
#[test]
fn test_zeroize_derives_present() {
    // Vérification que les types secrets implémentent Zeroize
    use zeroize::Zeroize;
    
    fn assert_zeroize<T: Zeroize>() {}
    
    assert_zeroize::<AeadKeyRef>();
    assert_zeroize::<SigningKeyRef>();
    // Les types sont forcés d'implémenter Zeroize au compile-time
}

#[test]
fn test_no_debug_on_secrets() {
    // Les clés secrètes ne doivent pas implémenter Debug
    // (vérification au compile-time)
    
    fn assert_no_debug<T>() {
        // Utilise un trait helper pour vérifier l'absence de Debug
        trait NotDebug { fn check(&self) {} }
        impl<T> NotDebug for T where T: std::fmt::Debug {}
        
        // Cette ligne NE DOIT PAS compiler pour les secrets :
        // AeadKeyRef{}.check(); // ← erreur attendue
    }
}

#[test]
fn test_constant_time_operations() {
    // Utilisation de subtle::ConstantTimeEq pour les comparaisons sensibles
    use subtle::ConstantTimeEq;
    
    let tag1 = [0x42u8; 16];
    let tag2 = [0x42u8; 16];
    let tag3 = [0x43u8; 16];
    
    // Comparaisons constant-time
    assert_eq!(tag1.ct_eq(&tag2).unwrap_u8(), 1);
    assert_eq!(tag1.ct_eq(&tag3).unwrap_u8(), 0);
}

#[test]
fn test_aead_aad_enforcement() {
    // AAD ne doit jamais être vide
    let provider = TestCryptoProvider::new();
    let key = AeadKeyRef::generate();
    let mut rng = OsRng;
    
    // AAD vide doit être rejetée
    let result = provider.seal(&key, b"", b"plaintext", &mut rng);
    assert!(result.is_err()); // AAD vide interdit
    
    // AAD non-vide doit fonctionner
    let result = provider.seal(&key, b"version:1", b"plaintext", &mut rng);
    assert!(result.is_ok());
}

#[test]
fn test_nonce_uniqueness() {
    // XChaCha20-Poly1305 avec nonces 192-bit
    let provider = TestCryptoProvider::new();
    let key = AeadKeyRef::generate();
    let mut rng = OsRng;
    
    let mut nonces = std::collections::HashSet::new();
    
    // Générer 1000 chiffrements et vérifier unicité des nonces
    for _ in 0..1000 {
        let sealed = provider.seal(&key, b"aad", b"msg", &mut rng).unwrap();
        assert!(nonces.insert(sealed.nonce)); // Doit être unique
    }
}
```

---

## 🗓️ Roadmap interne v0.1.0

### **Phase 1 : Correction et redémarrage**
- [x] Analyse échec précédent (incohérence crypto, UB tests)
- [x] Mise à jour spécifications avec recommandations GPT-5
- [ ] **EN COURS : Implémentation selon spécs corrigées**

### **Phase 2 : Fondations crypto (Option A cohérente)**
- [ ] Wrappers XChaCha20-Poly1305 + Ed25519 + X25519
- [ ] Traits object-safe avec AAD obligatoire
- [ ] Tests KAT IETF (pas NIST) sans UB
- [ ] Zeroization et types opaques

### **Phase 3 : Stockage et Profils**
- [ ] Stockage fichier chiffré (pas SQLite pour v0.1)
- [ ] Keyring avec dérivation Argon2id
- [ ] Gestion profils avec secrecy::SecretString
- [ ] Tests structurels de sécurité

### **Phase 4 : CLI et Validation**
- [ ] CLI minimale mais fonctionnelle
- [ ] Auto-tests crypto intégrés
- [ ] CI optimisée (fuzz court/long)
- [ ] Documentation et métriques v0.1

---

## 📋 Checklist de Release

### **Tests et Qualité**
- [ ] Tous les tests unitaires passent (100%)
- [ ] Couverture de code >= 90% (tarpaulin)
- [ ] Fuzzing 0 crash (toutes les targets)
- [ ] Audit sécurité cargo-audit clean
- [ ] Linting clippy pedantic clean
- [ ] Tests KAT crypto tous validés
- [ ] Tests de mutation passent (cargo-mutagen)
- [ ] Benchmarks performance dans les SLA

### **Documentation**
- [ ] README à jour avec examples
- [ ] Documentation API complète (rustdoc)
- [ ] Guide d'installation testé
- [ ] Exemples de code fonctionnels
- [ ] CHANGELOG détaillé

### **Sécurité**
- [ ] Review sécurité par expert externe
- [ ] Tests de sécurité automatisés
- [ ] Validation politique dépendances
- [ ] Scan vulnérabilités (cargo-audit)
- [ ] Vérification zeroization mémoire

---

## 🎯 Préparation v0.2.0

Cette version pose les bases pour la **v0.2.0 "Radar à Moustaches"** qui ajoutera :
- Communication P2P avec WebRTC
- Découverte de pairs automatique  
- Protocole réseau Miaou
- Messages chiffrés bout-en-bout

**Les fondations de la v0.1.0 sont essentielles** - pas de compromis sur la qualité ! 🔐

**Corrections appliquées suite à l'échec précédent :**
- Stack cryptographique cohérente (Option A : RustCrypto + Dalek uniquement)
- Traits object-safe avec AAD obligatoire pour AEAD
- Tests sans Undefined Behavior
- rustls 0.23 avec provider aws-lc-rs
- XChaCha20-Poly1305 pour nonces 192-bit moins contraints
- Types opaques avec Zeroize automatique
- Implémentation progressive sans dégradation qualité

---

*La Première Griffe marque le début de la révolution : un chaton prêt à conquérir le monde numérique.* 🐱⚔️