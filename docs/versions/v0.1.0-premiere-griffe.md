# ğŸ± Version 0.1.0 "PremiÃ¨re Griffe"
## *Quand le chaton montre ses crocs*

> **Phase 1 : Fondations techniques** - Ã‰tablir l'infrastructure de base sÃ©curisÃ©e et modulaire

---

## ğŸ¯ Vision de cette version

La **PremiÃ¨re Griffe** reprÃ©sente le moment oÃ¹ Miaou passe de l'idÃ©e au premier prototype fonctionnel. Cette version pose les fondations technologiques incontournables : sÃ©curitÃ© cryptographique, architecture modulaire et qualitÃ© de code irrÃ©prochable.

**Motto :** *"Sortir les griffes sur la complexitÃ© technique"*

---

## ğŸ—ï¸ Architecture et Infrastructure

### **ğŸ“¦ Structure modulaire (Crates Rust)**
```
miaou-core/
â”œâ”€â”€ ğŸ” crypto/
â”‚   â”œâ”€â”€ crypto-primitives/     # Wrappers ring + RustCrypto
â”‚   â”œâ”€â”€ crypto-keyring/        # Gestion clÃ©s ed25519-dalek
â”‚   â”œâ”€â”€ crypto-encryption/     # Chiffrement libsignal-protocol
â”‚   â”œâ”€â”€ crypto-signature/      # Signatures Ed25519
â”‚   â””â”€â”€ crypto-hashing/        # SHA-3, BLAKE3, Argon2
â”œâ”€â”€ ğŸ“¦ core/
â”‚   â”œâ”€â”€ miaou-types/          # Types de base et structures
â”‚   â”œâ”€â”€ miaou-config/         # Configuration et profils
â”‚   â”œâ”€â”€ miaou-storage/        # Stockage local sÃ©curisÃ©
â”‚   â””â”€â”€ miaou-protocol/       # DÃ©finition protocole Miaou
â”œâ”€â”€ ğŸŒ network/
â”‚   â”œâ”€â”€ network-discovery/    # DÃ©couverte pairs (prÃ©paration)
â”‚   â”œâ”€â”€ network-protocol/     # Protocole rÃ©seau de base
â”‚   â””â”€â”€ network-transport/    # Transport sÃ©curisÃ© TLS
â””â”€â”€ ğŸ§ª testing/
    â”œâ”€â”€ test-framework/       # Framework tests personnalisÃ©
    â”œâ”€â”€ test-crypto/          # Tests cryptographiques KAT
    â””â”€â”€ test-mocks/           # Mocks et fixtures
```

### **ğŸ”Œ Interfaces et Traits (Object-Safe, AAD obligatoire)**

**Corrections appliquÃ©es :**
- Tous les traits avec `&self` pour l'object safety
- AAD (Associated Authenticated Data) obligatoire pour AEAD
- Retour `Result<(), CryptoError>` pour `verify` (pas de masquage d'erreurs)
- Types opaques pour les clÃ©s (pas de Debug, Zeroize sur drop)
- Stockage typÃ© pour Ã©viter les collisions de clÃ©s string

```rust
/// ğŸ” Fournit des primitives cryptographiques de haut niveau (AEAD, signatures)
/// âš ï¸ ImplÃ©mentations basÃ©es EXCLUSIVEMENT sur des bibliothÃ¨ques auditÃ©es
pub trait CryptoProvider: Send + Sync {
    /// Chiffre avec XChaCha20-Poly1305 et AAD obligatoires
    /// - `aad`: donnÃ©es associÃ©es (version protocole, type message, flags)
    /// - GÃ©nÃ¨re automatiquement un nonce 192-bit alÃ©atoire
    fn seal(
        &self,
        key: &AeadKeyRef,
        aad: &[u8],  // OBLIGATOIRE - jamais vide
        plaintext: &[u8],
        rng: &mut dyn rand_core::RngCore,
    ) -> Result<SealedData, CryptoError>;

    /// DÃ©chiffre et authentifie ; Ã©choue si tag/nonce/AAD invalide
    fn open(
        &self,
        key: &AeadKeyRef,
        aad: &[u8],  // DOIT correspondre exactement au seal
        sealed: &SealedData,
    ) -> Result<Vec<u8>, CryptoError>;

    /// Signe avec Ed25519 (signature 64 bytes)
    fn sign(&self, sk: &SigningKeyRef, msg: &[u8]) -> Result<Signature, CryptoError>;

    /// VÃ©rifie signature Ed25519 - RETOURNE ERREUR (pas bool)
    fn verify(&self, pk: &VerifyingKeyRef, msg: &[u8], sig: &Signature) -> Result<(), CryptoError>;
}

/// ğŸ”‘ GÃ©nÃ¨re et gÃ¨re le matÃ©riel cryptographique (object-safe)
pub trait KeyMaterial: Send + Sync {
    fn generate_identity(&self, rng: &mut dyn rand_core::RngCore) -> Result<IdentityKeys, CryptoError>;
    fn rotate_session_key(&self, rng: &mut dyn rand_core::RngCore) -> Result<AeadKey, CryptoError>;
}

/// ğŸ—‚ï¸ Gestion des profils utilisateur (object-safe)
pub trait ProfileManager: Send + Sync {
    fn create_profile(&self, name: &str, password: &secrecy::SecretString) -> Result<ProfileId, ProfileError>;
    fn load_profile(&self, id: &ProfileId, password: &secrecy::SecretString) -> Result<Profile, ProfileError>;
    fn list_profiles(&self) -> Vec<ProfileInfo>;
    fn delete_profile(&self, id: &ProfileId) -> Result<(), ProfileError>;
}

/// ğŸ—„ï¸ Stockage sÃ©curisÃ© typÃ© (Ã©vite collisions de clÃ©s string)
pub trait SecureStorage: Send + Sync {
    fn store(&self, namespace: Namespace, key: KeyId, data: &[u8]) -> Result<(), StorageError>;
    fn retrieve(&self, namespace: Namespace, key: KeyId) -> Result<Option<Vec<u8>>, StorageError>;
    fn delete(&self, namespace: Namespace, key: KeyId) -> Result<(), StorageError>;
    fn exists(&self, namespace: Namespace, key: KeyId) -> bool;
}

/// ğŸ“¦ Types opaques sÃ©curisÃ©s
#[derive(ZeroizeOnDrop)]
pub struct AeadKeyRef(Zeroizing<[u8; 32]>);

#[derive(ZeroizeOnDrop)]
pub struct SigningKeyRef(Zeroizing<[u8; 32]>);

pub struct VerifyingKeyRef([u8; 32]);

/// ğŸ“‹ DonnÃ©es scellÃ©es avec nonce intÃ©grÃ©
#[derive(Clone)]
pub struct SealedData {
    pub nonce: [u8; 24],     // XChaCha20 nonce 192-bit
    pub ciphertext: Vec<u8>, // Tag Poly1305 inclus
}

/// ğŸ†” Types typÃ©s pour le stockage
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Namespace {
    Profiles,
    Sessions,
    Config,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct KeyId(String);
```

---

## ğŸ” ImplÃ©mentation Cryptographique

### **Stack cryptographique cohÃ©rente (Option A : RustCrypto + Dalek)**

**Pourquoi cette stratÃ©gie :**
- Ã‰vite le mÃ©lange ring + dalek + RustCrypto qui cause des incompatibilitÃ©s d'API
- Types cohÃ©rents pour nonces, clÃ©s, tags entre les crates
- XChaCha20-Poly1305 avec nonces 24 bytes pour rÃ©duire les risques de collision
- APIs object-safe avec `&self` pour le dynamic dispatch

```toml
[workspace.dependencies]
# ğŸ” Cryptographie cohÃ©rente (Option A : RustCrypto + Dalek)
# AEAD avec XChaCha20 (nonces 192-bit, moins de contraintes d'unicitÃ©)
chacha20poly1305 = { version = "0.10", default-features = false, features = ["alloc", "rand_core", "xchacha20poly1305"] }

# Signatures et ECDH via Dalek (performance + audit)
ed25519-dalek = { version = "2", features = ["rand_core", "zeroize"] }
x25519-dalek = { version = "2", features = ["static_secrets"] }

# KDF et hachage
hkdf = "0.12"                   # HKDF pour dÃ©rivations session
blake3 = { version = "1", features = ["zeroize"] }
argon2 = "0.5"                  # DÃ©rivation mots de passe

# Transport sÃ©curisÃ© (mis Ã  jour)
rustls = { version = "0.23", default-features = true }  # TLS 1.3 + provider aws-lc-rs
tokio = { version = "1", features = ["rt-multi-thread", "macros", "net"] }

# SÃ©curitÃ© et gestion des secrets
zeroize = "1.7"                 # Nettoyage mÃ©moire automatique
subtle = "2.5"                  # OpÃ©rations constant-time
secrecy = "0.8"                 # Gestion sÃ©curisÃ©e des secrets
rand_core = "0.6"               # CSPRNG unifiÃ©

# SÃ©rialisation et utilitaires
serde = { version = "1", features = ["derive"] }
serde_json = "1.0"              # Format JSON pour headers
hex = "0.4"                     # Encodage hexadÃ©cimal
thiserror = "1"
```

### **Algorithmes et Standards (cohÃ©rents)**
- **Chiffrement symÃ©trique** : **XChaCha20-Poly1305** (AEAD Ã©tendu, nonces 192-bit)
  - Moins de contraintes d'unicitÃ© des nonces vs ChaCha20-Poly1305
  - Compatible avec dÃ©ploiements distribuÃ©s sans coordination
- **Signatures** : **Ed25519** (RFC 8032, courbes elliptiques)
- **Ã‰change de clÃ©s** : **X25519** (RFC 7748, ECDH)
- **Hachage** : **BLAKE3** (ultra-rapide, zeroize, arbre Merkle)
- **DÃ©rivation clÃ©s** : **Argon2id** (mots de passe) + **HKDF** (sessions)
- **Transport** : **TLS 1.3** (RFC 8446) via rustls 0.23 + aws-lc-rs provider

### **SÃ©curitÃ© par design**
```rust
// Zeroization automatique des secrets
#[derive(Zeroize, ZeroizeOnDrop)]
pub struct PrivateKey([u8; 32]);

// Pas de Debug sur les secrets
impl fmt::Debug for PrivateKey {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "PrivateKey([REDACTED])")
    }
}

// Comparaisons constant-time obligatoires
use subtle::ConstantTimeEq;
pub fn verify_signature(sig: &[u8], expected: &[u8]) -> bool {
    sig.ct_eq(expected).into()
}

// Validation stricte des entrÃ©es
pub fn parse_message(data: &[u8]) -> Result<Message, ParseError> {
    if data.len() < MIN_SIZE || data.len() > MAX_SIZE {
        return Err(ParseError::InvalidSize);
    }
    validate_format(data)?;
    safe_deserialize(data)
}
```

---

## ğŸ§ª QualitÃ© et Tests (Non-nÃ©gociables)

### **Standards de qualitÃ© (adaptÃ©s v0.1)**
- **Couverture >= 90%** : MesurÃ©e avec cargo-tarpaulin sur pÃ©rimÃ¨tre v0.1
- **Tests KAT** : Known Answer Tests avec vecteurs **IETF RFC 8439** (ChaCha20-Poly1305)
- **Tests de propriÃ©tÃ©s** : Avec proptest pour roundtrip encrypt/decrypt
- **Fuzzing ciblÃ©** : Sur parseurs prÃ©sents uniquement (pas de fuzz aveugle)
- **Linting strict** : clippy pedantic + deny warnings
- **Audit sÃ©curitÃ©** : cargo-audit + cargo-deny (licences + advisories)

### **Framework de tests personnalisÃ©**
```rust
// Tests crypto avec vecteurs IETF officiels (RFC 8439)
#[test]
fn test_xchacha20_poly1305_kat() {
    // Vecteurs de test XChaCha20-Poly1305 depuis draft IETF
    let test_vectors = load_ietf_vectors("xchacha20poly1305_ietf.json");
    for vector in test_vectors {
        let result = encrypt_xchacha20poly1305(
            &vector.key,     // 32 bytes
            &vector.nonce,   // 24 bytes (XChaCha)
            &vector.aad,     // Associated data (obligatoire)
            &vector.plaintext
        );
        assert_eq!(result.unwrap(), vector.expected_ciphertext);
    }
}

// Tests de propriÃ©tÃ©s pour encrypt/decrypt
proptest! {
    #[test]
    fn encrypt_decrypt_roundtrip(
        plaintext in any::<Vec<u8>>(),
        key in prop::array::uniform32(any::<u8>()),
        nonce in prop::array::uniform12(any::<u8>())
    ) {
        let encrypted = encrypt_message(&plaintext, &key, &nonce)?;
        let decrypted = decrypt_message(&encrypted, &key)?;
        prop_assert_eq!(plaintext, decrypted);
    }
}

// Fuzzing pour parseurs
#[cfg(test)]
mod fuzz_tests {
    use super::*;
    
    #[test]
    fn fuzz_message_parser() {
        use arbitrary::*;
        let data = generate_random_bytes(0..10000);
        // Ne doit jamais paniquer, mÃªme avec donnÃ©es malformÃ©es
        let _ = parse_message(&data);
    }
}
```

### **Pipeline CI/CD**
```yaml
# .github/workflows/quality.yml
name: Quality Gates
on: [push, pull_request]

jobs:
  tests:
    runs-on: ubuntu-latest
    steps:
      - name: Run tests
        run: cargo test --all-features
      
  coverage:
    runs-on: ubuntu-latest
    steps:
      - name: Coverage check
        run: |
          cargo tarpaulin --verbose --timeout 120
          # Fail si < 90%
          
  security:
    runs-on: ubuntu-latest
    steps:
      - name: Audit dependencies
        run: cargo audit
      - name: Lint security
        run: cargo clippy -- -D warnings -D clippy::pedantic
        
  fuzzing:
    runs-on: ubuntu-latest
    steps:
      - name: Install cargo-fuzz
        run: cargo install cargo-fuzz
      - name: Run fuzz tests
        run: cargo fuzz run parser_target -- -max_total_time=300
```

---

## ğŸ’¬ FonctionnalitÃ©s de Base

### **Gestion des profils utilisateur**
```rust
// CrÃ©ation et gestion de profils chiffrÃ©s
pub struct ProfileManager {
    storage: Box<dyn SecureStorage>,
    crypto: Box<dyn CryptoEngine>,
}

impl ProfileManager {
    pub fn create_profile(&mut self, name: &str, password: &str) -> Result<ProfileId, ProfileError> {
        // 1. GÃ©nÃ©rer salt unique pour Argon2
        let salt = generate_random_salt();
        
        // 2. DÃ©river clÃ© de chiffrement depuis mot de passe
        let encryption_key = derive_key_argon2(password, &salt)?;
        
        // 3. GÃ©nÃ©rer paire de clÃ©s Ed25519 pour identitÃ©
        let keypair = self.crypto.generate_keypair()?;
        
        // 4. Chiffrer clÃ© privÃ©e avec clÃ© dÃ©rivÃ©e
        let encrypted_private_key = encrypt_private_key(&keypair.private, &encryption_key)?;
        
        // 5. CrÃ©er profil et stocker de maniÃ¨re sÃ©curisÃ©e
        let profile = Profile {
            id: ProfileId::new(),
            name: name.to_string(),
            public_key: keypair.public,
            encrypted_private_key,
            salt,
            created_at: Utc::now(),
        };
        
        self.storage.store(&profile.id.to_string(), &profile.serialize()?)?;
        Ok(profile.id)
    }
}
```

### **Stockage local sÃ©curisÃ©**
```rust
// Implementation SQLite chiffrÃ©e pour stockage
pub struct EncryptedStorage {
    db_path: PathBuf,
    encryption_key: [u8; 32],
}

impl SecureStorage for EncryptedStorage {
    fn store(&mut self, key: &str, data: &[u8]) -> Result<(), StorageError> {
        // 1. Chiffrer donnÃ©es avec ChaCha20-Poly1305
        let nonce = generate_random_nonce();
        let encrypted = encrypt_chacha20poly1305(data, &self.encryption_key, &nonce)?;
        
        // 2. Stocker dans SQLite avec nonce
        let conn = Connection::open(&self.db_path)?;
        conn.execute(
            "INSERT OR REPLACE INTO secure_storage (key, nonce, data) VALUES (?1, ?2, ?3)",
            params![key, nonce.as_slice(), encrypted.as_slice()]
        )?;
        
        Ok(())
    }
    
    fn retrieve(&self, key: &str) -> Result<Vec<u8>, StorageError> {
        let conn = Connection::open(&self.db_path)?;
        let mut stmt = conn.prepare(
            "SELECT nonce, data FROM secure_storage WHERE key = ?1"
        )?;
        
        let (nonce, encrypted_data): (Vec<u8>, Vec<u8>) = stmt
            .query_row(params![key], |row| {
                Ok((row.get(0)?, row.get(1)?))
            })?;
            
        // DÃ©chiffrer et retourner
        let decrypted = decrypt_chacha20poly1305(&encrypted_data, &self.encryption_key, &nonce)?;
        Ok(decrypted)
    }
}
```

### **CLI de base**
```rust
// Interface ligne de commande fonctionnelle
use clap::{Parser, Subcommand};

#[derive(Parser)]
#[command(name = "miaou")]
#[command(about = "ğŸ± Messagerie dÃ©centralisÃ©e sÃ©curisÃ©e")]
pub struct Cli {
    #[command(subcommand)]
    pub command: Commands,
    
    #[arg(short, long)]
    pub profile: Option<String>,
    
    #[arg(short, long)]
    pub verbose: bool,
}

#[derive(Subcommand)]
pub enum Commands {
    /// CrÃ©er un nouveau profil
    CreateProfile {
        #[arg(short, long)]
        name: String,
    },
    
    /// Lister les profils existants
    ListProfiles,
    
    /// GÃ©nÃ©rer une nouvelle paire de clÃ©s
    GenerateKeys,
    
    /// Afficher la clÃ© publique du profil
    ShowPublicKey,
    
    /// Tester la connectivitÃ© rÃ©seau
    NetworkTest,
    
    /// ExÃ©cuter les tests de sÃ©curitÃ©
    SecurityAudit,
}

// Exemple d'usage CLI
fn main() -> Result<(), Box<dyn std::error::Error>> {
    let cli = Cli::parse();
    
    match cli.command {
        Commands::CreateProfile { name } => {
            println!("ğŸ± CrÃ©ation du profil '{}'", name);
            let password = prompt_secure_password()?;
            let profile_id = create_profile(&name, &password)?;
            println!("âœ… Profil crÃ©Ã© : {}", profile_id);
        },
        
        Commands::ShowPublicKey => {
            let profile = load_current_profile()?;
            println!("ğŸ“‹ ClÃ© publique : {}", profile.public_key.to_hex());
            println!("ğŸ”— Lien d'ajout : miaou://add-contact/{}", profile.public_key.to_hex());
        },
        
        Commands::SecurityAudit => {
            println!("ğŸ” Audit de sÃ©curitÃ© en cours...");
            run_crypto_self_tests()?;
            check_dependencies_vulnerabilities()?;
            validate_storage_encryption()?;
            println!("âœ… Audit terminÃ© avec succÃ¨s");
        },
        
        _ => {}
    }
    
    Ok(())
}
```

---

## ğŸ“Š MÃ©triques et CritÃ¨res de SuccÃ¨s (v0.1 rÃ©alistes)

### **KPIs Techniques (pÃ©rimÃ¨tre v0.1)**
- âœ… **Couverture de tests >= 90%** sur modules crypto/keyring/storage
- âœ… **0 vulnÃ©rabilitÃ©s critiques** (cargo-audit + cargo-deny)
- âœ… **0 warning clippy pedantic** (linting strict)
- âœ… **Tests KAT XChaCha20-Poly1305** (vecteurs IETF RFC 8439)
- âœ… **Tests KAT Ed25519** (vecteurs RFC 8032)
- âœ… **Fuzzing 0 crash** sur parseurs prÃ©sents
- âœ… **Documentation rustdoc complÃ¨te** avec exemples

### **KPIs Fonctionnels (MVP v0.1)**
- âœ… **CrÃ©ation profil chiffrÃ©** via CLI fonctionnelle
- âœ… **Affichage clÃ© publique** depuis header fichier
- âœ… **Auto-tests crypto** (roundtrip AEAD + signatures)
- âœ… **Stockage fichier chiffrÃ©** avec header versionÃ©
- âœ… **Gestion erreurs** avec types thÃ©matiques
- âœ… **Zeroization automatique** des secrets

### **KPIs Performance (baselines v0.1)**
- âœ… **GÃ©nÃ©ration identitÃ© Ed25519 < 100ms** (p95)
- âœ… **XChaCha20-Poly1305 encrypt < 10ms** pour 1KB (p95)
- âœ… **DÃ©rivation Argon2id < 500ms** (config standard)
- âœ… **DÃ©marrage CLI < 200ms** (temps de boot)
- âœ… **Empreinte mÃ©moire < 20MB** (runtime de base)

---

## ğŸš€ Livrables de la Version

### **ğŸ“¦ Packages**
- `miaou-cli` : ExÃ©cutable CLI fonctionnel
- `libmiaou-core` : BibliothÃ¨que core rÃ©utilisable
- `libmiaou-crypto` : Wrappers cryptographiques auditÃ©es

### **ğŸ“š Documentation**
- **Guide d'installation** et premiers pas
- **Documentation API** complÃ¨te (rustdoc)
- **Guide dÃ©veloppeur** avec exemples de code
- **SpÃ©cification cryptographique** dÃ©taillÃ©e
- **Guide de sÃ©curitÃ©** et bonnes pratiques

### **ğŸ”§ Outils**
- Scripts de build automatisÃ©s
- Pipeline CI/CD opÃ©rationnel
- Outils d'audit de sÃ©curitÃ©
- GÃ©nÃ©rateurs de tests crypto
- Validators de configuration

---

## ğŸ›¡ï¸ SÃ©curitÃ© et Audit

### **Mesures de sÃ©curitÃ© implÃ©mentÃ©es**
- **Isolation mÃ©moire** : Zeroization automatique des secrets
- **Validation stricte** : Tous inputs validÃ©s et sanitizÃ©s
- **OpÃ©rations constant-time** : PrÃ©vention timing attacks
- **Stockage chiffrÃ©** : Aucune donnÃ©e sensible en clair
- **Audit trail** : Journalisation sÃ©curisÃ©e des opÃ©rations critiques

### **Tests de sÃ©curitÃ© (corrigÃ©s - sans UB)**

**ProblÃ¨mes corrigÃ©s :**
- Suppression test de lecture mÃ©moire aprÃ¨s `drop` (Undefined Behavior)
- Tests timing en CI non fiables â†’ utilisent `subtle::ConstantTimeEq`
- Focus sur tests structurels et vÃ©rification d'API

```rust
// Tests de sÃ©curitÃ© structurels (sans UB)
#[test]
fn test_zeroize_derives_present() {
    // VÃ©rification que les types secrets implÃ©mentent Zeroize
    use zeroize::Zeroize;
    
    fn assert_zeroize<T: Zeroize>() {}
    
    assert_zeroize::<AeadKeyRef>();
    assert_zeroize::<SigningKeyRef>();
    // Les types sont forcÃ©s d'implÃ©menter Zeroize au compile-time
}

#[test]
fn test_no_debug_on_secrets() {
    // Les clÃ©s secrÃ¨tes ne doivent pas implÃ©menter Debug
    // (vÃ©rification au compile-time)
    
    fn assert_no_debug<T>() {
        // Utilise un trait helper pour vÃ©rifier l'absence de Debug
        trait NotDebug { fn check(&self) {} }
        impl<T> NotDebug for T where T: std::fmt::Debug {}
        
        // Cette ligne NE DOIT PAS compiler pour les secrets :
        // AeadKeyRef{}.check(); // â† erreur attendue
    }
}

#[test]
fn test_constant_time_operations() {
    // Utilisation de subtle::ConstantTimeEq pour les comparaisons sensibles
    use subtle::ConstantTimeEq;
    
    let tag1 = [0x42u8; 16];
    let tag2 = [0x42u8; 16];
    let tag3 = [0x43u8; 16];
    
    // Comparaisons constant-time
    assert_eq!(tag1.ct_eq(&tag2).unwrap_u8(), 1);
    assert_eq!(tag1.ct_eq(&tag3).unwrap_u8(), 0);
}

#[test]
fn test_aead_aad_enforcement() {
    // AAD ne doit jamais Ãªtre vide
    let provider = TestCryptoProvider::new();
    let key = AeadKeyRef::generate();
    let mut rng = OsRng;
    
    // AAD vide doit Ãªtre rejetÃ©e
    let result = provider.seal(&key, b"", b"plaintext", &mut rng);
    assert!(result.is_err()); // AAD vide interdit
    
    // AAD non-vide doit fonctionner
    let result = provider.seal(&key, b"version:1", b"plaintext", &mut rng);
    assert!(result.is_ok());
}

#[test]
fn test_nonce_uniqueness() {
    // XChaCha20-Poly1305 avec nonces 192-bit
    let provider = TestCryptoProvider::new();
    let key = AeadKeyRef::generate();
    let mut rng = OsRng;
    
    let mut nonces = std::collections::HashSet::new();
    
    // GÃ©nÃ©rer 1000 chiffrements et vÃ©rifier unicitÃ© des nonces
    for _ in 0..1000 {
        let sealed = provider.seal(&key, b"aad", b"msg", &mut rng).unwrap();
        assert!(nonces.insert(sealed.nonce)); // Doit Ãªtre unique
    }
}
```

---

## ğŸ—“ï¸ Roadmap interne v0.1.0

### **Phase 1 : Correction et redÃ©marrage**
- [x] Analyse Ã©chec prÃ©cÃ©dent (incohÃ©rence crypto, UB tests)
- [x] Mise Ã  jour spÃ©cifications avec recommandations GPT-5
- [ ] **EN COURS : ImplÃ©mentation selon spÃ©cs corrigÃ©es**

### **Phase 2 : Fondations crypto (Option A cohÃ©rente)**
- [ ] Wrappers XChaCha20-Poly1305 + Ed25519 + X25519
- [ ] Traits object-safe avec AAD obligatoire
- [ ] Tests KAT IETF (pas NIST) sans UB
- [ ] Zeroization et types opaques

### **Phase 3 : Stockage et Profils**
- [ ] Stockage fichier chiffrÃ© (pas SQLite pour v0.1)
- [ ] Keyring avec dÃ©rivation Argon2id
- [ ] Gestion profils avec secrecy::SecretString
- [ ] Tests structurels de sÃ©curitÃ©

### **Phase 4 : CLI et Validation**
- [ ] CLI minimale mais fonctionnelle
- [ ] Auto-tests crypto intÃ©grÃ©s
- [ ] CI optimisÃ©e (fuzz court/long)
- [ ] Documentation et mÃ©triques v0.1

---

## ğŸ“‹ Checklist de Release

### **Tests et QualitÃ©**
- [ ] Tous les tests unitaires passent (100%)
- [ ] Couverture de code >= 90% (tarpaulin)
- [ ] Fuzzing 0 crash (toutes les targets)
- [ ] Audit sÃ©curitÃ© cargo-audit clean
- [ ] Linting clippy pedantic clean
- [ ] Tests KAT crypto tous validÃ©s
- [ ] Tests de mutation passent (cargo-mutagen)
- [ ] Benchmarks performance dans les SLA

### **Documentation**
- [ ] README Ã  jour avec examples
- [ ] Documentation API complÃ¨te (rustdoc)
- [ ] Guide d'installation testÃ©
- [ ] Exemples de code fonctionnels
- [ ] CHANGELOG dÃ©taillÃ©

### **SÃ©curitÃ©**
- [ ] Review sÃ©curitÃ© par expert externe
- [ ] Tests de sÃ©curitÃ© automatisÃ©s
- [ ] Validation politique dÃ©pendances
- [ ] Scan vulnÃ©rabilitÃ©s (cargo-audit)
- [ ] VÃ©rification zeroization mÃ©moire

---

## ğŸ¯ PrÃ©paration v0.2.0

Cette version pose les bases pour la **v0.2.0 "Radar Ã  Moustaches"** qui ajoutera :
- Communication P2P avec WebRTC
- DÃ©couverte de pairs automatique  
- Protocole rÃ©seau Miaou
- Messages chiffrÃ©s bout-en-bout

**Les fondations de la v0.1.0 sont essentielles** - pas de compromis sur la qualitÃ© ! ğŸ”

**Corrections appliquÃ©es suite Ã  l'Ã©chec prÃ©cÃ©dent :**
- Stack cryptographique cohÃ©rente (Option A : RustCrypto + Dalek uniquement)
- Traits object-safe avec AAD obligatoire pour AEAD
- Tests sans Undefined Behavior
- rustls 0.23 avec provider aws-lc-rs
- XChaCha20-Poly1305 pour nonces 192-bit moins contraints
- Types opaques avec Zeroize automatique
- ImplÃ©mentation progressive sans dÃ©gradation qualitÃ©

---

*La PremiÃ¨re Griffe marque le dÃ©but de la rÃ©volution : un chaton prÃªt Ã  conquÃ©rir le monde numÃ©rique.* ğŸ±âš”ï¸