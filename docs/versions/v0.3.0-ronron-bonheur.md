# üê± Version 0.3.0 "Ronron du Bonheur"
## *Quand contribuer fait plaisir*

> **Phase 3 : √âconomie et gamification** - Syst√®me d'incitations et gamification

---

## üéØ Vision de cette version

Le **Ronron du Bonheur** transforme l'utilisation de Miaou en une exp√©rience gratifiante. Comme un chat qui ronronne de satisfaction, cette version r√©compense chaque contribution positive au r√©seau, cr√©ant un √©cosyst√®me auto-entretenu o√π participer devient naturellement plaisant.

**Motto :** *"Faire ronronner l'√©conomie d√©centralis√©e"*

---

## üèÜ Syst√®me de R√©compenses Local (MVP)

### **Architecture √©conomique simplifi√©e**
```rust
// Syst√®me de cr√©dits locaux (sans blockchain pour MVP)
pub struct LocalRewardSystem {
    credit_store: HashMap<ContributionType, u64>,
    daily_limits: DailyLimits,
    reputation_score: f64,
    achievement_tracker: AchievementTracker,
}

#[derive(Debug, Clone, Hash, Eq, PartialEq)]
pub enum ContributionType {
    MessageSent,                    // 1 cr√©dit par message
    MessageReceived,                // 0.5 cr√©dit par r√©ception
    PeerHelped,                     // 10 cr√©dits aider connexion
    UptimeHour,                     // 2 cr√©dits par heure en ligne
    SecurityReport,                 // 100 cr√©dits rapport vuln√©rabilit√©
    Translation,                    // 50 cr√©dits traduction
    BugReport,                      // 25 cr√©dits bug reproductible
    FeatureRequest,                 // 10 cr√©dits suggestion constructive
    CodeContribution,               // 500 cr√©dits code accept√©
    DocumentationHelp,              // 25 cr√©dits am√©lioration docs
    CommunityModeration,            // 15 cr√©dits mod√©ration constructive
    Referral,                       // 200 cr√©dits par parrainage r√©ussi
    NetworkRelay,                   // 5 cr√©dits par relais de message
    OfflineMessageStore,            // 3 cr√©dits par message stock√©
    DirectoryContribution,          // 8 cr√©dits mise √† jour annuaire
}

#[derive(Debug, Clone)]
pub struct DailyLimits {
    pub max_message_credits: u64,      // Max 100/jour pour √©viter spam
    pub max_uptime_credits: u64,       // Max 48/jour (24h uptime)
    pub max_referral_credits: u64,     // Max 1000/jour (5 parrainages)
    pub unlimited_types: HashSet<ContributionType>, // Pas de limite
}

impl LocalRewardSystem {
    pub fn award_credits(&mut self, contribution: ContributionType, amount: u64) -> Result<u64, RewardError> {
        // 1. V√©rifier limites quotidiennes
        if !self.daily_limits.unlimited_types.contains(&contribution) {
            let today_total = self.get_today_credits(&contribution);
            let limit = self.get_daily_limit(&contribution);
            
            if today_total + amount > limit {
                return Err(RewardError::DailyLimitExceeded {
                    contribution,
                    attempted: amount,
                    remaining: limit.saturating_sub(today_total),
                });
            }
        }
        
        // 2. Calculer bonus multiplicateur selon r√©putation
        let multiplier = self.calculate_reputation_multiplier();
        let final_amount = ((amount as f64) * multiplier) as u64;
        
        // 3. Attribuer cr√©dits
        let current = self.credit_store.entry(contribution.clone()).or_insert(0);
        *current += final_amount;
        
        // 4. Mettre √† jour r√©putation
        self.update_reputation(&contribution, final_amount);
        
        // 5. V√©rifier achievements d√©bloqu√©s
        self.check_achievements(&contribution, *current);
        
        // 6. Journaliser pour transparence
        self.log_credit_award(&contribution, final_amount, multiplier);
        
        Ok(final_amount)
    }
    
    pub fn get_total_credits(&self) -> u64 {
        self.credit_store.values().sum()
    }
    
    pub fn get_credits_breakdown(&self) -> HashMap<ContributionType, u64> {
        self.credit_store.clone()
    }
    
    fn calculate_reputation_multiplier(&self) -> f64 {
        // R√©putation entre 0.0 et 2.0
        // Nouveaux utilisateurs : 1.0
        // Utilisateurs de confiance : jusqu'√† 1.5x
        // Contributeurs exceptionnels : jusqu'√† 2.0x
        match self.reputation_score {
            r if r < 100.0 => 1.0,                           // Nouveau
            r if r < 500.0 => 1.0 + (r - 100.0) / 800.0,    // Progressif jusqu'√† 1.2x
            r if r < 1000.0 => 1.2 + (r - 500.0) / 1000.0,  // Progressif jusqu'√† 1.5x
            r if r < 2000.0 => 1.5 + (r - 1000.0) / 2000.0, // Progressif jusqu'√† 2.0x
            _ => 2.0,                                         // Max 2x
        }
    }
}
```

### **Syst√®me anti-spam √©conomique**
```rust
pub struct AntiSpamSystem {
    rate_limiters: HashMap<PeerId, RateLimiter>,
    cost_calculator: MessageCostCalculator,
    trust_scores: HashMap<PeerId, f64>,
    penalty_tracker: PenaltyTracker,
}

#[derive(Debug, Clone)]
pub struct MessageCost {
    base_cost: u64,                     // Co√ªt de base (1 cr√©dit)
    recipient_multiplier: f64,          // Selon relation avec destinataire
    content_penalty: u64,               // P√©nalit√© contenu suspect
    frequency_penalty: u64,             // P√©nalit√© fr√©quence √©lev√©e
    total_cost: u64,                    // Co√ªt total final
}

impl AntiSpamSystem {
    pub fn calculate_message_cost(&self, sender: &PeerId, recipient: &PeerId, content: &str) -> MessageCost {
        let mut cost = MessageCost {
            base_cost: 1,
            recipient_multiplier: 1.0,
            content_penalty: 0,
            frequency_penalty: 0,
            total_cost: 0,
        };
        
        // 1. Multiplicateur selon relation
        let relationship = self.get_relationship_score(sender, recipient);
        cost.recipient_multiplier = match relationship {
            r if r > 0.8 => 0.5,        // Amis proches : co√ªt r√©duit
            r if r > 0.5 => 0.8,        // Connaissances : l√©ger rabais
            r if r > 0.0 => 1.0,        // Neutres : co√ªt normal
            r if r > -0.5 => 2.0,       // Suspicieux : co√ªt doubl√©
            _ => 5.0,                   // Bloqu√©s/spam : co√ªt prohibitif
        };
        
        // 2. Analyse contenu pour d√©tection spam
        cost.content_penalty = self.analyze_content_for_spam(content);
        
        // 3. P√©nalit√© fr√©quence
        let recent_count = self.get_recent_message_count(sender, Duration::minutes(10));
        cost.frequency_penalty = match recent_count {
            0..=5 => 0,                 // Usage normal
            6..=10 => recent_count - 5, // P√©nalit√© progressive
            11..=20 => (recent_count - 10) * 2, // P√©nalit√© forte
            _ => 50,                    // P√©nalit√© maximale
        };
        
        // 4. Calcul co√ªt final
        cost.total_cost = ((cost.base_cost as f64 * cost.recipient_multiplier) as u64)
            + cost.content_penalty
            + cost.frequency_penalty;
        
        cost
    }
    
    pub fn can_afford_message(&self, sender: &PeerId, cost: &MessageCost) -> Result<bool, SpamError> {
        let sender_credits = self.get_peer_credits(sender)?;
        
        if sender_credits >= cost.total_cost {
            Ok(true)
        } else {
            // Proposer moyens de gagner des cr√©dits
            let suggestions = self.suggest_credit_earning_methods(sender);
            Err(SpamError::InsufficientCredits {
                required: cost.total_cost,
                available: sender_credits,
                suggestions,
            })
        }
    }
    
    fn analyze_content_for_spam(&self, content: &str) -> u64 {
        let mut penalty = 0;
        
        // D√©tections simples mais efficaces
        if content.len() > 1000 {
            penalty += 5; // Messages tr√®s longs
        }
        
        if content.chars().filter(|c| c.is_uppercase()).count() > content.len() / 2 {
            penalty += 10; // CAPS LOCK excessif
        }
        
        if content.matches("http").count() > 3 {
            penalty += 15; // Nombreux liens
        }
        
        let repeated_chars = content.chars()
            .collect::<Vec<_>>()
            .windows(3)
            .filter(|w| w[0] == w[1] && w[1] == w[2])
            .count();
        
        if repeated_chars > 5 {
            penalty += 8; // Caract√®res r√©p√©t√©s (ex: !!!!!!)
        }
        
        // Mots-cl√©s spam communs
        let spam_keywords = ["gratuit", "urgent", "cliquez", "promo", "offre", "crypto", "investir"];
        let spam_count = spam_keywords.iter()
            .filter(|&keyword| content.to_lowercase().contains(keyword))
            .count();
        
        penalty += (spam_count * 3) as u64;
        
        penalty.min(50) // Cap p√©nalit√© √† 50 cr√©dits
    }
}
```

---

## üéØ Syst√®me de Parrainage

### **M√©canisme de parrainage viral**
```rust
pub struct ReferralSystem {
    referral_codes: HashMap<ReferralCode, ReferralInfo>,
    referral_tree: ReferralTree,
    reward_distribution: RewardDistribution,
    tracking: ReferralTracking,
}

#[derive(Debug, Clone)]
pub struct ReferralCode {
    code: String,                       // Code unique (ex: "MIAOU-ABC123")
    referrer: PeerId,                   // Qui a g√©n√©r√© le code
    created_at: DateTime<Utc>,          // Date de cr√©ation
    expires_at: DateTime<Utc>,          // Expiration (30 jours)
    max_uses: Option<u32>,              // Utilisations max (None = illimit√©)
    current_uses: u32,                  // Utilisations actuelles
    bonus_multiplier: f64,              // Bonus sp√©cial (1.0 = normal)
}

#[derive(Debug, Clone)]
pub struct ReferralReward {
    referrer_reward: u64,               // R√©compense pour le parrain
    referee_reward: u64,                // R√©compense pour le filleul
    milestone_bonus: Option<u64>,       // Bonus jalons (10e, 50e r√©f√©r√©...)
    community_bonus: u64,               // Bonus redistribu√© √† la communaut√©
}

impl ReferralSystem {
    pub fn generate_referral_code(&mut self, referrer: &PeerId, custom_code: Option<String>) -> Result<ReferralCode, ReferralError> {
        let code_str = match custom_code {
            Some(custom) => {
                if self.is_code_available(&custom) {
                    format!("MIAOU-{}", custom.to_uppercase())
                } else {
                    return Err(ReferralError::CodeAlreadyExists);
                }
            },
            None => {
                // G√©n√©rer code unique automatiquement
                let suffix = self.generate_unique_suffix();
                format!("MIAOU-{}", suffix)
            }
        };
        
        let referral_code = ReferralCode {
            code: code_str.clone(),
            referrer: referrer.clone(),
            created_at: Utc::now(),
            expires_at: Utc::now() + Duration::days(30),
            max_uses: None, // Illimit√© par d√©faut
            current_uses: 0,
            bonus_multiplier: self.calculate_referrer_bonus_multiplier(referrer),
        };
        
        self.referral_codes.insert(code_str.clone(), referral_code.clone());
        
        Ok(referral_code)
    }
    
    pub fn use_referral_code(&mut self, code: &str, new_user: &PeerId) -> Result<ReferralReward, ReferralError> {
        let mut referral_info = self.referral_codes.get_mut(code)
            .ok_or(ReferralError::InvalidCode)?;
        
        // V√©rifications
        if Utc::now() > referral_info.expires_at {
            return Err(ReferralError::CodeExpired);
        }
        
        if let Some(max) = referral_info.max_uses {
            if referral_info.current_uses >= max {
                return Err(ReferralError::CodeMaxUsesReached);
            }
        }
        
        if referral_info.referrer == *new_user {
            return Err(ReferralError::SelfReferral);
        }
        
        // Calculer r√©compenses
        let base_referrer_reward = 200; // Cr√©dits de base pour le parrain
        let base_referee_reward = 100;  // Cr√©dits de base pour le filleul
        
        let referrer_reward = ((base_referrer_reward as f64) * referral_info.bonus_multiplier) as u64;
        let referee_reward = base_referee_reward;
        
        // Bonus jalons
        referral_info.current_uses += 1;
        let milestone_bonus = self.calculate_milestone_bonus(referral_info.current_uses);
        
        // Bonus communaut√© (1% des r√©compenses redistribu√©)
        let community_bonus = (referrer_reward + referee_reward) / 100;
        
        let reward = ReferralReward {
            referrer_reward,
            referee_reward,
            milestone_bonus,
            community_bonus,
        };
        
        // Enregistrer dans l'arbre de parrainage
        self.referral_tree.add_referral(&referral_info.referrer, new_user);
        
        // Distribuer r√©compenses
        self.distribute_referral_rewards(&reward, &referral_info.referrer, new_user)?;
        
        // Tracking pour analytics
        self.tracking.record_successful_referral(code, &referral_info.referrer, new_user);
        
        Ok(reward)
    }
    
    fn calculate_milestone_bonus(&self, usage_count: u32) -> Option<u64> {
        match usage_count {
            10 => Some(500),    // 10e filleul : 500 cr√©dits bonus
            25 => Some(1000),   // 25e filleul : 1000 cr√©dits bonus  
            50 => Some(2500),   // 50e filleul : 2500 cr√©dits bonus
            100 => Some(5000),  // 100e filleul : 5000 cr√©dits bonus
            250 => Some(10000), // 250e filleul : 10000 cr√©dits bonus
            500 => Some(25000), // 500e filleul : 25000 cr√©dits bonus
            _ => None,
        }
    }
    
    pub fn get_referral_stats(&self, referrer: &PeerId) -> ReferralStats {
        let direct_referrals = self.referral_tree.get_direct_referrals(referrer);
        let total_network = self.referral_tree.get_total_network_size(referrer);
        let total_rewards = self.tracking.get_total_referral_rewards(referrer);
        
        ReferralStats {
            total_codes_generated: self.get_codes_by_referrer(referrer).len(),
            direct_referrals: direct_referrals.len(),
            total_network_size: total_network,
            total_rewards_earned: total_rewards,
            top_performing_code: self.get_top_performing_code(referrer),
            recent_activity: self.get_recent_referral_activity(referrer, Duration::days(7)),
        }
    }
}
```

### **Invitations cross-platform (pr√©paration)**
```rust
pub struct CrossPlatformInviter {
    platform_bridges: HashMap<Platform, Box<dyn PlatformBridge>>,
    invitation_templates: InvitationTemplates,
    tracking: InvitationTracking,
}

#[derive(Debug, Clone)]
pub enum Platform {
    WhatsApp,
    Telegram,
    Signal,
    Discord,
    Email,
    SMS,
    QRCode,
    NFC,
}

pub trait PlatformBridge: Send + Sync {
    async fn send_invitation(&self, invitation: &Invitation) -> Result<InvitationResult, PlatformError>;
    fn is_available(&self) -> bool;
    fn get_rate_limits(&self) -> RateLimits;
}

#[derive(Debug, Clone)]
pub struct Invitation {
    pub referral_code: ReferralCode,
    pub platform: Platform,
    pub recipient: ContactInfo,
    pub personal_message: Option<String>,
    pub template: InvitationTemplate,
}

impl CrossPlatformInviter {
    pub async fn send_invitation(&mut self, invitation: Invitation) -> Result<InvitationResult, InvitationError> {
        // 1. V√©rifier rate limits
        self.check_rate_limits(&invitation.platform, &invitation.referral_code.referrer)?;
        
        // 2. Personnaliser message
        let personalized = self.personalize_invitation(&invitation)?;
        
        // 3. Envoyer via bridge appropri√©
        let bridge = self.platform_bridges.get(&invitation.platform)
            .ok_or(InvitationError::PlatformNotSupported)?;
        
        if !bridge.is_available() {
            return Err(InvitationError::PlatformUnavailable);
        }
        
        let result = bridge.send_invitation(&personalized).await?;
        
        // 4. Tracker pour analytics
        self.tracking.record_invitation_sent(&invitation, &result);
        
        // 5. Planifier follow-up si n√©cessaire
        if result.should_follow_up() {
            self.schedule_follow_up(&invitation, Duration::days(3)).await?;
        }
        
        Ok(result)
    }
    
    fn personalize_invitation(&self, invitation: &Invitation) -> Result<Invitation, InvitationError> {
        let mut personalized = invitation.clone();
        
        // Remplacer variables dans le template
        let mut message = invitation.template.content.clone();
        
        message = message.replace("{referral_code}", &invitation.referral_code.code);
        message = message.replace("{referrer_name}", &self.get_referrer_display_name(&invitation.referral_code.referrer));
        message = message.replace("{download_link}", &self.get_platform_download_link(&invitation.platform));
        message = message.replace("{bonus_amount}", "100"); // Cr√©dits bonus filleul
        
        if let Some(personal) = &invitation.personal_message {
            message = message.replace("{personal_message}", personal);
        }
        
        personalized.template.content = message;
        Ok(personalized)
    }
}

// Exemple de bridge Email
pub struct EmailBridge {
    smtp_config: SmtpConfig,
    rate_limiter: RateLimiter,
}

#[async_trait]
impl PlatformBridge for EmailBridge {
    async fn send_invitation(&self, invitation: &Invitation) -> Result<InvitationResult, PlatformError> {
        if let ContactInfo::Email(email) = &invitation.recipient {
            let email_msg = Message::builder()
                .from("invitations@miaou.chat".parse()?)
                .to(email.parse()?)
                .subject("üê± Rejoins-moi sur Miaou - Messagerie d√©centralis√©e")
                .header(ContentType::TEXT_HTML)
                .body(self.render_html_template(&invitation.template)?)?;
            
            let mailer = SmtpTransport::relay(&self.smtp_config.server)?
                .credentials(Credentials::new(
                    self.smtp_config.username.clone(),
                    self.smtp_config.password.clone()
                ))
                .build();
            
            match mailer.send(&email_msg) {
                Ok(_) => Ok(InvitationResult::Sent { 
                    tracking_id: Uuid::new_v4().to_string(),
                    estimated_delivery: Utc::now() + Duration::minutes(1),
                }),
                Err(e) => Err(PlatformError::SendFailed(e.to_string())),
            }
        } else {
            Err(PlatformError::InvalidContactInfo)
        }
    }
    
    fn is_available(&self) -> bool {
        // V√©rifier connectivit√© SMTP
        self.smtp_config.is_valid() && self.rate_limiter.can_proceed()
    }
    
    fn get_rate_limits(&self) -> RateLimits {
        RateLimits {
            per_minute: 10,
            per_hour: 100,
            per_day: 500,
        }
    }
}
```

---

## üéÆ Gamification et Achievements

### **Syst√®me d'achievements**
```rust
pub struct AchievementSystem {
    unlocked_achievements: HashMap<PeerId, HashSet<AchievementId>>,
    achievement_definitions: HashMap<AchievementId, Achievement>,
    progress_tracking: HashMap<PeerId, ProgressTracker>,
    leaderboards: Leaderboards,
}

#[derive(Debug, Clone)]
pub struct Achievement {
    pub id: AchievementId,
    pub name: String,
    pub description: String,
    pub icon: String,                   // Emoji ou ic√¥ne
    pub category: AchievementCategory,
    pub difficulty: Difficulty,
    pub requirements: Vec<Requirement>,
    pub rewards: AchievementRewards,
    pub hidden: bool,                   // Achievement secret
}

#[derive(Debug, Clone)]
pub enum AchievementCategory {
    Communication,      // Messages, conversations
    Network,           // Connexions, pairs
    Security,          // Rapports, audits
    Community,         // Parrainage, aide
    Technical,         // Contributions code
    Milestones,        // Jalons d'usage
    Special,           // √âv√©nements sp√©ciaux
    Easter_Egg,        // Secrets cach√©s
}

impl AchievementSystem {
    pub fn initialize_achievements(&mut self) {
        // Achievements Communication
        self.add_achievement(Achievement {
            id: "first_message",
            name: "Premier Miaou".to_string(),
            description: "Envoie ton premier message chiffr√©".to_string(),
            icon: "üê±".to_string(),
            category: AchievementCategory::Communication,
            difficulty: Difficulty::Trivial,
            requirements: vec![Requirement::MessagesSent(1)],
            rewards: AchievementRewards {
                credits: 50,
                title: Some("Chaton Bavard".to_string()),
                badge: Some("first_message.png".to_string()),
            },
            hidden: false,
        });
        
        self.add_achievement(Achievement {
            id: "chatterbox",
            name: "Moulin √† Paroles".to_string(),
            description: "Envoie 1000 messages".to_string(),
            icon: "üí¨".to_string(),
            category: AchievementCategory::Communication,
            difficulty: Difficulty::Medium,
            requirements: vec![Requirement::MessagesSent(1000)],
            rewards: AchievementRewards {
                credits: 500,
                title: Some("Bavard Professionnel".to_string()),
                badge: Some("chatterbox.png".to_string()),
            },
            hidden: false,
        });
        
        // Achievements Network
        self.add_achievement(Achievement {
            id: "social_butterfly",
            name: "Papillon Social".to_string(),
            description: "Connecte-toi √† 50 pairs diff√©rents".to_string(),
            icon: "ü¶ã".to_string(),
            category: AchievementCategory::Network,
            difficulty: Difficulty::Hard,
            requirements: vec![Requirement::UniquePeersConnected(50)],
            rewards: AchievementRewards {
                credits: 1000,
                title: Some("Connecteur R√©seau".to_string()),
                badge: Some("social_butterfly.png".to_string()),
            },
            hidden: false,
        });
        
        // Achievements S√©curit√©  
        self.add_achievement(Achievement {
            id: "security_audit",
            name: "Auditeur de S√©curit√©".to_string(),
            description: "Signale ta premi√®re vuln√©rabilit√©".to_string(),
            icon: "üîç".to_string(),
            category: AchievementCategory::Security,
            difficulty: Difficulty::Medium,
            requirements: vec![Requirement::SecurityReportsSubmitted(1)],
            rewards: AchievementRewards {
                credits: 1000,
                title: Some("Chasseur de Bugs".to_string()),
                badge: Some("security_audit.png".to_string()),
            },
            hidden: false,
        });
        
        // Achievements Parrainage
        self.add_achievement(Achievement {
            id: "recruiter",
            name: "Recruteur".to_string(),
            description: "Parraine 10 nouveaux utilisateurs".to_string(),
            icon: "üéØ".to_string(),
            category: AchievementCategory::Community,
            difficulty: Difficulty::Medium,
            requirements: vec![Requirement::ReferralsCompleted(10)],
            rewards: AchievementRewards {
                credits: 2000,
                title: Some("Ambassadeur Miaou".to_string()),
                badge: Some("recruiter.png".to_string()),
            },
            hidden: false,
        });
        
        // Achievement secret
        self.add_achievement(Achievement {
            id: "konami_code",
            name: "Code Konami".to_string(),
            description: "Une s√©quence myst√©rieuse...".to_string(),
            icon: "üïπÔ∏è".to_string(),
            category: AchievementCategory::Easter_Egg,
            difficulty: Difficulty::Secret,
            requirements: vec![Requirement::SecretSequence("konami".to_string())],
            rewards: AchievementRewards {
                credits: 1337,
                title: Some("Hacker Nostalgique".to_string()),
                badge: Some("konami.png".to_string()),
            },
            hidden: true,
        });
    }
    
    pub fn check_achievements(&mut self, peer: &PeerId, event: &GameEvent) -> Vec<AchievementUnlocked> {
        let mut newly_unlocked = Vec::new();
        
        // Mettre √† jour progress
        self.update_progress(peer, event);
        
        let current_progress = self.progress_tracking.get(peer).unwrap();
        let already_unlocked = self.unlocked_achievements.get(peer)
            .cloned()
            .unwrap_or_default();
        
        // V√©rifier chaque achievement
        for (achievement_id, achievement) in &self.achievement_definitions {
            if already_unlocked.contains(achievement_id) {
                continue; // D√©j√† d√©bloqu√©
            }
            
            if self.check_requirements(&achievement.requirements, current_progress) {
                // Achievement d√©bloqu√© !
                self.unlock_achievement(peer, achievement_id.clone());
                
                newly_unlocked.push(AchievementUnlocked {
                    achievement: achievement.clone(),
                    unlocked_at: Utc::now(),
                    progress_snapshot: current_progress.clone(),
                });
                
                // Distribuer r√©compenses
                self.distribute_achievement_rewards(peer, &achievement.rewards);
            }
        }
        
        newly_unlocked
    }
    
    pub fn get_achievement_progress(&self, peer: &PeerId) -> AchievementProgress {
        let progress = self.progress_tracking.get(peer);
        let unlocked = self.unlocked_achievements.get(peer)
            .cloned()
            .unwrap_or_default();
        
        let total_achievements = self.achievement_definitions.len();
        let unlocked_count = unlocked.len();
        let completion_percentage = (unlocked_count as f64 / total_achievements as f64) * 100.0;
        
        AchievementProgress {
            total_achievements,
            unlocked_count,
            completion_percentage,
            recent_unlocks: self.get_recent_unlocks(peer, Duration::days(7)),
            next_achievements: self.get_next_achievable(peer),
            leaderboard_position: self.leaderboards.get_position(peer),
        }
    }
}
```

### **Interface gamifi√©e**
```rust
// Extension CLI avec commandes gamification
#[derive(Subcommand)]
pub enum GameCommands {
    /// Afficher le profil et statistiques
    Profile,
    
    /// Voir les achievements d√©bloqu√©s
    Achievements,
    
    /// Afficher le classement
    Leaderboard {
        #[arg(short, long)]
        category: Option<String>,
    },
    
    /// G√©n√©rer un code de parrainage
    GenerateReferral {
        #[arg(short, long)]
        custom_code: Option<String>,
    },
    
    /// Utiliser un code de parrainage
    UseReferral {
        code: String,
    },
    
    /// Voir les statistiques de parrainage
    ReferralStats,
    
    /// Envoyer une invitation
    SendInvitation {
        #[arg(short, long)]
        platform: String,
        #[arg(short, long)]
        contact: String,
        #[arg(short, long)]
        message: Option<String>,
    },
    
    /// Voir l'historique des gains de cr√©dits
    CreditHistory {
        #[arg(short, long)]
        days: Option<u32>,
    },
}

impl GameCommands {
    pub async fn execute(&self, app: &mut MiaouApp) -> Result<(), CliError> {
        match self {
            GameCommands::Profile => {
                let profile = app.rewards.get_user_profile(&app.local_peer_id).await?;
                
                println!("üê± Profil Miaou de {}", profile.display_name);
                println!("‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê");
                println!("‚îÇ üí∞ Cr√©dits totaux : {:>15} ‚îÇ", profile.total_credits);
                println!("‚îÇ ‚≠ê R√©putation      : {:>15.1} ‚îÇ", profile.reputation_score);
                println!("‚îÇ üèÜ Achievements    : {:>15} ‚îÇ", format!("{}/{}", profile.unlocked_achievements, profile.total_achievements));
                println!("‚îÇ üë• Parrainages     : {:>15} ‚îÇ", profile.successful_referrals);
                println!("‚îÇ ‚è±Ô∏è  Temps actif     : {:>15} ‚îÇ", format_duration(profile.total_uptime));
                println!("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò");
                
                if let Some(title) = profile.current_title {
                    println!("üéñÔ∏è  Titre actuel : {}", title);
                }
                
                println!("\nüìä R√©partition des cr√©dits :");
                for (category, amount) in profile.credits_breakdown {
                    let percentage = (amount as f64 / profile.total_credits as f64) * 100.0;
                    println!("  {:20} : {:>8} ({:>5.1}%)", 
                        format!("{:?}", category), amount, percentage);
                }
            },
            
            GameCommands::Achievements => {
                let achievements = app.achievements.get_user_achievements(&app.local_peer_id).await?;
                
                println!("üèÜ Achievements d√©bloqu√©s :");
                for achievement in &achievements.unlocked {
                    println!("  {} {} - {}", 
                        achievement.icon, 
                        achievement.name,
                        achievement.description
                    );
                }
                
                println!("\nüéØ Prochains objectifs :");
                for next in &achievements.next_achievable {
                    let progress_bar = self.create_progress_bar(next.current_progress, next.required_progress);
                    println!("  {} {} - {} [{}]", 
                        next.icon,
                        next.name,
                        next.description,
                        progress_bar
                    );
                }
            },
            
            GameCommands::GenerateReferral { custom_code } => {
                let referral = app.referrals.generate_code(&app.local_peer_id, custom_code.clone()).await?;
                
                println!("üéØ Code de parrainage g√©n√©r√© :");
                println!("‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê");
                println!("‚îÇ Code : {}                   ‚îÇ", referral.code);
                println!("‚îÇ Expire : {}              ‚îÇ", referral.expires_at.format("%d/%m/%Y"));
                println!("‚îÇ Utilisations : {}/{}             ‚îÇ", 
                    referral.current_uses, 
                    referral.max_uses.map(|m| m.to_string()).unwrap_or("‚àû".to_string())
                );
                println!("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò");
                
                println!("\nüì± Lien d'invitation :");
                println!("miaou://join/{}", referral.code);
                
                println!("\nüîó Lien web :");
                println!("https://join.miaou.chat/{}", referral.code);
            },
            
            GameCommands::CreditHistory { days } => {
                let history = app.rewards.get_credit_history(
                    &app.local_peer_id,
                    days.unwrap_or(7)
                ).await?;
                
                println!("üí∞ Historique des gains (derniers {} jours) :", days.unwrap_or(7));
                
                let mut daily_totals: BTreeMap<Date<Utc>, u64> = BTreeMap::new();
                for entry in &history.entries {
                    let date = entry.timestamp.date();
                    *daily_totals.entry(date).or_insert(0) += entry.amount;
                }
                
                for (date, total) in daily_totals {
                    println!("üìÖ {} : +{} cr√©dits", date.format("%d/%m"), total);
                    
                    // D√©tail par type pour ce jour
                    let day_entries: Vec<_> = history.entries.iter()
                        .filter(|e| e.timestamp.date() == date)
                        .collect();
                    
                    for entry in day_entries {
                        println!("   ‚îî‚îÄ {} : +{} ({})", 
                            entry.timestamp.format("%H:%M"),
                            entry.amount,
                            format!("{:?}", entry.contribution_type)
                        );
                    }
                }
                
                println!("\nüìà Total p√©riode : +{} cr√©dits", history.total_earned);
            },
            
            _ => {}
        }
        
        Ok(())
    }
    
    fn create_progress_bar(&self, current: u64, required: u64) -> String {
        let percentage = (current as f64 / required as f64).min(1.0);
        let filled = (percentage * 20.0) as usize;
        let empty = 20 - filled;
        
        format!("{}{}  {}/{}",
            "‚ñà".repeat(filled),
            "‚ñë".repeat(empty),
            current,
            required
        )
    }
}
```

---

## üìä M√©triques et Crit√®res de Succ√®s

### **KPIs √âconomie**
- ‚úÖ **Syst√®me de cr√©dits** fonctionnel et √©quilibr√©
- ‚úÖ **Anti-spam √©conomique** efficace (< 1% de spam)
- ‚úÖ **Limites quotidiennes** respect√©es automatiquement
- ‚úÖ **Distribution de r√©compenses** √©quitable et motivante

### **KPIs Parrainage**
- ‚úÖ **Codes de parrainage** g√©n√©r√©s et utilisables
- ‚úÖ **Invitations cross-platform** (email, SMS minimum)
- ‚úÖ **Tracking de conversion** >= 10% taux de r√©ussite
- ‚úÖ **R√©compenses distribu√©es** correctement

### **KPIs Gamification**
- ‚úÖ **Achievements system** avec 50+ achievements
- ‚úÖ **Progression tracking** en temps r√©el
- ‚úÖ **Leaderboards** communautaires
- ‚úÖ **Engagement utilisateur** : temps d'usage +50%

---

## üöÄ Livrables de la Version

### **üì¶ Nouveaux packages**
- `libmiaou-rewards` : Syst√®me de r√©compenses local
- `libmiaou-gamification` : Achievements et progression
- `libmiaou-referrals` : Syst√®me de parrainage
- `libmiaou-invitations` : Invitations cross-platform

### **üéÆ Fonctionnalit√©s gamification**
- Interface CLI gamifi√©e avec statistiques
- Syst√®me d'achievements complet (50+ achievements)
- Leaderboards communautaires
- Profils utilisateur enrichis
- Historique d√©taill√© des contributions

---

## üóìÔ∏è Pr√©paration v0.4.0

Cette version pr√©pare la **v0.4.0 "Toilettage Royal"** qui ajoutera :
- Application desktop native (Tauri)
- Interface web progressive (WebAssembly)
- Site d'accueil avec documentation
- UX/UI moderne et accessible

**L'√©conomie gamifi√©e de la v0.3.0 motive l'adoption** - la v0.4.0 rendra l'exp√©rience belle ! üé®

---

*Le ronronnement du bonheur r√©sonne... Miaou r√©compense maintenant chaque geste de bienveillance !* üê±üíñ