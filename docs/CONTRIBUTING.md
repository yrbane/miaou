# ü§ù GUIDE DE CONTRIBUTION

*Guidelines pour contribuer au projet Miaou*

---

## üè¥‚Äç‚ò†Ô∏è Philosophie de contribution

**Miaou incarne un esprit de libert√© num√©rique et de r√©sistance technologique.** Contribuer √† Miaou, c'est participer √† la construction d'un outil d'√©mancipation num√©rique.

**Nos valeurs :**
- **Pragmatisme technique** : Code robuste et auditable
- **Intransigeance sur les principes** : D√©centralisation et confidentialit√©
- **Qualit√© non n√©gociable** : Standards professionnels stricts
- **Esprit pirate** : Contourner les limitations, connecter les √Ælots

---

## ‚ö° Exigences techniques NON N√âGOCIABLES

### **üìã Qualit√© du code**
- **üèóÔ∏è Architecture SOLID** : Respect strict des 5 principes
- **üß™ TDD obligatoire** : Tests √©crits AVANT le code
- **üìä Couverture >= 90%** : Mesur√©e avec cargo-tarpaulin + fuzzing obligatoire
- **üß™ Tests KAT crypto** : Vecteurs officiels pour primitives cryptographiques
- **üö´ Z√©ro commit** si tests critiques √©chouent
- **üìù Commentaires exhaustifs** en fran√ßais
- **üìö Documentation stricte obligatoire** : `#![warn(missing_docs)]` dans TOUS les crates
- **üîê S√©curit√© by design** : Validation et sanitization syst√©matiques

### **üß© Architecture modulaire**
- **üî¨ Micro-responsabilit√©s** : Un crate = une fonction pr√©cise
- **üìã Allowlist de d√©pendances** : Seules les d√©pendances audit√©es autoris√©es (voir DEPENDENCIES.md)
- **üîó D√©pendances internes autoris√©es** entre crates Miaou
- **üîå Hi√©rarchie claire** : Pas de d√©pendances circulaires
- **üîç Audit continu** : cargo-audit en CI pour vuln√©rabilit√©s

### **üåç Standards internationaux**
- **üåê i18n d√®s le d√©part** : Pas de strings hardcod√©es
- **‚ôø Accessibilit√© WCAG 2.1 AA** minimum
- **üì± Responsive** : Adaptation tous √©crans
- **üé® Templates externes** : S√©paration logique/pr√©sentation

---

## üõ†Ô∏è Processus de d√©veloppement

### **1. üç¥ Fork et setup**
```bash
# Fork du repo sur GitHub
git clone https://github.com/VOTRE_USERNAME/miaou.git
cd miaou

# Configuration des hooks pre-commit
cargo install cargo-tarpaulin cargo-mutagen
cp scripts/pre-commit.sh .git/hooks/pre-commit
chmod +x .git/hooks/pre-commit
```

### **2. üåø Workflow Git par versions**

Le projet utilise une strat√©gie de branches d√©di√©es par version majeure :

```
main (production)
‚îú‚îÄ‚îÄ v0.1.0-premiere-griffe (Phase 1 - Fondations crypto)
‚îú‚îÄ‚îÄ v0.2.0-radar-moustaches (Phase 2 - R√©seau P2P)  
‚îú‚îÄ‚îÄ v0.3.0-ronron-bonheur (Phase 3 - √âconomie gamification)
‚îú‚îÄ‚îÄ v0.4.0-toilettage-royal (Phase 4 - UI/UX multi-plateforme)
‚îú‚îÄ‚îÄ v0.5.0-chat-gouttiere (Phase 5 - Interop√©rabilit√©)
‚îú‚îÄ‚îÄ v0.6.0-neuf-vies (Phase 6 - Fonctionnalit√©s avanc√©es)
‚îî‚îÄ‚îÄ v1.0.0-matou-majestueux (Phase 7 - Production compl√®te)
```

**üìñ Documentation compl√®te :** [GIT_WORKFLOW.md](GIT_WORKFLOW.md)

```bash
# D√©veloppement sur une version sp√©cifique
git checkout v0.1.0-premiere-griffe  # Exemple pour Phase 1

# Cr√©er une branche de fonctionnalit√© depuis la version
git checkout -b feature/crypto-primitives v0.1.0-premiere-griffe

# OU pour un bugfix
git checkout -b fix/description-bug

# OU pour de la documentation
git checkout -b docs/sujet-modifie
```

### **3. üß™ D√©veloppement TDD strict**
```bash
# 1. √âcrire les tests d'abord
cargo test nom_du_test -- --ignored

# 2. Lancer les tests (qui doivent √©chouer)
cargo test

# 3. √âcrire le minimum de code pour passer
# 4. Refactorer en gardant les tests verts
# 5. R√©p√©ter
```

### **4. ‚úÖ Checklist avant commit**
- [ ] **Tests √©crits AVANT le code**
- [ ] **Tous les tests passent** : `cargo test`
- [ ] **Couverture >= 95%** : `cargo tarpaulin --verbose`
- [ ] **Linting clean** : `cargo clippy -- -D warnings`
- [ ] **Format Rust** : `cargo fmt`
- [ ] **Documentation stricte** : `cargo doc --no-deps` + pas d'avertissements missing_docs
- [ ] **Commentaires en fran√ßais** pour la logique m√©tier
- [ ] **Pas de `println!` ou `dbg!`** dans le code final

### **5. üìù Messages de commit**
```bash
# Format : type(scope): description courte

# Types autoris√©s :
feat(crypto): ajoute chiffrement ChaCha20-Poly1305
fix(network): corrige timeout connexion P2P  
docs(readme): met √† jour installation
test(messaging): ajoute tests unitaires envoi
refactor(ui): simplifie gestion des th√®mes
perf(blockchain): optimise validation des blocs
security(auth): durcit v√©rification signatures

# Le message doit √™tre en fran√ßais
# Ligne 1 : < 50 caract√®res
# Ligne 3+ : d√©tails si n√©cessaire
```

---

## üèóÔ∏è Architecture et conventions

### **üì¶ Structure des crates**
```
nom-du-domaine/
‚îú‚îÄ‚îÄ Cargo.toml          # M√©tadonn√©es et d√©pendances
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ lib.rs          # Point d'entr√©e avec documentation
‚îÇ   ‚îú‚îÄ‚îÄ error.rs        # Types d'erreur sp√©cifiques
‚îÇ   ‚îú‚îÄ‚îÄ config.rs       # Configuration (si applicable)
‚îÇ   ‚îî‚îÄ‚îÄ modules/        # Modules fonctionnels
‚îú‚îÄ‚îÄ tests/              # Tests d'int√©gration
‚îú‚îÄ‚îÄ benches/            # Benchmarks
‚îî‚îÄ‚îÄ examples/           # Exemples d'usage
```

### **üîê Conventions de s√©curit√©**
```rust
// ‚úÖ BON : Types s√©curis√©s
#[derive(Zeroize, ZeroizeOnDrop)]
pub struct PrivateKey([u8; 32]);

// ‚ùå INTERDIT : Debug sur secrets
impl fmt::Debug for PrivateKey {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "PrivateKey([REDACTED])")
    }
}

// ‚úÖ BON : Validation des entr√©es
pub fn decrypt_message(ciphertext: &[u8]) -> Result<Vec<u8>, CryptoError> {
    if ciphertext.len() < MIN_CIPHERTEXT_LEN {
        return Err(CryptoError::InvalidInput);
    }
    // ...
}
```

### **üìù Documentation stricte obligatoire**

**üö´ R√àGLES NON N√âGOCIABLES :**
- **TOUS les crates** doivent avoir `#![warn(missing_docs)]` en d√©but de `lib.rs` ou `main.rs`
- **TOUS les items publics** doivent √™tre document√©s (modules, fonctions, structs, enums, champs)
- **TOUS les param√®tres** et valeurs de retour doivent √™tre expliqu√©s
- **TOUS les types d'erreur** possibles doivent √™tre document√©s

```rust
//! Documentation du crate obligatoire
#![warn(missing_docs)]
#![warn(rustdoc::broken_intra_doc_links)]

/// Chiffre un message avec l'algorithme ChaCha20-Poly1305.
/// 
/// Cette fonction impl√©mente le chiffrement authentifi√© AEAD en utilisant
/// une cl√© d√©riv√©e via HKDF et un nonce al√©atoire g√©n√©r√© de mani√®re s√©curis√©e.
///
/// # Arguments
/// 
/// * `plaintext` - Le message en clair √† chiffrer
/// * `key` - La cl√© de chiffrement (32 bytes)
/// * `associated_data` - Donn√©es authentifi√©es non chiffr√©es
///
/// # Exemples
///
/// ```rust
/// use crypto_encryption::encrypt_message;
/// 
/// let message = b"Message secret";
/// let key = generate_key();
/// let result = encrypt_message(message, &key, b"headers")?;
/// ```
///
/// # Erreurs
///
/// Retourne `CryptoError::InvalidKey` si la cl√© n'a pas la bonne taille.
pub fn encrypt_message(
    plaintext: &[u8], 
    key: &Key, 
    associated_data: &[u8]
) -> Result<EncryptedMessage, CryptoError> {
    // Impl√©mentation...
}

/// Structure repr√©sentant un profil utilisateur
pub struct ProfileInfo {
    /// Nom du profil choisi par l'utilisateur
    pub name: String,
    /// Identifiant unique g√©n√©r√© automatiquement
    pub id: ProfileId,
}
```

---

## üß™ Tests et qualit√©

### **Types de tests obligatoires**
```rust
// 1. Tests unitaires
#[cfg(test)]
mod tests {
    use super::*;
    use proptest::prelude::*;

    #[test]
    fn test_encrypt_decrypt_roundtrip() {
        let plaintext = b"test message";
        let key = generate_test_key();
        
        let encrypted = encrypt_message(plaintext, &key, b"").unwrap();
        let decrypted = decrypt_message(&encrypted, &key, b"").unwrap();
        
        assert_eq!(plaintext, &decrypted[..]);
    }

    // 2. Tests de propri√©t√©s
    proptest! {
        #[test]
        fn encryption_is_deterministic_with_same_nonce(
            plaintext in any::<Vec<u8>>(),
        ) {
            let key = generate_test_key();
            let nonce = [0u8; 12];
            
            let result1 = encrypt_with_nonce(plaintext, &key, nonce);
            let result2 = encrypt_with_nonce(plaintext, &key, nonce);
            
            prop_assert_eq!(result1, result2);
        }
    }
}

// 3. Tests d'int√©gration (dans tests/)
#[test]
fn integration_full_protocol_handshake() {
    // Test bout-en-bout
}

// 4. Benchmarks (dans benches/)
use criterion::{criterion_group, criterion_main, Criterion};

fn benchmark_encryption(c: &mut Criterion) {
    c.bench_function("encrypt_1kb", |b| {
        let data = vec![0u8; 1024];
        let key = generate_test_key();
        
        b.iter(|| encrypt_message(&data, &key, b""))
    });
}
```

### **üîç Outils de qualit√©**
```bash
# Tests avec couverture
cargo tarpaulin --verbose --timeout 120

# Tests de mutation (d√©tecte les tests faibles)
cargo mutagen

# Linting strict
cargo clippy -- -D warnings -D clippy::pedantic

# Audit des d√©pendances
cargo audit

# Fuzzing (pour les parseurs)
cargo install cargo-fuzz
cargo fuzz run parser_target
```

---

## üîê S√©curit√© et cryptographie

### **‚ùå INTERDICTIONS ABSOLUES**
- **Pas de crypto from scratch** : OBLIGATOIRE d'utiliser ring, RustCrypto, libsignal
- **Pas de `unsafe` injustifi√©** autour des secrets
- **Pas de logs de secrets** : Jamais de cl√©s en logs
- **Pas de timing attacks** : Comparaisons constant-time
- **Pas de d√©pendances non-audit√©es** : V√©rifier DEPENDENCIES.md

### **‚úÖ BONNES PRATIQUES**
```rust
// Comparaison constant-time
use subtle::ConstantTimeEq;

fn verify_signature(signature: &[u8], expected: &[u8]) -> bool {
    signature.ct_eq(expected).into()
}

// Zeroization automatique
use zeroize::{Zeroize, ZeroizeOnDrop};

#[derive(Zeroize, ZeroizeOnDrop)]
struct Secret {
    data: [u8; 32],
}

// Validation stricte
fn parse_message(data: &[u8]) -> Result<Message, ParseError> {
    if data.len() < HEADER_SIZE {
        return Err(ParseError::TooShort);
    }
    if data.len() > MAX_MESSAGE_SIZE {
        return Err(ParseError::TooLong);
    }
    // ...
}
```

---

## üìã Pull Request Process

### **1. ‚úÖ Checklist PR**
- [ ] **Branche √† jour** avec main
- [ ] **Tests passent** en local
- [ ] **Description claire** du changement
- [ ] **Screenshots** si changement UI
- [ ] **Documentation** mise √† jour
- [ ] **CHANGELOG.md** mis √† jour
- [ ] **Pas de breaking changes** sans discussion

### **2. üìù Template de PR**
```markdown
## üéØ Objectif
Br√®ve description du probl√®me r√©solu ou de la fonctionnalit√© ajout√©e.

## üîß Changements
- [ ] Changement 1
- [ ] Changement 2

## üß™ Tests
- [ ] Tests unitaires ajout√©s
- [ ] Tests d'int√©gration mis √† jour
- [ ] Benchmarks si pertinent

## üì∏ Screenshots
(Si applicable)

## ‚ö†Ô∏è Notes pour les reviewers
Points d'attention particuliers.
```

### **3. üëÄ Processus de review**
1. **Review automatique** : CI/CD doit passer
2. **Review manuelle** : Au moins 1 approbation
3. **Merge** : Squash and merge preferred
4. **Deploy** : Automatique sur branche main

---

## üèÜ Reconnaissance des contributions

### **üåü Types de contributions valoris√©es**
- **Code** : Fonctionnalit√©s, corrections, optimisations
- **Tests** : Am√©lioration de la couverture et qualit√©
- **Documentation** : Guides, exemples, traductions
- **S√©curit√©** : Audits, corrections de vuln√©rabilit√©s
- **Design** : UI/UX, assets, th√®mes
- **Infrastructure** : CI/CD, tooling, optimisations

### **üéÅ R√©compenses en Croquettes**
- **Premi√®re contribution** : 50 croquettes
- **Bug critique corrig√©** : 100 croquettes
- **Nouvelle fonctionnalit√© majeure** : 200 croquettes
- **Audit de s√©curit√©** : 500 croquettes
- **Documentation majeure** : 100 croquettes

### **üèÖ Hall of Fame**
Les contributeurs exceptionnels seront mis en avant dans :
- README principal
- Site web du projet
- Cr√©dits dans l'application

---

## üìû Communication et support

### **üí¨ Canaux de communication**
- **Issues GitHub** : Bugs, demandes de fonctionnalit√©s
- **Discussions GitHub** : Questions, id√©es, aide
- **Matrix/IRC** : Discussion temps r√©el (√† venir)

### **üÜò Obtenir de l'aide**
1. **Documentation** : Lire README, CONTRIBUTING, SECURITY
2. **Glossaire** : V√©rifier GLOSSAIRE.md pour les termes
3. **Issues** : Chercher les issues existantes
4. **Discussion** : Cr√©er une discussion GitHub
5. **Direct** : Contacter les mainteneurs

---

## üéØ Conclusion

Contribuer √† Miaou, c'est participer √† la construction d'un Internet plus libre et plus respectueux de la vie priv√©e. Chaque ligne de code compte dans cette mission.

**Remember :** *Move fast and don't break cryptography* üè¥‚Äç‚ò†Ô∏è

---

*Merci de contribuer √† l'√©mancipation num√©rique !*