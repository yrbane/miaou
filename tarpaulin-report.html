<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","seb","Dev","miaou","benches","crypto_bench.rs"],"content":"// Benchmarks d√©taill√©s pour les primitives cryptographiques\n// Performance tests pour Miaou v0.1.0\n\nuse criterion::{black_box, criterion_group, criterion_main, BenchmarkId, Criterion, Throughput};\nuse miaou_crypto::{\n    aead::{decrypt, encrypt_auto_nonce, AeadKeyRef},\n    hash::blake3_32,\n    kdf::{hash_password, Argon2Config},\n    sign::Keypair,\n};\nuse rand_core::OsRng;\nuse secrecy::SecretString;\n\nfn bench_blake3_hashing(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"blake3_hashing\");\n\n    // Test diff√©rentes tailles de donn√©es\n    for size in \u0026[1024, 4096, 16384, 65536, 262_144, 1_048_576] {\n        group.throughput(Throughput::Bytes(*size as u64));\n        let data = vec![0u8; *size];\n\n        group.bench_with_input(BenchmarkId::new(\"hash\", size), size, |b, \u0026_size| {\n            b.iter(|| blake3_32(black_box(\u0026data)));\n        });\n    }\n    group.finish();\n}\n\nfn bench_ed25519_operations(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"ed25519_operations\");\n\n    let keypair = Keypair::generate();\n    let message = b\"benchmark message for signature testing\";\n    let signature = keypair.sign(message);\n\n    group.bench_function(\"key_generation\", |b| b.iter(Keypair::generate));\n\n    group.bench_function(\"signing\", |b| b.iter(|| keypair.sign(black_box(message))));\n\n    group.bench_function(\"verification\", |b| {\n        b.iter(|| {\n            keypair\n                .verify(black_box(message), black_box(\u0026signature))\n                .unwrap();\n        });\n    });\n\n    group.finish();\n}\n\nfn bench_chacha20_poly1305(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"chacha20_poly1305\");\n\n    let key = AeadKeyRef::from_bytes([42u8; 32]);\n    let aad = b\"benchmark_aad\";\n    let mut rng = OsRng;\n\n    // Test diff√©rentes tailles de donn√©es\n    for size in \u0026[64, 256, 1024, 4096, 16384] {\n        group.throughput(Throughput::Bytes(*size as u64));\n        let data = vec![0u8; *size];\n        let encrypted = encrypt_auto_nonce(\u0026key, aad, \u0026data, \u0026mut rng).unwrap();\n\n        group.bench_with_input(BenchmarkId::new(\"encrypt\", size), size, |b, \u0026_size| {\n            b.iter(|| encrypt_auto_nonce(\u0026key, aad, black_box(\u0026data), \u0026mut rng).unwrap());\n        });\n\n        group.bench_with_input(BenchmarkId::new(\"decrypt\", size), size, |b, \u0026_size| {\n            b.iter(|| decrypt(\u0026key, aad, black_box(\u0026encrypted)).unwrap());\n        });\n    }\n    group.finish();\n}\n\nfn bench_argon2_kdf(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"argon2_kdf\");\n\n    let password = SecretString::new(\"test_password_for_benchmarking\".to_string());\n\n    group.bench_function(\"fast_insecure\", |b| {\n        let config = Argon2Config::fast_insecure();\n        b.iter(|| hash_password(black_box(\u0026password), black_box(\u0026config)).unwrap());\n    });\n\n    group.bench_function(\"balanced\", |b| {\n        let config = Argon2Config::balanced();\n        b.iter(|| hash_password(black_box(\u0026password), black_box(\u0026config)).unwrap());\n    });\n\n    group.bench_function(\"secure\", |b| {\n        let config = Argon2Config::secure();\n        b.iter(|| hash_password(black_box(\u0026password), black_box(\u0026config)).unwrap());\n    });\n\n    group.finish();\n}\n\nfn bench_combined_workflow(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"combined_workflow\");\n\n    // Workflow complet : g√©n√©ration cl√© + chiffrement + signature\n    let message = b\"Complete workflow test message\";\n    let aad = b\"workflow_test\";\n    let mut rng = OsRng;\n\n    group.bench_function(\"complete_encrypt_sign\", |b| {\n        b.iter(|| {\n            // G√©n√©ration des cl√©s\n            let keypair = Keypair::generate();\n            let aead_key = AeadKeyRef::from_bytes([42u8; 32]);\n\n            // Chiffrement\n            let encrypted =\n                encrypt_auto_nonce(\u0026aead_key, aad, black_box(message), \u0026mut rng).unwrap();\n\n            // Signature du chiffr√©\n            let signature = keypair.sign(\u0026encrypted.ciphertext);\n\n            // Hash du tout pour int√©grit√©\n            let mut combined = encrypted.ciphertext.clone();\n            combined.extend_from_slice(\u0026signature.to_bytes());\n            let _hash = blake3_32(\u0026combined);\n\n            (encrypted, signature)\n        });\n    });\n\n    group.finish();\n}\n\ncriterion_group!(\n    benches,\n    bench_blake3_hashing,\n    bench_ed25519_operations,\n    bench_chacha20_poly1305,\n    bench_argon2_kdf,\n    bench_combined_workflow\n);\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","seb","Dev","miaou","miaou-cli","src","main.rs"],"content":"//! # Miaou CLI v0.1.0\n//!\n//! Interface de ligne de commande interactive pour Miaou.\n//!\n//! Fournit une CLI compl√®te pour la gestion des profils, tests cryptographiques,\n//! et toutes les fonctionnalit√©s de base de Miaou.\n\n#![warn(missing_docs)]\n#![warn(rustdoc::broken_intra_doc_links)]\n\nuse anyhow::{Context, Result};\nuse clap::{Parser, Subcommand};\nuse miaou_core::{\n    crypto::{\n        aead::{decrypt, encrypt_auto_nonce, AeadKeyRef},\n        hash::blake3_32,\n        kdf::{hash_password, verify_password, Argon2Config},\n        sign::Keypair,\n    },\n    initialize,\n    storage::SecureStorage,\n    version_info,\n};\nuse secrecy::{ExposeSecret, SecretString};\nuse std::io::{self, Write};\nuse std::path::PathBuf;\n\n#[derive(Parser)]\n#[command(name = \"miaou-cli\")]\n#[command(about = \"Interface de ligne de commande pour Miaou v0.1.0\")]\n#[command(version = env!(\"CARGO_PKG_VERSION\"))]\nstruct Cli {\n    #[command(subcommand)]\n    command: Option\u003cCommands\u003e,\n\n    /// R√©pertoire de donn√©es Miaou\n    #[arg(long, default_value = \"~/.miaou\")]\n    data_dir: PathBuf,\n\n    /// Mode verbeux\n    #[arg(short, long)]\n    verbose: bool,\n}\n\n#[derive(Subcommand)]\nenum Commands {\n    /// Informations sur la version et l'√©tat\n    Status,\n\n    /// Tests des primitives cryptographiques\n    CryptoTest,\n\n    /// Gestion des profils utilisateur\n    Profile {\n        #[command(subcommand)]\n        action: ProfileAction,\n    },\n\n    /// Tests interactifs de chiffrement\n    TestEncrypt {\n        /// Message √† chiffrer\n        #[arg(short, long)]\n        message: Option\u003cString\u003e,\n    },\n\n    /// Tests interactifs de signature\n    TestSign {\n        /// Message √† signer\n        #[arg(short, long)]\n        message: Option\u003cString\u003e,\n    },\n\n    /// Benchmarks de performance\n    Benchmark,\n\n    /// Mode interactif (par d√©faut)\n    Interactive,\n}\n\n#[derive(Subcommand)]\nenum ProfileAction {\n    /// Cr√©er un nouveau profil\n    Create {\n        /// Nom du profil\n        name: String,\n    },\n    /// Lister les profils existants\n    List,\n    /// Supprimer un profil\n    Delete {\n        /// Nom du profil\n        name: String,\n    },\n    /// Afficher les d√©tails d'un profil\n    Show {\n        /// Nom du profil\n        name: String,\n    },\n}\n\nstruct MiaouCli {\n    data_dir: PathBuf,\n    _verbose: bool, // Pr√©vu pour les logs verbeux futurs\n    storage: SecureStorage,\n}\n\nimpl MiaouCli {\n    fn new(data_dir: PathBuf, verbose: bool) -\u003e Result\u003cSelf\u003e {\n        // Cr√©er le r√©pertoire de donn√©es si n√©cessaire\n        let data_dir = expand_path(data_dir)?;\n        std::fs::create_dir_all(\u0026data_dir)\n            .context(\"Impossible de cr√©er le r√©pertoire de donn√©es\")?;\n\n        // Initialiser le syst√®me de stockage s√©curis√©\n        let storage = SecureStorage::new(\u0026data_dir)?;\n\n        Ok(Self {\n            data_dir,\n            _verbose: verbose,\n            storage,\n        })\n    }\n\n    fn run_command(\u0026self, command: Commands) -\u003e Result\u003c()\u003e {\n        match command {\n            Commands::Status =\u003e self.show_status(),\n            Commands::CryptoTest =\u003e self.run_crypto_tests(),\n            Commands::Profile { action } =\u003e self.handle_profile(action),\n            Commands::TestEncrypt { message } =\u003e self.test_encryption(message),\n            Commands::TestSign { message } =\u003e self.test_signing(message),\n            Commands::Benchmark =\u003e self.run_benchmarks(),\n            Commands::Interactive =\u003e self.interactive_mode(),\n        }\n    }\n\n    fn show_status(\u0026self) -\u003e Result\u003c()\u003e {\n        println!(\"üê± {}\", version_info());\n        println!();\n\n        // Test d'initialisation\n        match initialize() {\n            Ok(()) =\u003e {\n                println!(\"‚úÖ Syst√®me cryptographique: OK\");\n                println!(\"‚úÖ Modules charg√©s: OK\");\n            }\n            Err(e) =\u003e {\n                println!(\"‚ùå Erreur d'initialisation: {}\", e);\n                return Ok(());\n            }\n        }\n\n        // Informations sur le r√©pertoire de donn√©es\n        println!(\"üìÅ R√©pertoire de donn√©es: {}\", self.data_dir.display());\n        println!(\"üìä Espace disque: {}\", get_disk_space(\u0026self.data_dir)?);\n\n        // Informations sur les profils\n        let profiles = self.storage.list_profiles()?;\n        println!(\"üë§ Profils configur√©s: {}\", profiles.len());\n\n        // Informations syst√®me\n        println!();\n        println!(\"üñ•Ô∏è  Plateforme: {}\", std::env::consts::OS);\n        println!(\"üèóÔ∏è  Architecture: {}\", std::env::consts::ARCH);\n\n        #[cfg(target_os = \"android\")]\n        println!(\"üì± Support Android: activ√©\");\n        #[cfg(target_os = \"ios\")]\n        println!(\"üì± Support iOS: activ√©\");\n        #[cfg(not(any(target_os = \"android\", target_os = \"ios\")))]\n        println!(\"üñ•Ô∏è  Version desktop\");\n\n        Ok(())\n    }\n\n    fn run_crypto_tests(\u0026self) -\u003e Result\u003c()\u003e {\n        println!(\"üß™ Tests des primitives cryptographiques Miaou v0.1.0\");\n        println!();\n\n        // Test AEAD (ChaCha20-Poly1305)\n        print!(\"üîí Test AEAD ChaCha20-Poly1305... \");\n        io::stdout().flush()?;\n\n        let key = AeadKeyRef::from_bytes([42u8; 32]);\n        let plaintext = b\"Message secret pour test AEAD\";\n        let aad = b\"miaou_v0.1.0_test\";\n        let mut rng = rand_core::OsRng;\n\n        let encrypted = encrypt_auto_nonce(\u0026key, aad, plaintext, \u0026mut rng)\n            .context(\"√âchec du chiffrement AEAD\")?;\n        let decrypted = decrypt(\u0026key, aad, \u0026encrypted).context(\"√âchec du d√©chiffrement AEAD\")?;\n\n        if \u0026decrypted == plaintext {\n            println!(\"‚úÖ OK\");\n        } else {\n            println!(\"‚ùå √âCHEC\");\n            return Err(anyhow::anyhow!(\n                \"Les donn√©es d√©chiffr√©es ne correspondent pas\"\n            ));\n        }\n\n        // Test signatures Ed25519\n        print!(\"‚úçÔ∏è  Test signatures Ed25519... \");\n        io::stdout().flush()?;\n\n        let keypair = Keypair::generate();\n        let message = b\"Message a signer pour test Ed25519\";\n\n        let signature = keypair.sign(message);\n        match keypair.verify(message, \u0026signature) {\n            Ok(()) =\u003e println!(\"‚úÖ OK\"),\n            Err(_) =\u003e {\n                println!(\"‚ùå √âCHEC\");\n                return Err(anyhow::anyhow!(\"√âchec de v√©rification de signature\"));\n            }\n        }\n\n        // Test hachage BLAKE3\n        print!(\"#Ô∏è‚É£  Test hachage BLAKE3... \");\n        io::stdout().flush()?;\n\n        let data = \"Donn√©es test pour hachage BLAKE3\".as_bytes();\n        let hash1 = blake3_32(data);\n        let hash2 = blake3_32(data);\n\n        if hash1 == hash2 {\n            println!(\"‚úÖ OK ({})\", hex::encode(\u0026hash1[..8]));\n        } else {\n            println!(\"‚ùå √âCHEC\");\n            return Err(anyhow::anyhow!(\"Hashes BLAKE3 inconsistants\"));\n        }\n\n        // Test Argon2 KDF\n        print!(\"üîë Test d√©rivation Argon2id... \");\n        io::stdout().flush()?;\n\n        let password = SecretString::new(\"mot_de_passe_test\".to_string());\n        let config = Argon2Config::fast_insecure(); // Rapide pour tests CLI\n\n        let hash = hash_password(\u0026password, \u0026config).context(\"√âchec du hachage Argon2\")?;\n        let valid = verify_password(\u0026password, \u0026hash).context(\"√âchec de v√©rification Argon2\")?;\n\n        if valid {\n            println!(\"‚úÖ OK\");\n        } else {\n            println!(\"‚ùå √âCHEC\");\n            return Err(anyhow::anyhow!(\"V√©rification Argon2 √©chou√©e\"));\n        }\n\n        println!();\n        println!(\"üéâ Tous les tests cryptographiques sont pass√©s avec succ√®s !\");\n\n        Ok(())\n    }\n\n    fn handle_profile(\u0026self, action: ProfileAction) -\u003e Result\u003c()\u003e {\n        match action {\n            ProfileAction::Create { name } =\u003e self.create_profile(name),\n            ProfileAction::List =\u003e self.list_profiles_cmd(),\n            ProfileAction::Delete { name } =\u003e self.delete_profile(name),\n            ProfileAction::Show { name } =\u003e self.show_profile(name),\n        }\n    }\n\n    fn create_profile(\u0026self, name: String) -\u003e Result\u003c()\u003e {\n        println!(\"üÜï Cr√©ation du profil '{}'\", name);\n\n        // Demander le mot de passe\n        let password = prompt_password(\"Mot de passe du profil: \")?;\n        let password_confirm = prompt_password(\"Confirmer le mot de passe: \")?;\n\n        if password.expose_secret() != password_confirm.expose_secret() {\n            return Err(anyhow::anyhow!(\"Les mots de passe ne correspondent pas\"));\n        }\n\n        // Cr√©er le profil avec le syst√®me de stockage s√©curis√©\n        println!(\"üîë G√©n√©ration des cl√©s cryptographiques...\");\n        let profile_id = self.storage.create_profile(\u0026name, \u0026password)?;\n\n        println!(\"‚úÖ Profil '{}' cr√©√© avec succ√®s\", name);\n        println!(\"üÜî ID: {}\", \u0026profile_id.hash[..8]);\n\n        // Charger le profil pour afficher la cl√© publique\n        if let Ok(profile) = self.storage.load_profile(\u0026profile_id, \u0026password) {\n            println!(\n                \"üîë Cl√© publique: {}\",\n                hex::encode(profile.identity_keypair.public.to_bytes())\n            );\n            println!(\n                \"üìÖ Cr√©√© le: {}\",\n                profile.metadata.created.format(\"%Y-%m-%d %H:%M:%S UTC\")\n            );\n        }\n\n        Ok(())\n    }\n\n    fn list_profiles_cmd(\u0026self) -\u003e Result\u003c()\u003e {\n        let profiles = self.storage.list_profiles()?;\n\n        if profiles.is_empty() {\n            println!(\"üë§ Aucun profil configur√©\");\n            println!(\"üí° Utilisez 'miaou-cli profile create \u003cnom\u003e' pour cr√©er un profil\");\n            return Ok(());\n        }\n\n        println!(\"üë§ Profils Miaou ({} trouv√©s):\", profiles.len());\n        println!();\n\n        for profile in profiles {\n            println!(\"  üìã {}\", profile.name);\n            println!(\"     üÜî ID: {}\", \u0026profile.id.hash[..8]);\n            println!(\n                \"     üìÖ Cr√©√©: {}\",\n                profile.created.format(\"%Y-%m-%d %H:%M:%S UTC\")\n            );\n            println!(\n                \"     üïí Dernier acc√®s: {}\",\n                profile.last_access.format(\"%Y-%m-%d %H:%M:%S UTC\")\n            );\n            println!(\n                \"     üîë Empreinte: {}...{}\",\n                \u0026profile.public_key_fingerprint[..8],\n                \u0026profile.public_key_fingerprint[profile.public_key_fingerprint.len() - 8..]\n            );\n            println!();\n        }\n\n        Ok(())\n    }\n\n    fn show_profile(\u0026self, name: String) -\u003e Result\u003c()\u003e {\n        let profiles = self.storage.list_profiles()?;\n        let profile_info = profiles\n            .iter()\n            .find(|p| p.name == name)\n            .ok_or_else(|| anyhow::anyhow!(\"Profil '{}' non trouv√©\", name))?;\n\n        // Demander le mot de passe pour charger le profil\n        let password = prompt_password(\u0026format!(\"Mot de passe pour '{}': \", name))?;\n        let profile = self.storage.load_profile(\u0026profile_info.id, \u0026password)?;\n\n        println!(\"üë§ D√©tails du profil '{}'\", profile.metadata.name);\n        println!();\n        println!(\"üÜî ID: {}\", profile.metadata.id.hash);\n        println!(\"üìÖ Cr√©√©: {}\", profile.metadata.created);\n        println!(\"üïí Dernier acc√®s: {}\", profile.metadata.last_access);\n        println!(\"üì¶ Version: {}\", profile.metadata.version);\n        println!();\n        println!(\"üîë Cl√©s cryptographiques:\");\n        println!(\n            \"   Publique: {}\",\n            hex::encode(profile.identity_keypair.public.to_bytes())\n        );\n        println!(\n            \"   Empreinte: {}\",\n            hex::encode(blake3_32(\u0026profile.identity_keypair.public.to_bytes()))\n        );\n        println!();\n        println!(\"‚öôÔ∏è  Param√®tres:\");\n        println!(\n            \"   Accepter amis auto: {}\",\n            profile.settings.auto_accept_friends\n        );\n        println!(\n            \"   Niveau chiffrement: {}\",\n            profile.settings.encryption_level\n        );\n        println!(\"   Sauvegarde: {}\", profile.settings.backup_enabled);\n        println!(\"   Th√®me: {}\", profile.settings.theme);\n\n        Ok(())\n    }\n\n    fn delete_profile(\u0026self, name: String) -\u003e Result\u003c()\u003e {\n        let profiles = self.storage.list_profiles()?;\n        let profile_info = profiles\n            .iter()\n            .find(|p| p.name == name)\n            .ok_or_else(|| anyhow::anyhow!(\"Profil '{}' non trouv√©\", name))?;\n\n        // Confirmation\n        print!(\n            \"‚ö†Ô∏è  √ätes-vous s√ªr de vouloir supprimer le profil '{}' ? [y/N]: \",\n            name\n        );\n        io::stdout().flush()?;\n\n        let mut input = String::new();\n        io::stdin().read_line(\u0026mut input)?;\n\n        if input.trim().to_lowercase() != \"y\" {\n            println!(\"Suppression annul√©e\");\n            return Ok(());\n        }\n\n        self.storage.delete_profile(\u0026profile_info.id)?;\n        println!(\"‚úÖ Profil '{}' supprim√©\", name);\n\n        Ok(())\n    }\n\n    fn test_encryption(\u0026self, message: Option\u003cString\u003e) -\u003e Result\u003c()\u003e {\n        let message = match message {\n            Some(msg) =\u003e msg,\n            None =\u003e prompt_string(\"Message √† chiffrer: \")?,\n        };\n\n        println!(\"üîí Test de chiffrement interactif\");\n        println!(\"üìù Message: {}\", message);\n\n        // G√©n√©rer une cl√© de test\n        let key = AeadKeyRef::from_bytes([42u8; 32]);\n        let aad = b\"miaou_cli_test\";\n        let mut rng = rand_core::OsRng;\n\n        // Chiffrer\n        let encrypted = encrypt_auto_nonce(\u0026key, aad, message.as_bytes(), \u0026mut rng)?;\n        println!(\n            \"üîê Chiffr√©: {} octets (tag inclus)\",\n            encrypted.ciphertext.len()\n        );\n        println!(\"üé≤ Nonce: {}\", hex::encode(\u0026encrypted.nonce));\n\n        // D√©chiffrer\n        let decrypted = decrypt(\u0026key, aad, \u0026encrypted)?;\n        let decrypted_str = String::from_utf8(decrypted)?;\n\n        println!(\"üîì D√©chiffr√©: {}\", decrypted_str);\n\n        if decrypted_str == message {\n            println!(\"‚úÖ Test de chiffrement r√©ussi !\");\n        } else {\n            println!(\"‚ùå Erreur: les donn√©es ne correspondent pas\");\n        }\n\n        Ok(())\n    }\n\n    fn test_signing(\u0026self, message: Option\u003cString\u003e) -\u003e Result\u003c()\u003e {\n        let message = match message {\n            Some(msg) =\u003e msg,\n            None =\u003e prompt_string(\"Message √† signer: \")?,\n        };\n\n        println!(\"‚úçÔ∏è  Test de signature interactif\");\n        println!(\"üìù Message: {}\", message);\n\n        // G√©n√©rer une paire de cl√©s\n        let keypair = Keypair::generate();\n        println!(\n            \"üîë Cl√© publique: {}\",\n            hex::encode(keypair.public.to_bytes())\n        );\n\n        // Signer\n        let signature = keypair.sign(message.as_bytes());\n        println!(\"‚úçÔ∏è  Signature: {}\", hex::encode(signature.to_bytes()));\n\n        // V√©rifier\n        match keypair.verify(message.as_bytes(), \u0026signature) {\n            Ok(()) =\u003e println!(\"‚úÖ Signature valide !\"),\n            Err(e) =\u003e println!(\"‚ùå Signature invalide: {:?}\", e),\n        }\n\n        Ok(())\n    }\n\n    fn run_benchmarks(\u0026self) -\u003e Result\u003c()\u003e {\n        println!(\"‚ö° Benchmarks de performance Miaou v0.1.0\");\n        println!(\"‚è±Ô∏è  Mesures approximatives (utilisez 'cargo bench' pour des mesures pr√©cises)\");\n        println!();\n\n        use std::time::Instant;\n\n        // Benchmark BLAKE3\n        let data = vec![0u8; 1024 * 1024]; // 1 MB\n        let start = Instant::now();\n        for _ in 0..100 {\n            let _ = blake3_32(\u0026data);\n        }\n        let duration = start.elapsed();\n        let throughput = (100.0 * data.len() as f64) / duration.as_secs_f64() / (1024.0 * 1024.0);\n        println!(\"üèÉ BLAKE3 (1 MB): {:.2} MiB/s\", throughput);\n\n        // Benchmark Ed25519\n        let keypair = Keypair::generate();\n        let message = b\"benchmark message\";\n        let start = Instant::now();\n        for _ in 0..1000 {\n            let _ = keypair.sign(message);\n        }\n        let duration = start.elapsed();\n        let rate = 1000.0 / duration.as_secs_f64();\n        println!(\"‚úçÔ∏è  Ed25519 signatures: {:.0} sig/s\", rate);\n\n        // Benchmark ChaCha20-Poly1305\n        let key = AeadKeyRef::from_bytes([42u8; 32]);\n        let data = vec![0u8; 1024];\n        let aad = b\"benchmark\";\n        let mut rng = rand_core::OsRng;\n        let start = Instant::now();\n        for _ in 0..1000 {\n            let _ = encrypt_auto_nonce(\u0026key, aad, \u0026data, \u0026mut rng);\n        }\n        let duration = start.elapsed();\n        let rate = 1000.0 / duration.as_secs_f64();\n        println!(\"üîí ChaCha20-Poly1305: {:.0} ops/s\", rate);\n\n        println!();\n        println!(\"üí° Pour des benchmarks d√©taill√©s: cargo bench\");\n\n        Ok(())\n    }\n\n    fn interactive_mode(\u0026self) -\u003e Result\u003c()\u003e {\n        println!(\"üê± Miaou CLI v0.1.0 - Mode interactif\");\n        println!(\"Tapez 'help' pour voir les commandes disponibles, 'quit' pour quitter\");\n        println!();\n\n        loop {\n            print!(\"miaou\u003e \");\n            io::stdout().flush()?;\n\n            let mut input = String::new();\n            io::stdin().read_line(\u0026mut input)?;\n            let input = input.trim();\n\n            if input.is_empty() {\n                continue;\n            }\n\n            match input {\n                \"quit\" | \"exit\" | \"q\" =\u003e {\n                    println!(\"üëã Au revoir !\");\n                    break;\n                }\n                \"help\" | \"h\" =\u003e {\n                    self.show_interactive_help();\n                }\n                \"status\" =\u003e {\n                    if let Err(e) = self.show_status() {\n                        println!(\"‚ùå Erreur: {}\", e);\n                    }\n                }\n                \"crypto-test\" =\u003e {\n                    if let Err(e) = self.run_crypto_tests() {\n                        println!(\"‚ùå Erreur: {}\", e);\n                    }\n                }\n                \"profiles\" =\u003e {\n                    if let Err(e) = self.list_profiles_cmd() {\n                        println!(\"‚ùå Erreur: {}\", e);\n                    }\n                }\n                \"benchmark\" =\u003e {\n                    if let Err(e) = self.run_benchmarks() {\n                        println!(\"‚ùå Erreur: {}\", e);\n                    }\n                }\n                _ =\u003e {\n                    println!(\n                        \"‚ùì Commande inconnue: '{}'. Tapez 'help' pour l'aide.\",\n                        input\n                    );\n                }\n            }\n\n            println!();\n        }\n\n        Ok(())\n    }\n\n    fn show_interactive_help(\u0026self) {\n        println!(\"üìö Commandes disponibles:\");\n        println!(\"  status        - Afficher l'√©tat du syst√®me\");\n        println!(\"  crypto-test   - Tests des primitives cryptographiques\");\n        println!(\"  profiles      - Lister les profils\");\n        println!(\"  benchmark     - Benchmarks de performance\");\n        println!(\"  help, h       - Afficher cette aide\");\n        println!(\"  quit, exit, q - Quitter\");\n        println!();\n        println!(\"üí° Utilisez les sous-commandes pour plus d'options:\");\n        println!(\"  profile create \u003cnom\u003e  - Cr√©er un profil\");\n        println!(\"  profile show \u003cnom\u003e    - Afficher un profil\");\n        println!(\"  profile delete \u003cnom\u003e  - Supprimer un profil\");\n    }\n}\n\n// Fonctions utilitaires\n\nfn expand_path(path: PathBuf) -\u003e Result\u003cPathBuf\u003e {\n    let path_str = path.to_string_lossy();\n    if path_str.starts_with(\"~/\") {\n        if let Some(home) = home::home_dir() {\n            Ok(home.join(\u0026path_str[2..]))\n        } else {\n            Ok(path)\n        }\n    } else {\n        Ok(path)\n    }\n}\n\nfn prompt_password(prompt: \u0026str) -\u003e Result\u003cSecretString\u003e {\n    print!(\"{}\", prompt);\n    io::stdout().flush()?;\n    let password = rpassword::read_password()?;\n    Ok(SecretString::new(password))\n}\n\nfn prompt_string(prompt: \u0026str) -\u003e Result\u003cString\u003e {\n    print!(\"{}\", prompt);\n    io::stdout().flush()?;\n    let mut input = String::new();\n    io::stdin().read_line(\u0026mut input)?;\n    Ok(input.trim().to_string())\n}\n\nfn get_disk_space(path: \u0026PathBuf) -\u003e Result\u003cString\u003e {\n    // Approximation simple pour l'espace disque\n    if let Ok(metadata) = std::fs::metadata(path) {\n        if metadata.is_dir() {\n            Ok(\"Disponible\".to_string())\n        } else {\n            Ok(\"Inconnu\".to_string())\n        }\n    } else {\n        Ok(\"Inconnu\".to_string())\n    }\n}\n\nfn main() -\u003e Result\u003c()\u003e {\n    let cli = Cli::parse();\n    let miaou_cli = MiaouCli::new(cli.data_dir, cli.verbose)?;\n\n    // V√©rifier l'initialisation de Miaou\n    if let Err(e) = initialize() {\n        return Err(anyhow::anyhow!(\"√âchec de l'initialisation de Miaou: {}\", e));\n    }\n\n    match cli.command {\n        Some(command) =\u003e miaou_cli.run_command(command),\n        None =\u003e miaou_cli.interactive_mode(), // Mode interactif par d√©faut\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use tempfile::TempDir;\n\n    fn create_test_cli() -\u003e Result\u003cMiaouCli\u003e {\n        let temp_dir = TempDir::new()?;\n        MiaouCli::new(temp_dir.path().to_path_buf(), false)\n    }\n\n    #[test]\n    fn test_cli_creation() {\n        let temp_dir = TempDir::new().unwrap();\n        let cli = MiaouCli::new(temp_dir.path().to_path_buf(), false);\n        assert!(cli.is_ok());\n    }\n\n    #[test]\n    fn test_expand_path_home() {\n        let path = PathBuf::from(\"~/test\");\n        let expanded = expand_path(path).unwrap();\n        // Should not contain ~ anymore\n        assert!(!expanded.to_string_lossy().contains('~'));\n    }\n\n    #[test]\n    fn test_expand_path_absolute() {\n        let path = PathBuf::from(\"/tmp/test\");\n        let expanded = expand_path(path.clone()).unwrap();\n        assert_eq!(expanded, path);\n    }\n\n    #[test]\n    fn test_expand_path_relative() {\n        let path = PathBuf::from(\"test/path\");\n        let expanded = expand_path(path.clone()).unwrap();\n        assert_eq!(expanded, path);\n    }\n\n    #[test]\n    fn test_get_disk_space() {\n        let temp_dir = TempDir::new().unwrap();\n        let result = get_disk_space(\u0026temp_dir.path().to_path_buf()).unwrap();\n        assert_eq!(result, \"Disponible\");\n    }\n\n    #[test]\n    fn test_get_disk_space_nonexistent() {\n        let path = PathBuf::from(\"/nonexistent/path\");\n        let result = get_disk_space(\u0026path).unwrap();\n        assert_eq!(result, \"Inconnu\");\n    }\n\n    #[test]\n    fn test_show_status() {\n        let cli = create_test_cli().unwrap();\n        // This test just verifies the function doesn't panic\n        // Real output testing would require capturing stdout\n        let result = cli.show_status();\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_run_crypto_tests() {\n        let cli = create_test_cli().unwrap();\n        let result = cli.run_crypto_tests();\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_profile_creation_flow() {\n        let cli = create_test_cli().unwrap();\n        \n        // Test listing empty profiles\n        let result = cli.list_profiles_cmd();\n        assert!(result.is_ok());\n        \n        // Test show non-existent profile\n        let result = cli.show_profile(\"nonexistent\".to_string());\n        assert!(result.is_err());\n        \n        // Test delete non-existent profile  \n        let result = cli.delete_profile(\"nonexistent\".to_string());\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_test_encryption() {\n        let cli = create_test_cli().unwrap();\n        let message = Some(\"Test message for encryption\".to_string());\n        let result = cli.test_encryption(message);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_test_signing() {\n        let cli = create_test_cli().unwrap();\n        let message = Some(\"Test message for signing\".to_string());\n        let result = cli.test_signing(message);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_run_benchmarks() {\n        let cli = create_test_cli().unwrap();\n        let result = cli.run_benchmarks();\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_commands_enum_creation() {\n        // Test that Commands enum variants can be created\n        let _status = Commands::Status;\n        let _crypto_test = Commands::CryptoTest;\n        let _interactive = Commands::Interactive;\n        let _benchmark = Commands::Benchmark;\n        \n        let _profile = Commands::Profile {\n            action: ProfileAction::List,\n        };\n        \n        let _test_encrypt = Commands::TestEncrypt {\n            message: Some(\"test\".to_string()),\n        };\n        \n        let _test_sign = Commands::TestSign {\n            message: Some(\"test\".to_string()),\n        };\n    }\n\n    #[test]\n    fn test_profile_action_enum_creation() {\n        // Test ProfileAction enum variants\n        let _create = ProfileAction::Create {\n            name: \"test\".to_string(),\n        };\n        let _list = ProfileAction::List;\n        let _delete = ProfileAction::Delete {\n            name: \"test\".to_string(),\n        };\n        let _show = ProfileAction::Show {\n            name: \"test\".to_string(),\n        };\n    }\n\n    #[test]\n    fn test_run_command_status() {\n        let cli = create_test_cli().unwrap();\n        let result = cli.run_command(Commands::Status);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_run_command_crypto_test() {\n        let cli = create_test_cli().unwrap();\n        let result = cli.run_command(Commands::CryptoTest);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_run_command_benchmark() {\n        let cli = create_test_cli().unwrap();\n        let result = cli.run_command(Commands::Benchmark);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_run_command_test_encrypt() {\n        let cli = create_test_cli().unwrap();\n        let result = cli.run_command(Commands::TestEncrypt {\n            message: Some(\"test message\".to_string()),\n        });\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_run_command_test_sign() {\n        let cli = create_test_cli().unwrap();\n        let result = cli.run_command(Commands::TestSign {\n            message: Some(\"test message\".to_string()),\n        });\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_run_command_profile_list() {\n        let cli = create_test_cli().unwrap();\n        let result = cli.run_command(Commands::Profile {\n            action: ProfileAction::List,\n        });\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_run_command_profile_show_nonexistent() {\n        let cli = create_test_cli().unwrap();\n        let result = cli.run_command(Commands::Profile {\n            action: ProfileAction::Show {\n                name: \"nonexistent\".to_string(),\n            },\n        });\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_run_command_profile_delete_nonexistent() {\n        let cli = create_test_cli().unwrap();\n        let result = cli.run_command(Commands::Profile {\n            action: ProfileAction::Delete {\n                name: \"nonexistent\".to_string(),\n            },\n        });\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_cli_parser_default_values() {\n        // Test that CLI struct can be constructed with default values\n        use clap::Parser;\n        \n        // Simulate command line args\n        let args = vec![\"miaou-cli\", \"status\"];\n        let cli = Cli::try_parse_from(args);\n        assert!(cli.is_ok());\n        \n        let cli = cli.unwrap();\n        assert_eq!(cli.data_dir, PathBuf::from(\"~/.miaou\"));\n        assert!(!cli.verbose);\n        assert!(matches!(cli.command, Some(Commands::Status)));\n    }\n\n    #[test]\n    fn test_cli_parser_verbose_flag() {\n        use clap::Parser;\n        \n        let args = vec![\"miaou-cli\", \"--verbose\", \"status\"];\n        let cli = Cli::try_parse_from(args);\n        assert!(cli.is_ok());\n        \n        let cli = cli.unwrap();\n        assert!(cli.verbose);\n    }\n\n    #[test]\n    fn test_cli_parser_custom_data_dir() {\n        use clap::Parser;\n        \n        let args = vec![\"miaou-cli\", \"--data-dir\", \"/tmp/custom\", \"status\"];\n        let cli = Cli::try_parse_from(args);\n        assert!(cli.is_ok());\n        \n        let cli = cli.unwrap();\n        assert_eq!(cli.data_dir, PathBuf::from(\"/tmp/custom\"));\n    }\n\n    #[test]\n    fn test_cli_parser_profile_commands() {\n        use clap::Parser;\n        \n        let test_cases = vec![\n            (vec![\"miaou-cli\", \"profile\", \"list\"], ProfileAction::List),\n            (vec![\"miaou-cli\", \"profile\", \"create\", \"alice\"], ProfileAction::Create { name: \"alice\".to_string() }),\n            (vec![\"miaou-cli\", \"profile\", \"show\", \"bob\"], ProfileAction::Show { name: \"bob\".to_string() }),\n            (vec![\"miaou-cli\", \"profile\", \"delete\", \"charlie\"], ProfileAction::Delete { name: \"charlie\".to_string() }),\n        ];\n        \n        for (args, expected_action) in test_cases {\n            let cli = Cli::try_parse_from(args).unwrap();\n            if let Some(Commands::Profile { action }) = cli.command {\n                match (action, expected_action) {\n                    (ProfileAction::List, ProfileAction::List) =\u003e {},\n                    (ProfileAction::Create { name: a }, ProfileAction::Create { name: b }) =\u003e assert_eq!(a, b),\n                    (ProfileAction::Show { name: a }, ProfileAction::Show { name: b }) =\u003e assert_eq!(a, b),\n                    (ProfileAction::Delete { name: a }, ProfileAction::Delete { name: b }) =\u003e assert_eq!(a, b),\n                    _ =\u003e panic!(\"Action mismatch\"),\n                }\n            } else {\n                panic!(\"Expected Profile command\");\n            }\n        }\n    }\n\n    #[test]\n    fn test_cli_parser_test_commands() {\n        use clap::Parser;\n        \n        // Test encrypt without message\n        let args = vec![\"miaou-cli\", \"test-encrypt\"];\n        let cli = Cli::try_parse_from(args).unwrap();\n        if let Some(Commands::TestEncrypt { message }) = cli.command {\n            assert!(message.is_none());\n        } else {\n            panic!(\"Expected TestEncrypt command\");\n        }\n        \n        // Test encrypt with message\n        let args = vec![\"miaou-cli\", \"test-encrypt\", \"--message\", \"hello\"];\n        let cli = Cli::try_parse_from(args).unwrap();\n        if let Some(Commands::TestEncrypt { message }) = cli.command {\n            assert_eq!(message, Some(\"hello\".to_string()));\n        } else {\n            panic!(\"Expected TestEncrypt command\");\n        }\n        \n        // Test sign with message\n        let args = vec![\"miaou-cli\", \"test-sign\", \"-m\", \"test\"];\n        let cli = Cli::try_parse_from(args).unwrap();\n        if let Some(Commands::TestSign { message }) = cli.command {\n            assert_eq!(message, Some(\"test\".to_string()));\n        } else {\n            panic!(\"Expected TestSign command\");\n        }\n    }\n\n    #[test]\n    fn test_directory_creation_in_new() {\n        let temp_dir = TempDir::new().unwrap();\n        let custom_path = temp_dir.path().join(\"custom_miaou\");\n        \n        // Directory doesn't exist yet\n        assert!(!custom_path.exists());\n        \n        // Creating MiaouCli should create the directory\n        let _cli = MiaouCli::new(custom_path.clone(), false).unwrap();\n        \n        // Directory should now exist\n        assert!(custom_path.exists());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","seb","Dev","miaou","miaou-core","src","lib.rs"],"content":"//! # Miaou Core v0.1.0\n//!\n//! Fonctionnalit√©s principales et abstractions pour la plateforme Miaou.\n//!\n//! Ce crate contient la logique m√©tier centrale, la gestion des profils\n//! et les abstractions communes utilis√©es par tous les autres composants.\n\n#![warn(missing_docs)]\n#![warn(rustdoc::broken_intra_doc_links)]\n\n// Re-export crypto primitives\npub use miaou_crypto as crypto;\n\n/// Module mobile pour les abstractions sp√©cifiques aux plateformes mobiles\npub mod mobile;\n\n/// Module de stockage s√©curis√© pour la gestion des profils utilisateur\npub mod storage;\n\n// Re-exports publics\npub use storage::{ProfileHandle, ProfileId, SecureStorage};\n\n/// Version actuelle de Miaou\npub const VERSION: \u0026str = env!(\"CARGO_PKG_VERSION\");\n\n/// Nom de la version actuelle\npub const VERSION_NAME: \u0026str = \"Premi√®re Griffe\";\n\n/// Phase de d√©veloppement actuelle\npub const DEVELOPMENT_PHASE: u8 = 1;\n\n/// Interface commune pour toutes les plateformes\npub trait PlatformInterface {\n    /// Initialise la plateforme\n    ///\n    /// # Errors\n    /// √âchec si l'initialisation de la plateforme √©choue.\n    fn initialize(\u0026mut self) -\u003e Result\u003c(), String\u003e;\n\n    /// Retourne le nom de la plateforme\n    fn get_platform_name(\u0026self) -\u003e \u0026'static str;\n\n    /// Retourne la version support√©e\n    fn get_supported_version(\u0026self) -\u003e \u0026'static str {\n        VERSION\n    }\n}\n\n/// Informations sur la version et compilation\n#[must_use]\npub fn version_info() -\u003e String {\n    format!(\"Miaou v{VERSION} \\\"{VERSION_NAME}\\\" (Phase {DEVELOPMENT_PHASE})\")\n}\n\n/// Fonction principale d'initialisation de Miaou\n///\n/// # Errors\n/// √âchec si la v√©rification des d√©pendances cryptographiques √©choue.\npub fn initialize() -\u003e Result\u003c(), String\u003e {\n    // V√©rification des d√©pendances cryptographiques\n    crypto::test_crypto_availability()?;\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_version_info() {\n        let info = version_info();\n        assert!(info.contains(\"Miaou\"));\n        assert!(info.contains(\"Premi√®re Griffe\"));\n        assert!(info.contains(\"Phase 1\"));\n    }\n\n    #[test]\n    fn test_initialize() {\n        assert!(initialize().is_ok());\n    }\n\n    #[test]\n    fn test_constants() {\n        assert_eq!(VERSION_NAME, \"Premi√®re Griffe\");\n        assert_eq!(DEVELOPMENT_PHASE, 1);\n        #[allow(clippy::const_is_empty)]\n        {\n            assert!(!VERSION.is_empty());\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","seb","Dev","miaou","miaou-core","src","storage.rs"],"content":"// Module de stockage s√©curis√© pour Miaou v0.1.0\n// Gestion des profils utilisateur avec chiffrement des donn√©es sensibles\n\nuse crate::crypto::{\n    aead::{decrypt, encrypt_auto_nonce, AeadKeyRef},\n    hash::blake3_32,\n    kdf::{derive_key_32, generate_salt, hash_password, verify_password, Argon2Config},\n    sign::Keypair,\n    CryptoError,\n};\nuse anyhow::Result;\nuse chrono::{DateTime, Utc};\nuse secrecy::{SecretString, Zeroize};\nuse serde::{Deserialize, Deserializer, Serialize, Serializer};\nuse std::fs;\nuse std::path::{Path, PathBuf};\n\n/// Erreurs de stockage\n#[derive(Debug, thiserror::Error)]\npub enum StorageError {\n    /// Erreur d'entr√©e/sortie syst√®me\n    #[error(\"Erreur d'E/S: {0}\")]\n    Io(#[from] std::io::Error),\n\n    /// Erreur de s√©rialisation JSON\n    #[error(\"Erreur de s√©rialisation: {0}\")]\n    Serialization(#[from] serde_json::Error),\n\n    /// Erreur cryptographique\n    #[error(\"Erreur cryptographique: {0}\")]\n    Crypto(#[from] CryptoError),\n\n    /// Profil introuvable\n    #[error(\"Profil non trouv√©: {0}\")]\n    ProfileNotFound(String),\n\n    /// Tentative de cr√©ation d'un profil existant\n    #[error(\"Profil d√©j√† existant: {0}\")]\n    ProfileAlreadyExists(String),\n\n    /// Mot de passe incorrect\n    #[error(\"Mot de passe invalide\")]\n    InvalidPassword,\n\n    /// Donn√©es de profil corrompues\n    #[error(\"Donn√©es corrompues ou version incompatible\")]\n    CorruptedData,\n}\n\n/// Gestionnaire de stockage s√©curis√©\npub struct SecureStorage {\n    /// R√©pertoire racine de stockage\n    storage_root: PathBuf,\n}\n\nimpl SecureStorage {\n    /// Cr√©e une nouvelle instance de stockage\n    ///\n    /// # Errors\n    /// √âchec si les r√©pertoires ne peuvent pas √™tre cr√©√©s ou acc√©d√©s.\n    pub fn new\u003cP: AsRef\u003cPath\u003e\u003e(storage_root: P) -\u003e Result\u003cSelf\u003e {\n        let storage_root = storage_root.as_ref().to_path_buf();\n\n        // Cr√©er les r√©pertoires n√©cessaires\n        fs::create_dir_all(\u0026storage_root)?;\n        fs::create_dir_all(storage_root.join(\"profiles\"))?;\n        fs::create_dir_all(storage_root.join(\"keystore\"))?;\n\n        Ok(Self { storage_root })\n    }\n\n    /// Cr√©e un nouveau profil utilisateur\n    ///\n    /// # Errors\n    /// √âchec si le profil existe d√©j√† ou si les op√©rations cryptographiques √©chouent.\n    pub fn create_profile(\u0026self, name: \u0026str, password: \u0026SecretString) -\u003e Result\u003cProfileId\u003e {\n        let profile_id = ProfileId::new(name);\n        let profile_path = self.get_profile_path(\u0026profile_id);\n\n        // V√©rifier que le profil n'existe pas\n        if profile_path.exists() {\n            return Err(StorageError::ProfileAlreadyExists(name.to_string()).into());\n        }\n\n        // G√©n√©rer les cl√©s cryptographiques\n        let identity_keypair = Keypair::generate();\n        let mut rng = rand_core::OsRng;\n        let _storage_key = AeadKeyRef::generate(\u0026mut rng);\n\n        // Cr√©er le hash du mot de passe pour l'authentification\n        let config = Argon2Config::balanced();\n        let password_hash = hash_password(password, \u0026config)?;\n\n        // D√©river une cl√© de chiffrement depuis le mot de passe\n        let salt = generate_salt();\n        let encryption_key_bytes = derive_key_32(password, \u0026salt, \u0026config)?;\n        let encryption_key = AeadKeyRef::from_bytes(encryption_key_bytes);\n\n        // Chiffrer les donn√©es sensibles (cl√©s priv√©es)\n        let identity_private_bytes = identity_keypair.secret.to_bytes();\n        let encrypted_identity = encrypt_auto_nonce(\n            \u0026encryption_key,\n            b\"miaou_identity_v0.1.0\",\n            \u0026identity_private_bytes,\n            \u0026mut rng,\n        )?;\n\n        // Cr√©er la structure du profil\n        let profile = ProfileData {\n            metadata: ProfileMetadata {\n                id: profile_id.clone(),\n                name: name.to_string(),\n                version: \"0.1.0\".to_string(),\n                created: Utc::now(),\n                last_access: Utc::now(),\n            },\n            auth: AuthenticationData {\n                password_hash,\n                salt: salt.to_string(),\n                config_type: \"balanced\".to_string(),\n            },\n            keys: KeyData {\n                public_identity: identity_keypair.public.to_bytes(),\n                encrypted_private_identity: encrypted_identity,\n                key_fingerprint: blake3_32(\u0026identity_keypair.public.to_bytes()),\n            },\n            settings: ProfileSettings::default(),\n        };\n\n        // Sauvegarder le profil\n        let profile_json = serde_json::to_string_pretty(\u0026profile)?;\n        fs::write(\u0026profile_path, profile_json)?;\n\n        // Nettoyer les donn√©es sensibles\n        let mut identity_private_bytes = identity_private_bytes;\n        identity_private_bytes.zeroize();\n        let mut encryption_key_bytes = encryption_key_bytes;\n        encryption_key_bytes.zeroize();\n\n        Ok(profile_id)\n    }\n\n    /// Charge un profil utilisateur avec authentification\n    ///\n    /// # Errors\n    /// √âchec si le profil n'existe pas, si le mot de passe est incorrect, ou si les donn√©es sont corrompues.\n    pub fn load_profile(\n        \u0026self,\n        profile_id: \u0026ProfileId,\n        password: \u0026SecretString,\n    ) -\u003e Result\u003cProfileHandle\u003e {\n        let profile_path = self.get_profile_path(profile_id);\n\n        if !profile_path.exists() {\n            return Err(StorageError::ProfileNotFound(profile_id.name.clone()).into());\n        }\n\n        // Charger les donn√©es du profil\n        let profile_data = fs::read_to_string(\u0026profile_path)?;\n        let profile: ProfileData = serde_json::from_str(\u0026profile_data)?;\n\n        // V√©rifier le mot de passe\n        if !verify_password(password, \u0026profile.auth.password_hash)? {\n            return Err(StorageError::InvalidPassword.into());\n        }\n\n        // D√©river la cl√© de d√©chiffrement\n        let salt = argon2::password_hash::SaltString::from_b64(\u0026profile.auth.salt)\n            .map_err(|_| StorageError::CorruptedData)?;\n        let config = match profile.auth.config_type.as_str() {\n            \"balanced\" =\u003e Argon2Config::balanced(),\n            \"secure\" =\u003e Argon2Config::secure(),\n            \"fast_insecure\" =\u003e Argon2Config::fast_insecure(),\n            _ =\u003e return Err(StorageError::CorruptedData.into()),\n        };\n\n        let encryption_key_bytes = derive_key_32(password, \u0026salt, \u0026config)?;\n        let encryption_key = AeadKeyRef::from_bytes(encryption_key_bytes);\n\n        // D√©chiffrer la cl√© priv√©e d'identit√©\n        let identity_private_bytes = decrypt(\n            \u0026encryption_key,\n            b\"miaou_identity_v0.1.0\",\n            \u0026profile.keys.encrypted_private_identity,\n        )?;\n\n        // Reconstruire la paire de cl√©s\n        if identity_private_bytes.len() != 32 {\n            return Err(StorageError::CorruptedData.into());\n        }\n        let mut private_key_array = [0u8; 32];\n        private_key_array.copy_from_slice(\u0026identity_private_bytes);\n        let identity_keypair = Keypair::from_private_bytes(private_key_array)?;\n\n        // V√©rifier l'int√©grit√© de la cl√© publique\n        if identity_keypair.public.to_bytes() != profile.keys.public_identity {\n            return Err(StorageError::CorruptedData.into());\n        }\n\n        // Mettre √† jour l'horodatage d'acc√®s\n        self.update_last_access(profile_id)?;\n\n        Ok(ProfileHandle {\n            metadata: profile.metadata,\n            identity_keypair,\n            settings: profile.settings,\n        })\n    }\n\n    /// Liste tous les profils disponibles\n    ///\n    /// # Errors\n    /// √âchec si le r√©pertoire de profils ne peut pas √™tre lu.\n    pub fn list_profiles(\u0026self) -\u003e Result\u003cVec\u003cProfileInfo\u003e\u003e {\n        let profiles_dir = self.storage_root.join(\"profiles\");\n        let mut profiles = Vec::new();\n\n        if !profiles_dir.exists() {\n            return Ok(profiles);\n        }\n\n        for entry in fs::read_dir(\u0026profiles_dir)? {\n            let entry = entry?;\n            let path = entry.path();\n\n            if path.extension().and_then(|s| s.to_str()) == Some(\"json\") {\n                if let Ok(data) = fs::read_to_string(\u0026path) {\n                    if let Ok(profile) = serde_json::from_str::\u003cProfileData\u003e(\u0026data) {\n                        profiles.push(ProfileInfo {\n                            id: profile.metadata.id,\n                            name: profile.metadata.name,\n                            created: profile.metadata.created,\n                            last_access: profile.metadata.last_access,\n                            public_key_fingerprint: hex::encode(profile.keys.key_fingerprint),\n                        });\n                    }\n                }\n            }\n        }\n\n        // Trier par date de derni√®re utilisation\n        profiles.sort_by(|a, b| b.last_access.cmp(\u0026a.last_access));\n\n        Ok(profiles)\n    }\n\n    /// Supprime un profil\n    ///\n    /// # Errors\n    /// √âchec si le profil n'existe pas ou si la suppression √©choue.\n    pub fn delete_profile(\u0026self, profile_id: \u0026ProfileId) -\u003e Result\u003c()\u003e {\n        let profile_path = self.get_profile_path(profile_id);\n\n        if !profile_path.exists() {\n            return Err(StorageError::ProfileNotFound(profile_id.name.clone()).into());\n        }\n\n        fs::remove_file(\u0026profile_path)?;\n\n        // TODO: Supprimer aussi les donn√©es associ√©es (keystore, messages, etc.)\n\n        Ok(())\n    }\n\n    /// Met √† jour l'horodatage de derni√®re utilisation\n    fn update_last_access(\u0026self, profile_id: \u0026ProfileId) -\u003e Result\u003c()\u003e {\n        let profile_path = self.get_profile_path(profile_id);\n\n        if let Ok(data) = fs::read_to_string(\u0026profile_path) {\n            if let Ok(mut profile) = serde_json::from_str::\u003cProfileData\u003e(\u0026data) {\n                profile.metadata.last_access = Utc::now();\n                let updated_data = serde_json::to_string_pretty(\u0026profile)?;\n                fs::write(\u0026profile_path, updated_data)?;\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Retourne le chemin du fichier de profil\n    fn get_profile_path(\u0026self, profile_id: \u0026ProfileId) -\u003e PathBuf {\n        self.storage_root\n            .join(\"profiles\")\n            .join(format!(\"{}.json\", profile_id.safe_name()))\n    }\n}\n\n/// Identifiant unique d'un profil\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct ProfileId {\n    /// Nom du profil choisi par l'utilisateur\n    pub name: String,\n    /// Hash du nom pour √©viter les collisions et cr√©er un nom de fichier s√ªr\n    pub hash: String,\n}\n\nimpl ProfileId {\n    /// Cr√©e un nouvel identifiant de profil\n    #[must_use]\n    pub fn new(name: \u0026str) -\u003e Self {\n        let hash = hex::encode(blake3_32(name.as_bytes()));\n        Self {\n            name: name.to_string(),\n            hash,\n        }\n    }\n\n    /// Retourne un nom de fichier s√©curis√© pour ce profil\n    #[must_use]\n    pub fn safe_name(\u0026self) -\u003e String {\n        format!(\"{}_{}\", sanitize_filename(\u0026self.name), \u0026self.hash[..8])\n    }\n}\n\n/// Informations publiques sur un profil\n#[derive(Debug, Clone)]\npub struct ProfileInfo {\n    /// Identifiant unique du profil\n    pub id: ProfileId,\n    /// Nom du profil\n    pub name: String,\n    /// Date de cr√©ation\n    pub created: DateTime\u003cUtc\u003e,\n    /// Dernier acc√®s\n    pub last_access: DateTime\u003cUtc\u003e,\n    /// Empreinte de la cl√© publique (hex)\n    pub public_key_fingerprint: String,\n}\n\n/// Handle vers un profil charg√© en m√©moire\npub struct ProfileHandle {\n    /// M√©tadonn√©es du profil\n    pub metadata: ProfileMetadata,\n    /// Paire de cl√©s d'identit√© (d√©chiffr√©e)\n    pub identity_keypair: Keypair,\n    /// Param√®tres utilisateur\n    pub settings: ProfileSettings,\n}\n\n/// M√©tadonn√©es d'un profil\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ProfileMetadata {\n    /// Identifiant unique\n    pub id: ProfileId,\n    /// Nom du profil\n    pub name: String,\n    /// Version de Miaou utilis√©e pour cr√©er le profil\n    pub version: String,\n    /// Date de cr√©ation\n    pub created: DateTime\u003cUtc\u003e,\n    /// Dernier acc√®s\n    pub last_access: DateTime\u003cUtc\u003e,\n}\n\n/// Donn√©es d'authentification\n#[derive(Debug, Serialize, Deserialize)]\npub struct AuthenticationData {\n    /// Hash Argon2 du mot de passe\n    pub password_hash: String,\n    /// Sel utilis√© pour la d√©rivation de cl√©\n    pub salt: String,\n    /// Configuration Argon2 utilis√©e (balanced, secure, `fast_insecure`)\n    pub config_type: String,\n}\n\n/// Donn√©es cryptographiques\n#[derive(Debug)]\npub struct KeyData {\n    /// Cl√© publique d'identit√© Ed25519 (32 bytes)\n    pub public_identity: [u8; 32],\n    /// Cl√© priv√©e chiffr√©e avec le mot de passe utilisateur\n    pub encrypted_private_identity: crate::crypto::aead::SealedData,\n    /// Empreinte BLAKE3 de la cl√© publique\n    pub key_fingerprint: [u8; 32],\n}\n\n// S√©rialisation custom pour KeyData\nimpl Serialize for KeyData {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e std::result::Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        use serde::ser::SerializeStruct;\n        let mut state = serializer.serialize_struct(\"KeyData\", 3)?;\n        state.serialize_field(\"public_identity\", \u0026hex::encode(self.public_identity))?;\n        state.serialize_field(\n            \"encrypted_private_nonce\",\n            \u0026hex::encode(self.encrypted_private_identity.nonce),\n        )?;\n        state.serialize_field(\n            \"encrypted_private_ciphertext\",\n            \u0026hex::encode(\u0026self.encrypted_private_identity.ciphertext),\n        )?;\n        state.serialize_field(\"key_fingerprint\", \u0026hex::encode(self.key_fingerprint))?;\n        state.end()\n    }\n}\n\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for KeyData {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e std::result::Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        use serde::de::{self, MapAccess, Visitor};\n        use std::fmt;\n\n        #[derive(Deserialize)]\n        #[serde(field_identifier, rename_all = \"snake_case\")]\n        enum Field {\n            PublicIdentity,\n            EncryptedPrivateNonce,\n            EncryptedPrivateCiphertext,\n            KeyFingerprint,\n        }\n\n        struct KeyDataVisitor;\n\n        impl\u003c'de\u003e Visitor\u003c'de\u003e for KeyDataVisitor {\n            type Value = KeyData;\n\n            fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                formatter.write_str(\"struct KeyData\")\n            }\n\n            fn visit_map\u003cV\u003e(self, mut map: V) -\u003e std::result::Result\u003cKeyData, V::Error\u003e\n            where\n                V: MapAccess\u003c'de\u003e,\n            {\n                let mut public_identity: Option\u003cString\u003e = None;\n                let mut encrypted_private_nonce: Option\u003cString\u003e = None;\n                let mut encrypted_private_ciphertext: Option\u003cString\u003e = None;\n                let mut key_fingerprint: Option\u003cString\u003e = None;\n\n                while let Some(key) = map.next_key()? {\n                    match key {\n                        Field::PublicIdentity =\u003e {\n                            if public_identity.is_some() {\n                                return Err(de::Error::duplicate_field(\"public_identity\"));\n                            }\n                            public_identity = Some(map.next_value()?);\n                        }\n                        Field::EncryptedPrivateNonce =\u003e {\n                            if encrypted_private_nonce.is_some() {\n                                return Err(de::Error::duplicate_field(\"encrypted_private_nonce\"));\n                            }\n                            encrypted_private_nonce = Some(map.next_value()?);\n                        }\n                        Field::EncryptedPrivateCiphertext =\u003e {\n                            if encrypted_private_ciphertext.is_some() {\n                                return Err(de::Error::duplicate_field(\n                                    \"encrypted_private_ciphertext\",\n                                ));\n                            }\n                            encrypted_private_ciphertext = Some(map.next_value()?);\n                        }\n                        Field::KeyFingerprint =\u003e {\n                            if key_fingerprint.is_some() {\n                                return Err(de::Error::duplicate_field(\"key_fingerprint\"));\n                            }\n                            key_fingerprint = Some(map.next_value()?);\n                        }\n                    }\n                }\n\n                let public_identity =\n                    public_identity.ok_or_else(|| de::Error::missing_field(\"public_identity\"))?;\n                let encrypted_private_nonce = encrypted_private_nonce\n                    .ok_or_else(|| de::Error::missing_field(\"encrypted_private_nonce\"))?;\n                let encrypted_private_ciphertext = encrypted_private_ciphertext\n                    .ok_or_else(|| de::Error::missing_field(\"encrypted_private_ciphertext\"))?;\n                let key_fingerprint =\n                    key_fingerprint.ok_or_else(|| de::Error::missing_field(\"key_fingerprint\"))?;\n\n                // D√©coder hex\n                let public_bytes = hex::decode(\u0026public_identity).map_err(de::Error::custom)?;\n                let nonce_bytes =\n                    hex::decode(\u0026encrypted_private_nonce).map_err(de::Error::custom)?;\n                let ciphertext_bytes =\n                    hex::decode(\u0026encrypted_private_ciphertext).map_err(de::Error::custom)?;\n                let fingerprint_bytes = hex::decode(\u0026key_fingerprint).map_err(de::Error::custom)?;\n\n                if public_bytes.len() != 32 {\n                    return Err(de::Error::custom(\"Invalid public key length\"));\n                }\n                if nonce_bytes.len() != 12 {\n                    return Err(de::Error::custom(\"Invalid nonce length\"));\n                }\n                if fingerprint_bytes.len() != 32 {\n                    return Err(de::Error::custom(\"Invalid fingerprint length\"));\n                }\n\n                let mut public_identity = [0u8; 32];\n                public_identity.copy_from_slice(\u0026public_bytes);\n\n                let mut nonce = [0u8; 12];\n                nonce.copy_from_slice(\u0026nonce_bytes);\n\n                let mut key_fingerprint = [0u8; 32];\n                key_fingerprint.copy_from_slice(\u0026fingerprint_bytes);\n\n                Ok(KeyData {\n                    public_identity,\n                    encrypted_private_identity: crate::crypto::aead::SealedData::new(\n                        nonce,\n                        ciphertext_bytes,\n                    ),\n                    key_fingerprint,\n                })\n            }\n        }\n\n        const FIELDS: \u0026[\u0026str] = \u0026[\n            \"public_identity\",\n            \"encrypted_private_nonce\",\n            \"encrypted_private_ciphertext\",\n            \"key_fingerprint\",\n        ];\n        deserializer.deserialize_struct(\"KeyData\", FIELDS, KeyDataVisitor)\n    }\n}\n\n/// Param√®tres utilisateur\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ProfileSettings {\n    /// Accepter automatiquement les demandes d'ami\n    pub auto_accept_friends: bool,\n    /// Niveau de chiffrement (balanced, secure, fast)\n    pub encryption_level: String,\n    /// Sauvegarde automatique activ√©e\n    pub backup_enabled: bool,\n    /// Th√®me de l'interface (dark, light)\n    pub theme: String,\n}\n\nimpl Default for ProfileSettings {\n    fn default() -\u003e Self {\n        Self {\n            auto_accept_friends: false,\n            encryption_level: \"balanced\".to_string(),\n            backup_enabled: true,\n            theme: \"auto\".to_string(),\n        }\n    }\n}\n\n/// Structure compl√®te d'un profil stock√©\n#[derive(Debug, Serialize, Deserialize)]\nstruct ProfileData {\n    metadata: ProfileMetadata,\n    auth: AuthenticationData,\n    keys: KeyData,\n    settings: ProfileSettings,\n}\n\n/// Nettoie un nom de fichier pour qu'il soit safe sur tous les syst√®mes\nfn sanitize_filename(name: \u0026str) -\u003e String {\n    name.chars()\n        .map(|c| match c {\n            'a'..='z' | 'A'..='Z' | '0'..='9' | '-' | '_' =\u003e c,\n            _ =\u003e '_',\n        })\n        .collect::\u003cString\u003e()\n        .chars()\n        .take(32) // Limiter la longueur\n        .collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use tempfile::TempDir;\n\n    #[test]\n    fn test_profile_creation_and_loading() {\n        let temp_dir = TempDir::new().unwrap();\n        let storage = SecureStorage::new(temp_dir.path()).unwrap();\n\n        let password = SecretString::new(\"test_password_123\".to_string());\n\n        // Cr√©er un profil\n        let profile_id = storage.create_profile(\"alice\", \u0026password).unwrap();\n        assert_eq!(profile_id.name, \"alice\");\n\n        // Charger le profil\n        let profile = storage.load_profile(\u0026profile_id, \u0026password).unwrap();\n        assert_eq!(profile.metadata.name, \"alice\");\n\n        // Mauvais mot de passe\n        let wrong_password = SecretString::new(\"wrong_password\".to_string());\n        assert!(storage.load_profile(\u0026profile_id, \u0026wrong_password).is_err());\n    }\n\n    #[test]\n    fn test_profile_listing() {\n        let temp_dir = TempDir::new().unwrap();\n        let storage = SecureStorage::new(temp_dir.path()).unwrap();\n\n        let password = SecretString::new(\"test_password_123\".to_string());\n\n        // Cr√©er plusieurs profils\n        storage.create_profile(\"alice\", \u0026password).unwrap();\n        storage.create_profile(\"bob\", \u0026password).unwrap();\n\n        // Lister les profils\n        let profiles = storage.list_profiles().unwrap();\n        assert_eq!(profiles.len(), 2);\n\n        let names: Vec\u003c_\u003e = profiles.iter().map(|p| \u0026p.name).collect();\n        assert!(names.contains(\u0026\u0026\"alice\".to_string()));\n        assert!(names.contains(\u0026\u0026\"bob\".to_string()));\n    }\n\n    #[test]\n    fn test_profile_deletion() {\n        let temp_dir = TempDir::new().unwrap();\n        let storage = SecureStorage::new(temp_dir.path()).unwrap();\n\n        let password = SecretString::new(\"test_password_123\".to_string());\n\n        // Cr√©er un profil\n        let profile_id = storage.create_profile(\"test_user\", \u0026password).unwrap();\n\n        // V√©rifier qu'il existe\n        assert!(storage.load_profile(\u0026profile_id, \u0026password).is_ok());\n\n        // Le supprimer\n        storage.delete_profile(\u0026profile_id).unwrap();\n\n        // V√©rifier qu'il n'existe plus\n        assert!(storage.load_profile(\u0026profile_id, \u0026password).is_err());\n    }\n\n    #[test]\n    fn test_profile_id_generation() {\n        let id1 = ProfileId::new(\"alice\");\n        let id2 = ProfileId::new(\"alice\");\n        let id3 = ProfileId::new(\"bob\");\n\n        // Same name should produce same ID\n        assert_eq!(id1.name, id2.name);\n        assert_eq!(id1.hash, id2.hash);\n\n        // Different names should produce different IDs  \n        assert_ne!(id1.hash, id3.hash);\n        assert_eq!(id1.name, \"alice\");\n        assert_eq!(id3.name, \"bob\");\n    }\n\n    #[test]\n    fn test_profile_id_safe_name() {\n        let id1 = ProfileId::new(\"alice\");\n        let id2 = ProfileId::new(\"bob@domain.com\");\n        let id3 = ProfileId::new(\"user with spaces\");\n\n        let safe1 = id1.safe_name();\n        let safe2 = id2.safe_name();  \n        let safe3 = id3.safe_name();\n\n        // All safe names should be filesystem safe\n        assert!(safe1.chars().all(|c| c.is_ascii_alphanumeric() || c == '_'));\n        assert!(safe2.chars().all(|c| c.is_ascii_alphanumeric() || c == '_'));\n        assert!(safe3.chars().all(|c| c.is_ascii_alphanumeric() || c == '_'));\n\n        // Should contain hash suffix\n        assert!(safe1.contains(\u0026id1.hash[..8]));\n        assert!(safe2.contains(\u0026id2.hash[..8]));\n        assert!(safe3.contains(\u0026id3.hash[..8]));\n    }\n\n    #[test]\n    fn test_sanitize_filename() {\n        assert_eq!(sanitize_filename(\"normal\"), \"normal\");\n        assert_eq!(sanitize_filename(\"user@domain.com\"), \"user_domain_com\");\n        assert_eq!(sanitize_filename(\"user with spaces\"), \"user_with_spaces\");\n        assert_eq!(sanitize_filename(\"user/\\\\\u003c\u003e:|?*\"), \"user________\");\n        \n        // Should limit length\n        let long_name = \"a\".repeat(100);\n        let sanitized = sanitize_filename(\u0026long_name);\n        assert_eq!(sanitized.len(), 32);\n    }\n\n    #[test]\n    fn test_create_profile_already_exists() {\n        let temp_dir = TempDir::new().unwrap();\n        let storage = SecureStorage::new(temp_dir.path()).unwrap();\n        let password = SecretString::new(\"test_password\".to_string());\n\n        // Create first profile\n        storage.create_profile(\"alice\", \u0026password).unwrap();\n\n        // Try to create same profile again\n        let result = storage.create_profile(\"alice\", \u0026password);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_load_profile_not_found() {\n        let temp_dir = TempDir::new().unwrap();\n        let storage = SecureStorage::new(temp_dir.path()).unwrap();\n        let password = SecretString::new(\"test_password\".to_string());\n\n        let fake_id = ProfileId::new(\"nonexistent\");\n        let result = storage.load_profile(\u0026fake_id, \u0026password);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_delete_profile_not_found() {\n        let temp_dir = TempDir::new().unwrap();\n        let storage = SecureStorage::new(temp_dir.path()).unwrap();\n\n        let fake_id = ProfileId::new(\"nonexistent\");\n        let result = storage.delete_profile(\u0026fake_id);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_list_profiles_empty() {\n        let temp_dir = TempDir::new().unwrap();\n        let storage = SecureStorage::new(temp_dir.path()).unwrap();\n\n        let profiles = storage.list_profiles().unwrap();\n        assert_eq!(profiles.len(), 0);\n    }\n\n    #[test]\n    fn test_profile_settings_default() {\n        let settings = ProfileSettings::default();\n        assert!(!settings.auto_accept_friends);\n        assert_eq!(settings.encryption_level, \"balanced\");\n        assert!(settings.backup_enabled);\n        assert_eq!(settings.theme, \"auto\");\n    }\n\n    #[test]\n    fn test_profile_loading_with_different_configs() {\n        let temp_dir = TempDir::new().unwrap();\n        let storage = SecureStorage::new(temp_dir.path()).unwrap();\n\n        // Test loading profiles with different Argon2 configs\n        let passwords = [\n            SecretString::new(\"password1\".to_string()),\n            SecretString::new(\"password2\".to_string()),\n            SecretString::new(\"password3\".to_string()),\n        ];\n\n        let names = [\"user_fast\", \"user_balanced\", \"user_secure\"];\n\n        for (i, (name, password)) in names.iter().zip(passwords.iter()).enumerate() {\n            let profile_id = storage.create_profile(name, password).unwrap();\n            \n            // Should be able to load the profile\n            let loaded_profile = storage.load_profile(\u0026profile_id, password).unwrap();\n            assert_eq!(loaded_profile.metadata.name, *name);\n\n            // Wrong password should fail\n            let wrong_password = SecretString::new(format!(\"wrong_{i}\"));\n            assert!(storage.load_profile(\u0026profile_id, \u0026wrong_password).is_err());\n        }\n    }\n\n    #[test]\n    fn test_profile_key_integrity() {\n        let temp_dir = TempDir::new().unwrap();\n        let storage = SecureStorage::new(temp_dir.path()).unwrap();\n        let password = SecretString::new(\"test_password\".to_string());\n\n        let profile_id = storage.create_profile(\"alice\", \u0026password).unwrap();\n        let profile = storage.load_profile(\u0026profile_id, \u0026password).unwrap();\n\n        // Test that the keys work for crypto operations\n        let message = b\"test message for signing\";\n        let signature = profile.identity_keypair.sign(message);\n        \n        // Verify signature works\n        assert!(profile.identity_keypair.verify(message, \u0026signature).is_ok());\n        \n        // Wrong message should fail verification\n        assert!(profile.identity_keypair.verify(b\"wrong message\", \u0026signature).is_err());\n    }\n\n    #[test]\n    fn test_profile_metadata_consistency() {\n        let temp_dir = TempDir::new().unwrap();\n        let storage = SecureStorage::new(temp_dir.path()).unwrap();\n        let password = SecretString::new(\"test_password\".to_string());\n\n        let profile_id = storage.create_profile(\"test_user\", \u0026password).unwrap();\n        let profile = storage.load_profile(\u0026profile_id, \u0026password).unwrap();\n\n        // Metadata should be consistent\n        assert_eq!(profile.metadata.id.name, \"test_user\");\n        assert_eq!(profile.metadata.name, \"test_user\");\n        assert_eq!(profile.metadata.version, \"0.1.0\");\n        assert!(profile.metadata.created \u003c= chrono::Utc::now());\n        assert!(profile.metadata.last_access \u003c= chrono::Utc::now());\n        assert!(profile.metadata.last_access \u003e= profile.metadata.created);\n    }\n\n    #[test] \n    fn test_secure_storage_directory_creation() {\n        let temp_dir = TempDir::new().unwrap();\n        let storage_path = temp_dir.path().join(\"new_storage\");\n\n        // Directory doesn't exist yet\n        assert!(!storage_path.exists());\n\n        // Creating storage should create directories\n        let _storage = SecureStorage::new(\u0026storage_path).unwrap();\n        assert!(storage_path.exists());\n        assert!(storage_path.join(\"profiles\").exists());\n        assert!(storage_path.join(\"keystore\").exists());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","seb","Dev","miaou","miaou-crypto","src","aead.rs"],"content":"//! # AEAD ChaCha20-Poly1305 (v0.1)\n//!\n//! Chiffrement authentifi√© avec nonce 96 bits (12 octets) et AAD obligatoire.\n//! Utilise ChaCha20-Poly1305 standard avec gestion stricte des nonces.\n\nuse crate::CryptoError;\nuse chacha20poly1305::{\n    aead::{Aead, KeyInit, Payload},\n    ChaCha20Poly1305, Key, Nonce,\n};\nuse rand_core::RngCore;\nuse zeroize::{Zeroize, ZeroizeOnDrop};\n\n/// Cl√© AEAD opaque (32 octets) avec Zeroize automatique\n#[derive(ZeroizeOnDrop)]\npub struct AeadKeyRef {\n    key: Key,\n}\n\nimpl AeadKeyRef {\n    /// Construit une cl√© AEAD depuis 32 octets.\n    #[must_use]\n    pub fn from_bytes(k: [u8; 32]) -\u003e Self {\n        Self {\n            key: Key::from_slice(\u0026k).to_owned(),\n        }\n    }\n\n    /// G√©n√®re une nouvelle cl√© AEAD al√©atoire.\n    #[must_use]\n    pub fn generate(rng: \u0026mut dyn RngCore) -\u003e Self {\n        let mut key_bytes = [0u8; 32];\n        rng.fill_bytes(\u0026mut key_bytes);\n        let result = Self::from_bytes(key_bytes);\n        key_bytes.zeroize();\n        result\n    }\n\n    /// Retourne une r√©f√©rence vers la cl√© interne (usage interne).\n    #[must_use]\n    pub(crate) const fn as_key(\u0026self) -\u003e \u0026Key {\n        \u0026self.key\n    }\n}\n\n// Pas de Debug pour √©viter les fuites\nimpl std::fmt::Debug for AeadKeyRef {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"AeadKeyRef([REDACTED])\")\n    }\n}\n\n/// Donn√©es scell√©es avec nonce int√©gr√©\n#[derive(Clone, Debug)]\npub struct SealedData {\n    /// Nonce `ChaCha20` (96-bit)\n    pub nonce: [u8; 12],\n    /// Donn√©es chiffr√©es avec tag `Poly1305` inclus\n    pub ciphertext: Vec\u003cu8\u003e,\n}\n\nimpl SealedData {\n    /// Cr√©e un nouveau `SealedData`\n    #[must_use]\n    pub const fn new(nonce: [u8; 12], ciphertext: Vec\u003cu8\u003e) -\u003e Self {\n        Self { nonce, ciphertext }\n    }\n\n    /// Retourne la taille totale (nonce + ciphertext)\n    #[must_use]\n    pub const fn total_size(\u0026self) -\u003e usize {\n        12 + self.ciphertext.len()\n    }\n}\n\n/// G√©n√®re un nonce al√©atoire 12 octets pour `ChaCha20`.\n#[must_use]\npub fn random_nonce(rng: \u0026mut dyn RngCore) -\u003e [u8; 12] {\n    let mut nonce = [0u8; 12];\n    rng.fill_bytes(\u0026mut nonce);\n    nonce\n}\n\n/// Chiffre avec `ChaCha20-Poly1305` (nonce externe).\n///\n/// # Errors\n/// Retourne une erreur si l'AEAD √©choue (cl√© invalide, AAD non concordante, ou impl. sous-jacente en √©chec).\npub fn encrypt(\n    key: \u0026AeadKeyRef,\n    nonce: [u8; 12],\n    aad: \u0026[u8],\n    plaintext: \u0026[u8],\n) -\u003e Result\u003cSealedData, CryptoError\u003e {\n    // AAD ne doit jamais √™tre vide\n    if aad.is_empty() {\n        return Err(CryptoError::EmptyAad);\n    }\n\n    let cipher = ChaCha20Poly1305::new(key.as_key());\n    let nonce_ref = Nonce::from_slice(\u0026nonce);\n\n    let payload = Payload {\n        msg: plaintext,\n        aad,\n    };\n\n    let ciphertext = cipher\n        .encrypt(nonce_ref, payload)\n        .map_err(|_| CryptoError::EncryptionFailed)?;\n\n    Ok(SealedData::new(nonce, ciphertext))\n}\n\n/// D√©chiffre avec `ChaCha20-Poly1305`.\n///\n/// # Errors\n/// Retourne une erreur si l'authentification √©choue (tag invalide), si le nonce est incorrect ou sur erreur interne.\npub fn decrypt(key: \u0026AeadKeyRef, aad: \u0026[u8], sealed: \u0026SealedData) -\u003e Result\u003cVec\u003cu8\u003e, CryptoError\u003e {\n    // AAD ne doit jamais √™tre vide\n    if aad.is_empty() {\n        return Err(CryptoError::EmptyAad);\n    }\n\n    let cipher = ChaCha20Poly1305::new(key.as_key());\n    let nonce_ref = Nonce::from_slice(\u0026sealed.nonce);\n\n    let payload = Payload {\n        msg: \u0026sealed.ciphertext,\n        aad,\n    };\n\n    cipher\n        .decrypt(nonce_ref, payload)\n        .map_err(|_| CryptoError::DecryptionFailed)\n}\n\n/// Chiffre avec g√©n√©ration automatique de nonce.\n///\n/// # Errors\n/// Retourne une erreur si le chiffrement √©choue.\npub fn encrypt_auto_nonce(\n    key: \u0026AeadKeyRef,\n    aad: \u0026[u8],\n    plaintext: \u0026[u8],\n    rng: \u0026mut dyn RngCore,\n) -\u003e Result\u003cSealedData, CryptoError\u003e {\n    let nonce = random_nonce(rng);\n    encrypt(key, nonce, aad, plaintext)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_core::OsRng;\n\n    #[test]\n    fn test_aead_roundtrip() {\n        let key = AeadKeyRef::from_bytes([42u8; 32]);\n        let nonce = [1u8; 12];\n        let aad = b\"miaou_v1\";\n\n        let sealed = encrypt(\u0026key, nonce, aad, b\"hello world\").unwrap();\n        let decrypted = decrypt(\u0026key, aad, \u0026sealed).unwrap();\n\n        assert_eq!(decrypted, b\"hello world\");\n        assert_eq!(sealed.nonce, nonce);\n    }\n\n    #[test]\n    fn test_aad_enforcement() {\n        let key = AeadKeyRef::from_bytes([42u8; 32]);\n        let nonce = [1u8; 12];\n\n        // AAD vide doit √©chouer\n        let result = encrypt(\u0026key, nonce, b\"\", b\"plaintext\");\n        assert!(matches!(result, Err(CryptoError::EmptyAad)));\n\n        // AAD non-vide doit fonctionner\n        let result = encrypt(\u0026key, nonce, b\"version:1\", b\"plaintext\");\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_aad_mismatch() {\n        let key = AeadKeyRef::from_bytes([42u8; 32]);\n        let nonce = [1u8; 12];\n\n        let sealed = encrypt(\u0026key, nonce, b\"aad1\", b\"message\").unwrap();\n\n        // AAD diff√©rent doit √©chouer\n        let result = decrypt(\u0026key, b\"aad2\", \u0026sealed);\n        assert!(matches!(result, Err(CryptoError::DecryptionFailed)));\n\n        // AAD correct doit fonctionner\n        let result = decrypt(\u0026key, b\"aad1\", \u0026sealed);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_nonce_uniqueness() {\n        let mut rng = OsRng;\n        let mut nonces = std::collections::HashSet::new();\n\n        // G√©n√©rer 1000 nonces et v√©rifier unicit√©\n        for _ in 0..1000 {\n            let nonce = random_nonce(\u0026mut rng);\n            assert!(nonces.insert(nonce)); // Doit √™tre unique\n        }\n    }\n\n    #[test]\n    fn test_auto_nonce_encryption() {\n        let key = AeadKeyRef::generate(\u0026mut OsRng);\n        let mut rng = OsRng;\n\n        let sealed = encrypt_auto_nonce(\u0026key, b\"aad\", b\"message\", \u0026mut rng).unwrap();\n        let decrypted = decrypt(\u0026key, b\"aad\", \u0026sealed).unwrap();\n\n        assert_eq!(decrypted, b\"message\");\n    }\n\n    #[test]\n    fn test_decrypt_with_empty_aad() {\n        let key = AeadKeyRef::from_bytes([42u8; 32]);\n        let nonce = [1u8; 12];\n        \n        // First encrypt with valid AAD\n        let sealed = encrypt(\u0026key, nonce, b\"valid_aad\", b\"message\").unwrap();\n        \n        // Try to decrypt with empty AAD should fail\n        let result = decrypt(\u0026key, b\"\", \u0026sealed);\n        assert!(matches!(result, Err(CryptoError::EmptyAad)));\n    }\n\n    #[test]\n    fn test_encrypt_auto_nonce_success() {\n        let key = AeadKeyRef::from_bytes([42u8; 32]);\n        let aad = b\"test_aad\";\n        let plaintext = b\"test message\";\n        let mut rng = OsRng;\n        \n        let sealed = encrypt_auto_nonce(\u0026key, aad, plaintext, \u0026mut rng).unwrap();\n        let decrypted = decrypt(\u0026key, aad, \u0026sealed).unwrap();\n        \n        assert_eq!(decrypted, plaintext);\n        assert_eq!(sealed.nonce.len(), 12);\n    }\n\n    #[test]\n    fn test_sealed_data_total_size() {\n        let key = AeadKeyRef::from_bytes([42u8; 32]);\n        let nonce = [1u8; 12];\n        let aad = b\"test_aad\";\n        let plaintext = b\"hello world\"; // 11 bytes\n        \n        let sealed = encrypt(\u0026key, nonce, aad, plaintext).unwrap();\n        \n        // Total size should be nonce + ciphertext + tag\n        // ChaCha20-Poly1305 adds 16 bytes for authentication tag\n        let expected_size = 12 + 11 + 16; // nonce + plaintext + tag\n        assert_eq!(sealed.total_size(), expected_size);\n    }\n\n    #[test]\n    fn test_aead_key_ref_generate() {\n        let mut rng = OsRng;\n        let key1 = AeadKeyRef::generate(\u0026mut rng);\n        let key2 = AeadKeyRef::generate(\u0026mut rng);\n        \n        // Generated keys should be different\n        assert_ne!(key1.as_key().as_slice(), key2.as_key().as_slice());\n    }\n\n    #[test]\n    fn test_aead_key_ref_debug() {\n        let key = AeadKeyRef::from_bytes([42u8; 32]);\n        let debug_str = format!(\"{:?}\", key);\n        \n        // Should not expose key material\n        assert!(debug_str.contains(\"AeadKeyRef([REDACTED])\"));\n    }\n\n    #[test]\n    fn test_key_zeroization() {\n        // Test que AeadKeyRef impl√©mente ZeroizeOnDrop\n        fn assert_zeroize_on_drop\u003cT: ZeroizeOnDrop\u003e() {}\n        assert_zeroize_on_drop::\u003cAeadKeyRef\u003e();\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","seb","Dev","miaou","miaou-crypto","src","encryption.rs"],"content":"//! Chiffrement authentifi√© avec ChaCha20-Poly1305\n//! \n//! Impl√©mentation s√©curis√©e du chiffrement AEAD (Authenticated Encryption with Associated Data)\n//! utilisant ChaCha20-Poly1305 selon RFC 8439.\n\nuse crate::crypto::{CryptoError, CryptoResult, NONCE_SIZE, KEY_SIZE};\nuse chacha20poly1305::{\n    aead::{Aead, NewAead},\n    ChaCha20Poly1305, Nonce, Key\n};\nuse rand::RngCore;\nuse zeroize::{Zeroize, ZeroizeOnDrop};\nuse serde::{Deserialize, Serialize};\n\n/// Trait pour les moteurs de chiffrement\npub trait EncryptionEngine {\n    /// G√©n√®re une nouvelle cl√© de chiffrement\n    fn generate_key() -\u003e CryptoResult\u003cSelf\u003e where Self: Sized;\n    \n    /// Chiffre des donn√©es avec un nonce donn√©\n    fn encrypt(\u0026self, plaintext: \u0026[u8], nonce: \u0026[u8]) -\u003e CryptoResult\u003cVec\u003cu8\u003e\u003e;\n    \n    /// D√©chiffre des donn√©es avec un nonce donn√©\n    fn decrypt(\u0026self, ciphertext: \u0026[u8], nonce: \u0026[u8]) -\u003e CryptoResult\u003cVec\u003cu8\u003e\u003e;\n    \n    /// Chiffre des donn√©es avec un nonce g√©n√©r√© automatiquement\n    fn encrypt_with_random_nonce(\u0026self, plaintext: \u0026[u8]) -\u003e CryptoResult\u003cEncryptedData\u003e;\n    \n    /// D√©chiffre des donn√©es qui incluent le nonce\n    fn decrypt_with_nonce(\u0026self, encrypted_data: \u0026EncryptedData) -\u003e CryptoResult\u003cVec\u003cu8\u003e\u003e;\n}\n\n/// Donn√©es chiffr√©es avec nonce inclus\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct EncryptedData {\n    /// Nonce utilis√© pour le chiffrement\n    pub nonce: [u8; NONCE_SIZE],\n    /// Donn√©es chiffr√©es avec tag d'authentification\n    pub ciphertext: Vec\u003cu8\u003e,\n}\n\n/// Impl√©mentation ChaCha20-Poly1305\npub struct ChaCha20Poly1305Cipher {\n    cipher: ChaCha20Poly1305,\n    key_fingerprint: [u8; 4], // Pour identification, pas de s√©curit√©\n}\n\nimpl ChaCha20Poly1305Cipher {\n    /// Cr√©e un chiffreur √† partir d'une cl√©\n    pub fn from_key(key: \u0026[u8; KEY_SIZE]) -\u003e CryptoResult\u003cSelf\u003e {\n        let key_ref = Key::from_slice(key);\n        let cipher = ChaCha20Poly1305::new(key_ref);\n        \n        // Empreinte simple pour identification (non s√©curis√©)\n        let mut hasher = blake3::Hasher::new();\n        hasher.update(key);\n        let hash = hasher.finalize();\n        let key_fingerprint = [hash.as_bytes()[0], hash.as_bytes()[1], \n                              hash.as_bytes()[2], hash.as_bytes()[3]];\n        \n        Ok(Self {\n            cipher,\n            key_fingerprint,\n        })\n    }\n    \n    /// G√©n√®re un nonce al√©atoire s√©curis√©\n    pub fn generate_nonce() -\u003e [u8; NONCE_SIZE] {\n        let mut nonce = [0u8; NONCE_SIZE];\n        use rand::RngCore;\n        rand::thread_rng().fill_bytes(\u0026mut nonce);\n        nonce\n    }\n    \n    /// Retourne l'empreinte de la cl√© (pour identification uniquement)\n    pub fn key_fingerprint(\u0026self) -\u003e [u8; 4] {\n        self.key_fingerprint\n    }\n}\n\nimpl EncryptionEngine for ChaCha20Poly1305Cipher {\n    fn generate_key() -\u003e CryptoResult\u003cSelf\u003e {\n        let key = ChaCha20Poly1305::generate_key(\u0026mut OsRng);\n        Self::from_key(key.as_slice().try_into()\n            .map_err(|_| CryptoError::KeyGenerationError(\"Taille de cl√© invalide\".into()))?)\n    }\n    \n    fn encrypt(\u0026self, plaintext: \u0026[u8], nonce: \u0026[u8]) -\u003e CryptoResult\u003cVec\u003cu8\u003e\u003e {\n        if nonce.len() != NONCE_SIZE {\n            return Err(CryptoError::InvalidDataSize {\n                expected: NONCE_SIZE,\n                actual: nonce.len(),\n            });\n        }\n        \n        let nonce_ref = Nonce::from_slice(nonce);\n        \n        self.cipher\n            .encrypt(nonce_ref, plaintext)\n            .map_err(|e| CryptoError::EncryptionError(format!(\"ChaCha20-Poly1305 encryption failed: {}\", e)))\n    }\n    \n    fn decrypt(\u0026self, ciphertext: \u0026[u8], nonce: \u0026[u8]) -\u003e CryptoResult\u003cVec\u003cu8\u003e\u003e {\n        if nonce.len() != NONCE_SIZE {\n            return Err(CryptoError::InvalidDataSize {\n                expected: NONCE_SIZE,\n                actual: nonce.len(),\n            });\n        }\n        \n        let nonce_ref = Nonce::from_slice(nonce);\n        \n        self.cipher\n            .decrypt(nonce_ref, ciphertext)\n            .map_err(|e| CryptoError::DecryptionError(format!(\"ChaCha20-Poly1305 decryption failed: {}\", e)))\n    }\n    \n    fn encrypt_with_random_nonce(\u0026self, plaintext: \u0026[u8]) -\u003e CryptoResult\u003cEncryptedData\u003e {\n        let nonce = Self::generate_nonce();\n        let ciphertext = self.encrypt(plaintext, \u0026nonce)?;\n        \n        Ok(EncryptedData {\n            nonce,\n            ciphertext,\n        })\n    }\n    \n    fn decrypt_with_nonce(\u0026self, encrypted_data: \u0026EncryptedData) -\u003e CryptoResult\u003cVec\u003cu8\u003e\u003e {\n        self.decrypt(\u0026encrypted_data.ciphertext, \u0026encrypted_data.nonce)\n    }\n}\n\n/// Protection contre la r√©utilisation de nonce\n#[derive(Default)]\npub struct NonceTracker {\n    used_nonces: std::collections::HashSet\u003c[u8; NONCE_SIZE]\u003e,\n}\n\nimpl NonceTracker {\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n    \n    /// V√©rifie et enregistre un nonce pour √©viter la r√©utilisation\n    pub fn check_and_register_nonce(\u0026mut self, nonce: \u0026[u8; NONCE_SIZE]) -\u003e CryptoResult\u003c()\u003e {\n        if self.used_nonces.contains(nonce) {\n            return Err(CryptoError::NonceReuse);\n        }\n        \n        self.used_nonces.insert(*nonce);\n        Ok(())\n    }\n    \n    /// Nombre de nonces utilis√©s\n    pub fn nonce_count(\u0026self) -\u003e usize {\n        self.used_nonces.len()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_chacha20_poly1305_basic() {\n        let cipher = ChaCha20Poly1305Cipher::generate_key().unwrap();\n        let plaintext = b\"Hello, Miaou!\";\n        let nonce = ChaCha20Poly1305Cipher::generate_nonce();\n        \n        let ciphertext = cipher.encrypt(plaintext, \u0026nonce).unwrap();\n        let decrypted = cipher.decrypt(\u0026ciphertext, \u0026nonce).unwrap();\n        \n        assert_eq!(plaintext, decrypted.as_slice());\n    }\n    \n    #[test]\n    fn test_encrypt_with_random_nonce() {\n        let cipher = ChaCha20Poly1305Cipher::generate_key().unwrap();\n        let plaintext = b\"Secret message for Miaou\";\n        \n        let encrypted = cipher.encrypt_with_random_nonce(plaintext).unwrap();\n        let decrypted = cipher.decrypt_with_nonce(\u0026encrypted).unwrap();\n        \n        assert_eq!(plaintext, decrypted.as_slice());\n    }\n    \n    #[test]\n    fn test_wrong_nonce_fails() {\n        let cipher = ChaCha20Poly1305Cipher::generate_key().unwrap();\n        let plaintext = b\"Test message\";\n        let nonce1 = ChaCha20Poly1305Cipher::generate_nonce();\n        let nonce2 = ChaCha20Poly1305Cipher::generate_nonce();\n        \n        let ciphertext = cipher.encrypt(plaintext, \u0026nonce1).unwrap();\n        let result = cipher.decrypt(\u0026ciphertext, \u0026nonce2);\n        \n        assert!(result.is_err());\n    }\n    \n    #[test]\n    fn test_nonce_tracker() {\n        let mut tracker = NonceTracker::new();\n        let nonce1 = ChaCha20Poly1305Cipher::generate_nonce();\n        let nonce2 = ChaCha20Poly1305Cipher::generate_nonce();\n        \n        // Premier usage OK\n        assert!(tracker.check_and_register_nonce(\u0026nonce1).is_ok());\n        assert_eq!(tracker.nonce_count(), 1);\n        \n        // R√©utilisation d√©tect√©e\n        assert!(tracker.check_and_register_nonce(\u0026nonce1).is_err());\n        \n        // Nouveau nonce OK\n        assert!(tracker.check_and_register_nonce(\u0026nonce2).is_ok());\n        assert_eq!(tracker.nonce_count(), 2);\n    }\n    \n    #[test]\n    fn test_key_fingerprint() {\n        let cipher1 = ChaCha20Poly1305Cipher::generate_key().unwrap();\n        let cipher2 = ChaCha20Poly1305Cipher::generate_key().unwrap();\n        \n        // Empreintes diff√©rentes pour cl√©s diff√©rentes\n        assert_ne!(cipher1.key_fingerprint(), cipher2.key_fingerprint());\n        \n        // Empreinte stable pour m√™me cl√©\n        let fingerprint1 = cipher1.key_fingerprint();\n        let fingerprint2 = cipher1.key_fingerprint();\n        assert_eq!(fingerprint1, fingerprint2);\n    }\n}","traces":[],"covered":0,"coverable":0},{"path":["/","home","seb","Dev","miaou","miaou-crypto","src","hash.rs"],"content":"//! # Hash (v0.1)\n//!\n//! BLAKE3 (par d√©faut) et SHA3-256 (compatibilit√©).\n\nuse blake3::{Hash as Blake3Hash, Hasher as Blake3Hasher};\nuse sha3::{Digest, Sha3_256};\n// use zeroize::{Zeroize, Zeroizing}; // Pour l'instant non utilis√©\n\n/// BLAKE3 32 octets (rapide, s√©curis√©)\n#[must_use]\npub fn blake3_32(input: \u0026[u8]) -\u003e [u8; 32] {\n    *blake3::hash(input).as_bytes()\n}\n\n/// BLAKE3 avec contexte (domaine de s√©paration)\n#[must_use]\npub fn blake3_with_context(input: \u0026[u8], context: \u0026str) -\u003e [u8; 32] {\n    let mut hasher = Blake3Hasher::new_derive_key(context);\n    hasher.update(input);\n    *hasher.finalize().as_bytes()\n}\n\n/// BLAKE3 avec cl√© (HMAC-like)\n#[must_use]\npub fn blake3_keyed(key: \u0026[u8; 32], input: \u0026[u8]) -\u003e [u8; 32] {\n    let mut hasher = Blake3Hasher::new_keyed(key);\n    hasher.update(input);\n    *hasher.finalize().as_bytes()\n}\n\n/// BLAKE3 pour plusieurs √©l√©ments (ordre sensible)\n#[must_use]\npub fn blake3_multiple(items: \u0026[\u0026[u8]]) -\u003e [u8; 32] {\n    let mut hasher = Blake3Hasher::new();\n    for item in items {\n        hasher.update(item);\n    }\n    *hasher.finalize().as_bytes()\n}\n\n/// SHA3-256 (compatibilit√© standards)\n#[must_use]\npub fn sha3_256(input: \u0026[u8]) -\u003e [u8; 32] {\n    let mut hasher = Sha3_256::new();\n    hasher.update(input);\n    hasher.finalize().into()\n}\n\n/// Output BLAKE3 avec encodage hex\n#[derive(Clone, PartialEq, Eq)]\npub struct Blake3Output {\n    hash: Blake3Hash,\n}\n\nimpl Blake3Output {\n    /// Cr√©e depuis un hash BLAKE3\n    #[must_use]\n    pub const fn new(hash: Blake3Hash) -\u003e Self {\n        Self { hash }\n    }\n\n    /// Hash des donn√©es\n    #[must_use]\n    pub fn hash(input: \u0026[u8]) -\u003e Self {\n        Self::new(blake3::hash(input))\n    }\n\n    /// Hash avec contexte\n    #[must_use]\n    pub fn hash_with_context(input: \u0026[u8], context: \u0026str) -\u003e Self {\n        let mut hasher = Blake3Hasher::new_derive_key(context);\n        hasher.update(input);\n        Self::new(hasher.finalize())\n    }\n\n    /// Hash avec cl√©\n    #[must_use]\n    pub fn hash_keyed(key: \u0026[u8; 32], input: \u0026[u8]) -\u003e Self {\n        let mut hasher = Blake3Hasher::new_keyed(key);\n        hasher.update(input);\n        Self::new(hasher.finalize())\n    }\n\n    /// Hash de plusieurs √©l√©ments\n    #[must_use]\n    pub fn hash_multiple(items: \u0026[\u0026[u8]]) -\u003e Self {\n        let mut hasher = Blake3Hasher::new();\n        for item in items {\n            hasher.update(item);\n        }\n        Self::new(hasher.finalize())\n    }\n\n    /// Retourne les octets du hash\n    #[must_use]\n    pub const fn as_bytes(\u0026self) -\u003e \u0026[u8; 32] {\n        self.hash.as_bytes()\n    }\n\n    /// Encode en hexad√©cimal\n    #[must_use]\n    pub fn to_hex(\u0026self) -\u003e String {\n        hex::encode(self.as_bytes())\n    }\n\n    /// D√©code depuis l'hexad√©cimal\n    ///\n    /// # Errors\n    /// √âchec si `hex_str` n'est pas une cha√Æne hex valide de 32 octets.\n    pub fn from_hex(hex_str: \u0026str) -\u003e Result\u003cSelf, hex::FromHexError\u003e {\n        let bytes = hex::decode(hex_str)?;\n        if bytes.len() != 32 {\n            return Err(hex::FromHexError::InvalidStringLength);\n        }\n\n        let mut hash_bytes = [0u8; 32];\n        hash_bytes.copy_from_slice(\u0026bytes);\n\n        Ok(Self {\n            hash: Blake3Hash::from(hash_bytes),\n        })\n    }\n}\n\nimpl std::fmt::Debug for Blake3Output {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"Blake3Output({})\", self.to_hex())\n    }\n}\n\nimpl std::fmt::Display for Blake3Output {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}\", self.to_hex())\n    }\n}\n\n/// Moteur de hachage unifi√©\npub trait HashingEngine {\n    /// Type de sortie du hachage\n    type Output;\n\n    /// Hash simple\n    fn hash(input: \u0026[u8]) -\u003e Self::Output;\n\n    /// Hash avec contexte optionnel\n    fn hash_with_context(input: \u0026[u8], context: \u0026str) -\u003e Self::Output;\n\n    /// Hash avec cl√© (HMAC-like)\n    fn hash_keyed(key: \u0026[u8; 32], input: \u0026[u8]) -\u003e Self::Output;\n\n    /// Hash de plusieurs √©l√©ments\n    fn hash_multiple(items: \u0026[\u0026[u8]]) -\u003e Self::Output;\n}\n\n/// Impl√©mentation BLAKE3 du moteur de hachage\npub struct Blake3Engine;\n\nimpl HashingEngine for Blake3Engine {\n    type Output = Blake3Output;\n\n    fn hash(input: \u0026[u8]) -\u003e Self::Output {\n        Blake3Output::hash(input)\n    }\n\n    fn hash_with_context(input: \u0026[u8], context: \u0026str) -\u003e Self::Output {\n        Blake3Output::hash_with_context(input, context)\n    }\n\n    fn hash_keyed(key: \u0026[u8; 32], input: \u0026[u8]) -\u003e Self::Output {\n        Blake3Output::hash_keyed(key, input)\n    }\n\n    fn hash_multiple(items: \u0026[\u0026[u8]]) -\u003e Self::Output {\n        Blake3Output::hash_multiple(items)\n    }\n}\n\n/// Comparaison s√©curis√©e (constant-time)\n#[must_use]\npub fn secure_compare(a: \u0026[u8], b: \u0026[u8]) -\u003e bool {\n    use subtle::ConstantTimeEq;\n    if a.len() != b.len() {\n        return false;\n    }\n    a.ct_eq(b).into()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_blake3_basic() {\n        let data = b\"test data for blake3\";\n        let hash1 = blake3_32(data);\n        let hash2 = blake3_32(data);\n\n        // M√™me donn√©es = m√™me hash\n        assert_eq!(hash1, hash2);\n        assert_eq!(hash1.len(), 32);\n\n        // Donn√©es diff√©rentes = hash diff√©rents\n        let hash3 = blake3_32(b\"different data\");\n        assert_ne!(hash1, hash3);\n    }\n\n    #[test]\n    fn test_blake3_context() {\n        let data = b\"same data\";\n        let hash1 = blake3_with_context(data, \"context1\");\n        let hash2 = blake3_with_context(data, \"context2\");\n\n        // Contextes diff√©rents = hash diff√©rents\n        assert_ne!(hash1, hash2);\n\n        // M√™me contexte = m√™me hash\n        let hash3 = blake3_with_context(data, \"context1\");\n        assert_eq!(hash1, hash3);\n    }\n\n    #[test]\n    fn test_blake3_keyed() {\n        let key = [42u8; 32];\n        let data = b\"test data\";\n\n        let hash1 = blake3_keyed(\u0026key, data);\n        let hash2 = blake3_keyed(\u0026key, data);\n\n        // M√™me cl√© = m√™me hash\n        assert_eq!(hash1, hash2);\n\n        // Cl√© diff√©rente = hash diff√©rent\n        let key2 = [43u8; 32];\n        let hash3 = blake3_keyed(\u0026key2, data);\n        assert_ne!(hash1, hash3);\n    }\n\n    #[test]\n    fn test_blake3_multiple() {\n        let items1 = [\n            b\"part1\".as_slice(),\n            b\"part2\".as_slice(),\n            b\"part3\".as_slice(),\n        ];\n        let hash1 = blake3_multiple(\u0026items1);\n\n        // M√™me √©l√©ments = m√™me hash\n        let hash2 = blake3_multiple(\u0026items1);\n        assert_eq!(hash1, hash2);\n\n        // Ordre diff√©rent = hash diff√©rent\n        let items2 = [\n            b\"part2\".as_slice(),\n            b\"part1\".as_slice(),\n            b\"part3\".as_slice(),\n        ];\n        let hash3 = blake3_multiple(\u0026items2);\n        assert_ne!(hash1, hash3);\n\n        // Contenu √©quivalent mais concat√©n√©\n        let concat = b\"part1part2part3\";\n        let hash4 = blake3_32(concat);\n        assert_eq!(hash1, hash4);\n    }\n\n    #[test]\n    fn test_sha3_256() {\n        let data = b\"test data for sha3\";\n        let hash1 = sha3_256(data);\n        let hash2 = sha3_256(data);\n\n        assert_eq!(hash1, hash2);\n        assert_eq!(hash1.len(), 32);\n\n        // Diff√©rent de BLAKE3\n        let blake3_hash = blake3_32(data);\n        assert_ne!(hash1, blake3_hash);\n    }\n\n    #[test]\n    fn test_blake3_output_hex() {\n        let data = b\"test\";\n        let output = Blake3Output::hash(data);\n\n        let hex_string = output.to_hex();\n        assert!(!hex_string.is_empty());\n        assert_eq!(hex_string.len(), 64); // 32 bytes * 2 chars/byte\n\n        let decoded = Blake3Output::from_hex(\u0026hex_string).unwrap();\n        assert_eq!(output, decoded);\n    }\n\n    #[test]\n    fn test_hashing_engine() {\n        let data = b\"test engine\";\n\n        let output1 = Blake3Engine::hash(data);\n        let output2 = Blake3Engine::hash(data);\n\n        assert_eq!(output1, output2);\n        assert_eq!(output1.as_bytes().len(), 32);\n    }\n\n    #[test]\n    fn test_secure_compare() {\n        let data1 = vec![1, 2, 3, 4, 5];\n        let data2 = vec![1, 2, 3, 4, 5];\n        let data3 = vec![1, 2, 3, 4, 6];\n        let data4 = vec![1, 2, 3, 4]; // longueur diff√©rente\n\n        assert!(secure_compare(\u0026data1, \u0026data2));\n        assert!(!secure_compare(\u0026data1, \u0026data3));\n        assert!(!secure_compare(\u0026data1, \u0026data4));\n    }\n\n    #[test]\n    fn test_performance_basic() {\n        use std::time::Instant;\n\n        let data = vec![0x42; 1024]; // 1KB\n        let start = Instant::now();\n\n        for _ in 0..1000 {\n            let _hash = blake3_32(\u0026data);\n        }\n\n        let duration = start.elapsed();\n        println!(\"1000 hashes BLAKE3 de 1KB: {:?}\", duration);\n\n        // Test basique de performance (devrait √™tre rapide)\n        assert!(duration.as_millis() \u003c 1000);\n    }\n\n    #[test]\n    fn test_blake3_with_context() {\n        let data = b\"test data\";\n        let context = \"test_context\";\n        \n        let hash1 = blake3_with_context(data, context);\n        let hash2 = blake3_with_context(data, context);\n        \n        // Same context should produce same hash\n        assert_eq!(hash1, hash2);\n        assert_eq!(hash1.len(), 32);\n        \n        // Different context should produce different hash\n        let hash3 = blake3_with_context(data, \"different_context\");\n        assert_ne!(hash1, hash3);\n    }\n\n    #[test]\n    fn test_blake3_keyed_function() {\n        let key = [0x42; 32];\n        let data = b\"test data\";\n        \n        let hash1 = blake3_keyed(\u0026key, data);\n        let hash2 = blake3_keyed(\u0026key, data);\n        \n        // Same key should produce same hash\n        assert_eq!(hash1, hash2);\n        assert_eq!(hash1.len(), 32);\n        \n        // Different key should produce different hash\n        let key2 = [0x43; 32];\n        let hash3 = blake3_keyed(\u0026key2, data);\n        assert_ne!(hash1, hash3);\n    }\n\n    #[test]\n    fn test_blake3_multiple_function() {\n        let items = [b\"part1\".as_slice(), b\"part2\".as_slice()];\n        let hash1 = blake3_multiple(\u0026items);\n        let hash2 = blake3_multiple(\u0026items);\n        \n        // Same items should produce same hash\n        assert_eq!(hash1, hash2);\n        assert_eq!(hash1.len(), 32);\n        \n        // Different order should produce different hash\n        let items2 = [b\"part2\".as_slice(), b\"part1\".as_slice()];\n        let hash3 = blake3_multiple(\u0026items2);\n        assert_ne!(hash1, hash3);\n    }\n\n    #[test]\n    fn test_sha3_256_function() {\n        let data = b\"test data\";\n        let hash1 = sha3_256(data);\n        let hash2 = sha3_256(data);\n        \n        // Same data should produce same hash\n        assert_eq!(hash1, hash2);\n        assert_eq!(hash1.len(), 32);\n        \n        // Should be different from BLAKE3\n        let blake3_hash = blake3_32(data);\n        assert_ne!(hash1, blake3_hash);\n    }\n\n    #[test]\n    fn test_blake3_output_new() {\n        let data = b\"test\";\n        let hash = blake3::hash(data);\n        let output = Blake3Output::new(hash);\n        \n        assert_eq!(output.as_bytes(), hash.as_bytes());\n    }\n\n    #[test]\n    fn test_blake3_output_hash_method() {\n        let data = b\"test data\";\n        let output = Blake3Output::hash(data);\n        let direct_hash = blake3_32(data);\n        \n        assert_eq!(*output.as_bytes(), direct_hash);\n    }\n\n    #[test]\n    fn test_blake3_output_hash_with_context_method() {\n        let data = b\"test data\";\n        let context = \"test_context\";\n        \n        let output = Blake3Output::hash_with_context(data, context);\n        let direct_hash = blake3_with_context(data, context);\n        \n        assert_eq!(*output.as_bytes(), direct_hash);\n    }\n\n    #[test]\n    fn test_blake3_output_hash_keyed_method() {\n        let key = [0x42; 32];\n        let data = b\"test data\";\n        \n        let output = Blake3Output::hash_keyed(\u0026key, data);\n        let direct_hash = blake3_keyed(\u0026key, data);\n        \n        assert_eq!(*output.as_bytes(), direct_hash);\n    }\n\n    #[test]\n    fn test_blake3_output_hash_multiple_method() {\n        let items = [b\"part1\".as_slice(), b\"part2\".as_slice()];\n        \n        let output = Blake3Output::hash_multiple(\u0026items);\n        let direct_hash = blake3_multiple(\u0026items);\n        \n        assert_eq!(*output.as_bytes(), direct_hash);\n    }\n\n    #[test]\n    fn test_blake3_output_from_hex_errors() {\n        // Invalid hex characters\n        assert!(Blake3Output::from_hex(\"invalid_hex\").is_err());\n        \n        // Wrong length (too short)\n        assert!(Blake3Output::from_hex(\"deadbeef\").is_err());\n        \n        // Wrong length (too long)  \n        let too_long = \"a\".repeat(100);\n        assert!(Blake3Output::from_hex(\u0026too_long).is_err());\n        \n        // Empty string\n        assert!(Blake3Output::from_hex(\"\").is_err());\n    }\n\n    #[test]\n    fn test_blake3_output_debug_display() {\n        let data = b\"test\";\n        let output = Blake3Output::hash(data);\n        \n        // Test Debug formatting\n        let debug_str = format!(\"{:?}\", output);\n        assert!(debug_str.contains(\"Blake3Output(\"));\n        assert!(debug_str.contains(\u0026output.to_hex()));\n        \n        // Test Display formatting\n        let display_str = format!(\"{}\", output);\n        assert_eq!(display_str, output.to_hex());\n    }\n\n    #[test]\n    fn test_blake3_engine_all_methods() {\n        let data = b\"test data\";\n        let key = [0x42; 32];\n        let items = [b\"part1\".as_slice(), b\"part2\".as_slice()];\n        \n        // Test all HashingEngine methods for Blake3Engine\n        let hash1 = Blake3Engine::hash(data);\n        assert_eq!(hash1.as_bytes().len(), 32);\n        \n        let hash2 = Blake3Engine::hash_with_context(data, \"context\");\n        assert_eq!(hash2.as_bytes().len(), 32);\n        assert_ne!(hash1, hash2);\n        \n        let hash3 = Blake3Engine::hash_keyed(\u0026key, data);\n        assert_eq!(hash3.as_bytes().len(), 32);\n        assert_ne!(hash1, hash3);\n        \n        let hash4 = Blake3Engine::hash_multiple(\u0026items);\n        assert_eq!(hash4.as_bytes().len(), 32);\n        assert_ne!(hash1, hash4);\n    }\n\n    #[test]\n    fn test_secure_compare_edge_cases() {\n        // Empty arrays\n        assert!(secure_compare(\u0026[], \u0026[]));\n        \n        // Single byte\n        assert!(secure_compare(\u0026[42], \u0026[42]));\n        assert!(!secure_compare(\u0026[42], \u0026[43]));\n        \n        // Very long arrays (test performance doesn't degrade security)\n        let long1 = vec![42u8; 10000];\n        let long2 = vec![42u8; 10000];\n        let mut long3 = vec![42u8; 10000];\n        long3[9999] = 43;\n        \n        assert!(secure_compare(\u0026long1, \u0026long2));\n        assert!(!secure_compare(\u0026long1, \u0026long3));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","seb","Dev","miaou","miaou-crypto","src","hashing.rs"],"content":"//! Fonctions de hachage cryptographiques\n//!\n//! Impl√©mentation de BLAKE3 pour hachage g√©n√©ral et Argon2 pour d√©rivation\n//! de cl√©s √† partir de mots de passe.\n\nuse crate::{CryptoError, CryptoResult};\nuse serde::{Deserialize, Serialize};\n\n/// Trait pour les moteurs de hachage\npub trait HashingEngine {\n    /// Type de sortie du hachage\n    type Output;\n\n    /// Hache des donn√©es\n    fn hash(data: \u0026[u8]) -\u003e Self::Output;\n\n    /// Hache des donn√©es avec un contexte\n    fn hash_with_context(data: \u0026[u8], context: \u0026str) -\u003e Self::Output;\n}\n\n/// Moteur de hachage BLAKE3\npub struct Blake3Hasher;\n\n/// Moteur de d√©rivation Argon2\npub struct Argon2Hasher;\n\n/// Hash BLAKE3 (32 bytes)\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub struct Blake3Output {\n    hash: [u8; 32],\n}\n\n/// Configuration simple pour Argon2\n#[derive(Debug, Clone)]\npub struct Argon2Config {\n    /// M√©moire utilis√©e en KiB\n    pub memory_cost: u32,\n    /// Nombre d'it√©rations\n    pub time_cost: u32,\n    /// Parall√©lisme\n    pub parallelism: u32,\n    /// Longueur de sortie en bytes\n    pub output_length: u32,\n}\n\nimpl Default for Argon2Config {\n    fn default() -\u003e Self {\n        Self {\n            memory_cost: 65536, // 64 MiB\n            time_cost: 3,       // 3 it√©rations\n            parallelism: 4,     // 4 threads\n            output_length: 32,  // 32 bytes\n        }\n    }\n}\n\nimpl Argon2Config {\n    /// Configuration rapide pour tests (INS√âCURIS√â pour la production)\n    #[must_use]\n    pub const fn fast_insecure() -\u003e Self {\n        Self {\n            memory_cost: 1024, // 1 MiB\n            time_cost: 1,      // 1 it√©ration\n            parallelism: 1,    // 1 thread\n            output_length: 32,\n        }\n    }\n\n    /// Configuration s√©curis√©e pour production\n    #[must_use]\n    pub const fn secure() -\u003e Self {\n        Self {\n            memory_cost: 131_072, // 128 MiB\n            time_cost: 4,         // 4 it√©rations\n            parallelism: 4,       // 4 threads\n            output_length: 32,\n        }\n    }\n}\n\nimpl Blake3Output {\n    /// Cr√©e un hash √† partir de bytes\n    #[must_use]\n    pub const fn from_bytes(bytes: [u8; 32]) -\u003e Self {\n        Self { hash: bytes }\n    }\n\n    /// Retourne les bytes du hash\n    #[must_use]\n    pub const fn as_bytes(\u0026self) -\u003e \u0026[u8; 32] {\n        \u0026self.hash\n    }\n\n    /// Convertit en slice\n    #[must_use]\n    pub const fn as_slice(\u0026self) -\u003e \u0026[u8] {\n        \u0026self.hash\n    }\n\n    /// Encode en hexad√©cimal\n    #[must_use]\n    pub fn to_hex(\u0026self) -\u003e String {\n        hex::encode(self.hash)\n    }\n\n    /// D√©code depuis hexad√©cimal\n    ///\n    /// # Errors\n    /// √âchec si `hex_str` n'est pas une cha√Æne hex valide de 32 octets.\n    pub fn from_hex(hex_str: \u0026str) -\u003e CryptoResult\u003cSelf\u003e {\n        let bytes = hex::decode(hex_str).map_err(|_| CryptoError::InvalidInput)?;\n\n        if bytes.len() != 32 {\n            return Err(CryptoError::InvalidSize {\n                expected: 32,\n                actual: bytes.len(),\n            });\n        }\n\n        let mut hash = [0u8; 32];\n        hash.copy_from_slice(\u0026bytes);\n        Ok(Self { hash })\n    }\n}\n\nimpl HashingEngine for Blake3Hasher {\n    type Output = Blake3Output;\n\n    fn hash(data: \u0026[u8]) -\u003e Self::Output {\n        let hash = blake3::hash(data);\n        Blake3Output::from_bytes(*hash.as_bytes())\n    }\n\n    fn hash_with_context(data: \u0026[u8], context: \u0026str) -\u003e Self::Output {\n        let mut hasher = blake3::Hasher::new_keyed(\u0026blake3::hash(context.as_bytes()).into());\n        hasher.update(data);\n        let hash = hasher.finalize();\n        Blake3Output::from_bytes(*hash.as_bytes())\n    }\n}\n\nimpl Blake3Hasher {\n    /// Hache plusieurs √©l√©ments en une seule op√©ration\n    #[must_use]\n    pub fn hash_multiple(items: \u0026[\u0026[u8]]) -\u003e Blake3Output {\n        let mut hasher = blake3::Hasher::new();\n        for item in items {\n            hasher.update(item);\n        }\n        let hash = hasher.finalize();\n        Blake3Output::from_bytes(*hash.as_bytes())\n    }\n\n    /// Hache avec une cl√©\n    #[must_use]\n    pub fn hash_keyed(key: \u0026[u8; 32], data: \u0026[u8]) -\u003e Blake3Output {\n        let mut hasher = blake3::Hasher::new_keyed(key);\n        hasher.update(data);\n        let hash = hasher.finalize();\n        Blake3Output::from_bytes(*hash.as_bytes())\n    }\n}\n\nimpl Argon2Hasher {\n    /// D√©rive une cl√© avec Argon2 (version simplifi√©e)\n    ///\n    /// # Errors\n    /// √âchec si la d√©rivation de cl√© √©choue.\n    pub fn derive_key(\n        password: \u0026[u8],\n        salt: \u0026[u8],\n        config: \u0026Argon2Config,\n    ) -\u003e CryptoResult\u003cVec\u003cu8\u003e\u003e {\n        // Version simplifi√©e utilisant BLAKE3 pour la d√©rivation\n        // En attendant de r√©soudre les probl√®mes de compatibilit√© avec argon2\n        let combined = [password, salt, \u0026config.output_length.to_le_bytes()].concat();\n        let hash = blake3::hash(\u0026combined);\n        let mut result = hash.as_bytes().to_vec();\n        result.truncate(config.output_length as usize);\n        Ok(result)\n    }\n\n    /// Hache un mot de passe avec un sel g√©n√©r√©\n    ///\n    /// # Errors\n    /// √âchec si la s√©rialisation Argon2 √©choue.\n    pub fn hash_password(password: \u0026[u8], config: \u0026Argon2Config) -\u003e CryptoResult\u003cString\u003e {\n        use rand_core::{OsRng, RngCore};\n        let mut salt = [0u8; 16];\n        OsRng.fill_bytes(\u0026mut salt);\n\n        // Version simplifi√©e utilisant BLAKE3\n        let derived = Self::derive_key(password, \u0026salt, config)?;\n        let salt_hex = hex::encode(salt);\n        let hash_hex = hex::encode(derived);\n\n        Ok(format!(\"blake3${salt_hex}${hash_hex}\"))\n    }\n\n    /// V√©rifie un mot de passe contre un hash\n    ///\n    /// # Errors\n    /// √âchec si le format est invalide ou si la v√©rification √©choue.\n    pub fn verify_password(password: \u0026[u8], hash: \u0026str) -\u003e CryptoResult\u003cbool\u003e {\n        let parts: Vec\u003c\u0026str\u003e = hash.split('$').collect();\n        if parts.len() != 3 || parts[0] != \"blake3\" {\n            return Ok(false);\n        }\n\n        let salt = hex::decode(parts[1]).map_err(|_| CryptoError::InvalidInput)?;\n        let expected_hash = hex::decode(parts[2]).map_err(|_| CryptoError::InvalidInput)?;\n\n        let config = Argon2Config {\n            output_length: u32::try_from(expected_hash.len())\n                .map_err(|_| CryptoError::Truncation)?,\n            ..Default::default()\n        };\n        let computed = Self::derive_key(password, \u0026salt, \u0026config)?;\n\n        Ok(computed == expected_hash)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_blake3_hash() {\n        let data = b\"test data\";\n        let hash1 = Blake3Hasher::hash(data);\n        let hash2 = Blake3Hasher::hash(data);\n        assert_eq!(hash1, hash2);\n    }\n\n    #[test]\n    fn test_blake3_hash_different_data() {\n        let data1 = b\"test data 1\";\n        let data2 = b\"test data 2\";\n        let hash1 = Blake3Hasher::hash(data1);\n        let hash2 = Blake3Hasher::hash(data2);\n        assert_ne!(hash1, hash2);\n    }\n\n    #[test]\n    fn test_argon2_derive_key() {\n        let password = b\"test_password\";\n        let salt = b\"test_salt_123456\";\n        let config = Argon2Config::fast_insecure();\n\n        let key1 = Argon2Hasher::derive_key(password, salt, \u0026config).unwrap();\n        let key2 = Argon2Hasher::derive_key(password, salt, \u0026config).unwrap();\n\n        assert_eq!(key1, key2);\n        assert_eq!(key1.len(), config.output_length as usize);\n    }\n\n    #[test]\n    fn test_argon2_password_hash() {\n        let password = b\"test_password\";\n        let config = Argon2Config::fast_insecure();\n\n        let hash = Argon2Hasher::hash_password(password, \u0026config).unwrap();\n        let is_valid = Argon2Hasher::verify_password(password, \u0026hash).unwrap();\n\n        assert!(is_valid);\n\n        let wrong_password = b\"wrong_password\";\n        let is_valid = Argon2Hasher::verify_password(wrong_password, \u0026hash).unwrap();\n        assert!(!is_valid);\n    }\n\n    #[test]\n    fn test_blake3_output_from_bytes() {\n        let bytes = [42u8; 32];\n        let output = Blake3Output::from_bytes(bytes);\n        assert_eq!(*output.as_bytes(), bytes);\n    }\n\n    #[test]\n    fn test_blake3_output_as_slice() {\n        let bytes = [42u8; 32];\n        let output = Blake3Output::from_bytes(bytes);\n        assert_eq!(output.as_slice(), \u0026bytes);\n    }\n\n    #[test]\n    fn test_blake3_output_to_hex() {\n        let bytes = [42u8; 32];\n        let output = Blake3Output::from_bytes(bytes);\n        let hex_str = output.to_hex();\n        assert_eq!(hex_str.len(), 64); // 32 bytes * 2 hex chars\n        assert!(hex_str.chars().all(|c| c.is_ascii_hexdigit()));\n    }\n\n    #[test]\n    fn test_blake3_output_from_hex() {\n        let bytes = [42u8; 32];\n        let output = Blake3Output::from_bytes(bytes);\n        let hex_str = output.to_hex();\n        let restored = Blake3Output::from_hex(\u0026hex_str).unwrap();\n        assert_eq!(output, restored);\n    }\n\n    #[test]\n    fn test_blake3_output_from_hex_invalid() {\n        // Invalid hex string\n        assert!(Blake3Output::from_hex(\"invalid\").is_err());\n        \n        // Wrong length\n        assert!(Blake3Output::from_hex(\"deadbeef\").is_err());\n    }\n\n    #[test]\n    fn test_blake3_hasher_hash_multiple() {\n        let items = vec![b\"part1\".as_slice(), b\"part2\".as_slice(), b\"part3\".as_slice()];\n        let hash1 = Blake3Hasher::hash_multiple(\u0026items);\n        let hash2 = Blake3Hasher::hash_multiple(\u0026items);\n        assert_eq!(hash1, hash2);\n        \n        // Different order should give different hash\n        let items_different = vec![b\"part2\".as_slice(), b\"part1\".as_slice(), b\"part3\".as_slice()];\n        let hash3 = Blake3Hasher::hash_multiple(\u0026items_different);\n        assert_ne!(hash1, hash3);\n    }\n\n    #[test]\n    fn test_blake3_hasher_hash_keyed() {\n        let key = [1u8; 32];\n        let data = b\"test data\";\n        let hash1 = Blake3Hasher::hash_keyed(\u0026key, data);\n        let hash2 = Blake3Hasher::hash_keyed(\u0026key, data);\n        assert_eq!(hash1, hash2);\n        \n        // Different key should give different hash\n        let key2 = [2u8; 32];\n        let hash3 = Blake3Hasher::hash_keyed(\u0026key2, data);\n        assert_ne!(hash1, hash3);\n    }\n\n    #[test]\n    fn test_blake3_hasher_hash_with_context() {\n        let data = b\"test data\";\n        let context = \"test_context\";\n        let hash1 = Blake3Hasher::hash_with_context(data, context);\n        let hash2 = Blake3Hasher::hash_with_context(data, context);\n        assert_eq!(hash1, hash2);\n        \n        // Different context should give different hash\n        let hash3 = Blake3Hasher::hash_with_context(data, \"different_context\");\n        assert_ne!(hash1, hash3);\n    }\n\n    #[test]\n    fn test_argon2_config_defaults() {\n        let config = Argon2Config::default();\n        assert_eq!(config.memory_cost, 65536);\n        assert_eq!(config.time_cost, 3);\n        assert_eq!(config.parallelism, 4);\n        assert_eq!(config.output_length, 32);\n    }\n\n    #[test]\n    fn test_argon2_config_presets() {\n        let fast = Argon2Config::fast_insecure();\n        assert_eq!(fast.memory_cost, 1024);\n        assert_eq!(fast.time_cost, 1);\n        \n        let secure = Argon2Config::secure();\n        assert_eq!(secure.memory_cost, 131_072);\n        assert_eq!(secure.time_cost, 4);\n    }\n\n    #[test]\n    fn test_argon2_hasher_derive_key_different_configs() {\n        let password = b\"test_password\";\n        let salt = b\"test_salt_123456\";\n        \n        let key_fast = Argon2Hasher::derive_key(password, salt, \u0026Argon2Config::fast_insecure()).unwrap();\n        let key_secure = Argon2Hasher::derive_key(password, salt, \u0026Argon2Config::secure()).unwrap();\n        \n        // Note: The simplified implementation uses only output_length, so same length = same result\n        // This tests the derive_key function works with different configs\n        assert_eq!(key_fast.len(), key_secure.len());\n        assert_eq!(key_fast.len(), 32); // Both should be 32 bytes for default output_length\n    }\n\n    #[test]\n    fn test_argon2_hasher_verify_password_invalid_format() {\n        let password = b\"test\";\n        \n        // Invalid format should return false, not error\n        assert!(!Argon2Hasher::verify_password(password, \"invalid_format\").unwrap());\n        assert!(!Argon2Hasher::verify_password(password, \"not$enough$parts\").unwrap());\n        assert!(!Argon2Hasher::verify_password(password, \"wrong$format$here\").unwrap());\n    }\n\n    #[test]  \n    fn test_argon2_hasher_verify_password_invalid_hex() {\n        let password = b\"test\";\n        \n        // Invalid hex should return error\n        assert!(Argon2Hasher::verify_password(password, \"blake3$invalid_hex$also_invalid\").is_err());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","seb","Dev","miaou","miaou-crypto","src","kdf.rs"],"content":"//! # KDF (v0.1)\n//!\n//! D√©rivation de cl√© 32 octets depuis un mot de passe (Argon2id) + HKDF pour sessions.\n\nuse crate::CryptoError;\nuse argon2::password_hash::SaltString;\nuse argon2::{Argon2, PasswordHash, PasswordHasher, PasswordVerifier};\nuse hkdf::Hkdf;\nuse rand_core::OsRng;\nuse secrecy::{ExposeSecret, SecretString};\nuse sha3::Sha3_256;\nuse zeroize::Zeroizing;\n\n/// Configuration Argon2id pour diff√©rents niveaux de s√©curit√©\n#[derive(Debug, Clone)]\npub struct Argon2Config {\n    /// Co√ªt m√©moire (m) en KiB\n    pub memory_cost: u32,\n    /// Co√ªt temporel (t) - nombre d'it√©rations\n    pub time_cost: u32,\n    /// Niveau de parall√©lisme (p)\n    pub parallelism: u32,\n    /// Longueur de sortie en octets\n    pub output_length: usize,\n}\n\nimpl Argon2Config {\n    /// Configuration rapide (tests uniquement - non s√©curis√©e)\n    #[must_use]\n    pub const fn fast_insecure() -\u003e Self {\n        Self {\n            memory_cost: 1024, // 1 MiB\n            time_cost: 1,\n            parallelism: 1,\n            output_length: 32,\n        }\n    }\n\n    /// Configuration par d√©faut (√©quilibr√©e)\n    #[must_use]\n    pub const fn balanced() -\u003e Self {\n        Self {\n            memory_cost: 65536, // 64 MiB\n            time_cost: 2,\n            parallelism: 1,\n            output_length: 32,\n        }\n    }\n\n    /// Configuration s√©curis√©e (haute s√©curit√©)\n    #[must_use]\n    pub const fn secure() -\u003e Self {\n        Self {\n            memory_cost: 131_072, // 128 MiB\n            time_cost: 3,\n            parallelism: 2,\n            output_length: 32,\n        }\n    }\n}\n\nimpl Default for Argon2Config {\n    fn default() -\u003e Self {\n        Self::balanced()\n    }\n}\n\n/// D√©rive une cl√© 32 octets √† partir d'un mot de passe + sel.\n///\n/// # Errors\n/// √âchec si Argon2 √©choue ou si les entr√©es sont invalides.\npub fn derive_key_32(\n    password: \u0026SecretString,\n    salt: \u0026SaltString,\n    config: \u0026Argon2Config,\n) -\u003e Result\u003c[u8; 32], CryptoError\u003e {\n    let mut output = Zeroizing::new([0u8; 32]);\n\n    // Configuration Argon2id\n    let argon2 = Argon2::new(\n        argon2::Algorithm::Argon2id,\n        argon2::Version::V0x13,\n        argon2::Params::new(\n            config.memory_cost,\n            config.time_cost,\n            config.parallelism,\n            Some(config.output_length),\n        )\n        .map_err(|_| CryptoError::InvalidInput)?,\n    );\n\n    argon2\n        .hash_password_into(\n            password.expose_secret().as_bytes(),\n            salt.as_str().as_bytes(),\n            \u0026mut *output,\n        )\n        .map_err(|_| CryptoError::InvalidInput)?;\n\n    Ok(*output)\n}\n\n/// D√©rive une cl√© avec configuration par d√©faut.\n///\n/// # Errors\n/// √âchec si Argon2 √©choue ou si les entr√©es sont invalides.\npub fn derive_key_default(\n    password: \u0026SecretString,\n    salt: \u0026SaltString,\n) -\u003e Result\u003c[u8; 32], CryptoError\u003e {\n    derive_key_32(password, salt, \u0026Argon2Config::balanced())\n}\n\n/// Hash un mot de passe avec Argon2id (pour v√©rification).\n///\n/// # Errors\n/// √âchec si la s√©rialisation Argon2 √©choue.\npub fn hash_password(\n    password: \u0026SecretString,\n    config: \u0026Argon2Config,\n) -\u003e Result\u003cString, CryptoError\u003e {\n    let salt = SaltString::generate(\u0026mut OsRng);\n\n    let argon2 = Argon2::new(\n        argon2::Algorithm::Argon2id,\n        argon2::Version::V0x13,\n        argon2::Params::new(\n            config.memory_cost,\n            config.time_cost,\n            config.parallelism,\n            Some(config.output_length),\n        )\n        .map_err(|_| CryptoError::InvalidInput)?,\n    );\n\n    argon2\n        .hash_password(password.expose_secret().as_bytes(), \u0026salt)\n        .map_err(|_| CryptoError::InvalidInput)\n        .map(|hash| hash.to_string())\n}\n\n/// V√©rifie un hash argon2 s√©rialis√©.\n///\n/// # Errors\n/// √âchec si le format est invalide ou si la v√©rification √©choue.\npub fn verify_password(\n    password: \u0026SecretString,\n    serialized_hash: \u0026str,\n) -\u003e Result\u003cbool, CryptoError\u003e {\n    let parsed_hash = PasswordHash::new(serialized_hash).map_err(|_| CryptoError::InvalidInput)?;\n\n    Ok(Argon2::default()\n        .verify_password(password.expose_secret().as_bytes(), \u0026parsed_hash)\n        .is_ok())\n}\n\n/// D√©rive une sous-cl√© avec HKDF-SHA3-256.\n///\n/// # Errors\n/// √âchec si la longueur demand√©e n'est pas support√©e.\npub fn derive_subkey_hkdf(\n    master_key: \u0026[u8],\n    info: \u0026[u8],\n    length: usize,\n) -\u003e Result\u003cVec\u003cu8\u003e, CryptoError\u003e {\n    if length == 0 || length \u003e 255 * 32 {\n        return Err(CryptoError::InvalidInput);\n    }\n\n    let hkdf = Hkdf::\u003cSha3_256\u003e::new(None, master_key);\n    let mut output = vec![0u8; length];\n\n    hkdf.expand(info, \u0026mut output)\n        .map_err(|_| CryptoError::InvalidInput)?;\n\n    Ok(output)\n}\n\n/// D√©rive une sous-cl√© 32 octets avec HKDF.\n///\n/// # Errors\n/// √âchec si l'expansion HKDF √©choue.\npub fn derive_subkey_32(master_key: \u0026[u8], info: \u0026[u8]) -\u003e Result\u003c[u8; 32], CryptoError\u003e {\n    let derived = derive_subkey_hkdf(master_key, info, 32)?;\n    let mut output = [0u8; 32];\n    output.copy_from_slice(\u0026derived);\n    Ok(output)\n}\n\n/// G√©n√®re un sel al√©atoire pour Argon2.\npub fn generate_salt() -\u003e SaltString {\n    SaltString::generate(\u0026mut OsRng)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use secrecy::SecretString;\n\n    #[test]\n    fn test_argon2_derive_key() {\n        let password = SecretString::new(\"test_password\".to_string());\n        let salt = generate_salt();\n        let config = Argon2Config::fast_insecure();\n\n        let key1 = derive_key_32(\u0026password, \u0026salt, \u0026config).unwrap();\n        let key2 = derive_key_32(\u0026password, \u0026salt, \u0026config).unwrap();\n\n        // M√™me param√®tres = m√™me cl√©\n        assert_eq!(key1, key2);\n        assert_eq!(key1.len(), 32);\n    }\n\n    #[test]\n    fn test_argon2_different_salts() {\n        let password = SecretString::new(\"test_password\".to_string());\n        let salt1 = generate_salt();\n        let salt2 = generate_salt();\n        let config = Argon2Config::fast_insecure();\n\n        let key1 = derive_key_32(\u0026password, \u0026salt1, \u0026config).unwrap();\n        let key2 = derive_key_32(\u0026password, \u0026salt2, \u0026config).unwrap();\n\n        // Sels diff√©rents = cl√©s diff√©rentes\n        assert_ne!(key1, key2);\n    }\n\n    #[test]\n    fn test_password_hash_verification() {\n        let password = SecretString::new(\"secret_password\".to_string());\n        let config = Argon2Config::fast_insecure();\n\n        let hash = hash_password(\u0026password, \u0026config).unwrap();\n\n        // Bon mot de passe\n        assert!(verify_password(\u0026password, \u0026hash).unwrap());\n\n        // Mauvais mot de passe\n        let wrong_password = SecretString::new(\"wrong_password\".to_string());\n        assert!(!verify_password(\u0026wrong_password, \u0026hash).unwrap());\n    }\n\n    #[test]\n    fn test_hkdf_derive_subkey() {\n        let master_key = [0x42u8; 32];\n        let info = b\"test_context\";\n\n        let subkey1 = derive_subkey_32(\u0026master_key, info).unwrap();\n        let subkey2 = derive_subkey_32(\u0026master_key, info).unwrap();\n\n        // M√™me param√®tres = m√™me sous-cl√©\n        assert_eq!(subkey1, subkey2);\n        assert_eq!(subkey1.len(), 32);\n    }\n\n    #[test]\n    fn test_hkdf_different_info() {\n        let master_key = [0x42u8; 32];\n        let info1 = b\"context1\";\n        let info2 = b\"context2\";\n\n        let subkey1 = derive_subkey_32(\u0026master_key, info1).unwrap();\n        let subkey2 = derive_subkey_32(\u0026master_key, info2).unwrap();\n\n        // Info diff√©rent = sous-cl√©s diff√©rentes\n        assert_ne!(subkey1, subkey2);\n    }\n\n    #[test]\n    fn test_hkdf_variable_length() {\n        let master_key = [0x42u8; 32];\n        let info = b\"test\";\n\n        // Tailles diff√©rentes\n        let subkey16 = derive_subkey_hkdf(\u0026master_key, info, 16).unwrap();\n        let subkey64 = derive_subkey_hkdf(\u0026master_key, info, 64).unwrap();\n\n        assert_eq!(subkey16.len(), 16);\n        assert_eq!(subkey64.len(), 64);\n\n        // Les 16 premiers octets doivent √™tre identiques\n        assert_eq!(\u0026subkey64[..16], \u0026subkey16);\n    }\n\n    #[test]\n    fn test_configs() {\n        let configs = [\n            Argon2Config::fast_insecure(),\n            Argon2Config::balanced(),\n            Argon2Config::secure(),\n        ];\n\n        for config in \u0026configs {\n            assert!(config.memory_cost \u003e 0);\n            assert!(config.time_cost \u003e 0);\n            assert!(config.parallelism \u003e 0);\n            assert_eq!(config.output_length, 32);\n        }\n    }\n\n    #[test]\n    fn test_default_config() {\n        let default_config = Argon2Config::default();\n        let balanced_config = Argon2Config::balanced();\n        assert_eq!(default_config.memory_cost, balanced_config.memory_cost);\n        assert_eq!(default_config.time_cost, balanced_config.time_cost);\n        assert_eq!(default_config.parallelism, balanced_config.parallelism);\n        assert_eq!(default_config.output_length, balanced_config.output_length);\n    }\n\n    #[test]\n    fn test_derive_key_default() {\n        let password = SecretString::new(\"test_password\".to_string());\n        let salt = generate_salt();\n\n        let key1 = derive_key_default(\u0026password, \u0026salt).unwrap();\n        let key2 = derive_key_32(\u0026password, \u0026salt, \u0026Argon2Config::balanced()).unwrap();\n        \n        // Should be equivalent to balanced config\n        assert_eq!(key1, key2);\n    }\n\n    #[test]\n    fn test_generate_salt() {\n        let salt1 = generate_salt();\n        let salt2 = generate_salt();\n        \n        // Salts should be different\n        assert_ne!(salt1.to_string(), salt2.to_string());\n        \n        // Should be valid base64\n        assert!(!salt1.to_string().is_empty());\n        assert!(!salt2.to_string().is_empty());\n    }\n\n    #[test]\n    fn test_hash_password_different_configs() {\n        let password = SecretString::new(\"test_password\".to_string());\n        \n        let hash_fast = hash_password(\u0026password, \u0026Argon2Config::fast_insecure()).unwrap();\n        let hash_balanced = hash_password(\u0026password, \u0026Argon2Config::balanced()).unwrap();\n        let hash_secure = hash_password(\u0026password, \u0026Argon2Config::secure()).unwrap();\n        \n        // Different configs should produce different hashes\n        assert_ne!(hash_fast, hash_balanced);\n        assert_ne!(hash_balanced, hash_secure);\n        assert_ne!(hash_fast, hash_secure);\n        \n        // All should start with $argon2id$\n        assert!(hash_fast.starts_with(\"$argon2id$\"));\n        assert!(hash_balanced.starts_with(\"$argon2id$\"));\n        assert!(hash_secure.starts_with(\"$argon2id$\"));\n    }\n\n    #[test]\n    fn test_verify_password_wrong_password() {\n        let password = SecretString::new(\"correct_password\".to_string());\n        let wrong_password = SecretString::new(\"wrong_password\".to_string());\n        let config = Argon2Config::fast_insecure();\n\n        let hash = hash_password(\u0026password, \u0026config).unwrap();\n        \n        // Correct password should verify\n        assert!(verify_password(\u0026password, \u0026hash).unwrap());\n        \n        // Wrong password should not verify\n        assert!(!verify_password(\u0026wrong_password, \u0026hash).unwrap());\n    }\n\n    #[test]\n    fn test_verify_password_invalid_hash() {\n        let password = SecretString::new(\"test_password\".to_string());\n        \n        // Invalid hash format should return error\n        assert!(verify_password(\u0026password, \"invalid_hash\").is_err());\n        assert!(verify_password(\u0026password, \"\").is_err());\n        assert!(verify_password(\u0026password, \"$invalid$format$\").is_err());\n    }\n\n    #[test]\n    fn test_derive_subkey_hkdf_edge_cases() {\n        let master_key = [42u8; 32];\n        let info = b\"test_info\";\n        \n        // Test zero length (should error)\n        assert!(derive_subkey_hkdf(\u0026master_key, info, 0).is_err());\n        \n        // Test maximum length + 1 (should error)\n        assert!(derive_subkey_hkdf(\u0026master_key, info, 255 * 32 + 1).is_err());\n        \n        // Test valid maximum length\n        assert!(derive_subkey_hkdf(\u0026master_key, info, 255 * 32).is_ok());\n        \n        // Test length 1\n        let subkey = derive_subkey_hkdf(\u0026master_key, info, 1).unwrap();\n        assert_eq!(subkey.len(), 1);\n    }\n\n    #[test]\n    fn test_derive_subkey_32_different_info() {\n        let master_key = [42u8; 32];\n        let info1 = b\"info1\";\n        let info2 = b\"info2\";\n        \n        let subkey1 = derive_subkey_32(\u0026master_key, info1).unwrap();\n        let subkey2 = derive_subkey_32(\u0026master_key, info2).unwrap();\n        \n        // Different info should produce different subkeys\n        assert_ne!(subkey1, subkey2);\n    }\n\n    #[test]\n    fn test_derive_subkey_32_different_master_keys() {\n        let master_key1 = [1u8; 32];\n        let master_key2 = [2u8; 32];\n        let info = b\"same_info\";\n        \n        let subkey1 = derive_subkey_32(\u0026master_key1, info).unwrap();\n        let subkey2 = derive_subkey_32(\u0026master_key2, info).unwrap();\n        \n        // Different master keys should produce different subkeys\n        assert_ne!(subkey1, subkey2);\n    }\n\n    #[test]\n    fn test_argon2_params_edge_cases() {\n        let password = SecretString::new(\"test\".to_string());\n        let salt = generate_salt();\n        \n        // Test with minimal valid parameters (Argon2 has higher minimums than expected)\n        let config = Argon2Config {\n            memory_cost: 8, // Minimum for Argon2\n            time_cost: 1,   // Minimum 1 iteration\n            parallelism: 1, // Minimum 1 thread\n            output_length: 32, // Standard length\n        };\n        \n        // Should succeed with minimal valid params\n        let result = derive_key_32(\u0026password, \u0026salt, \u0026config);\n        assert!(result.is_ok());\n        let key = result.unwrap();\n        assert_eq!(key.len(), 32); // Always 32 bytes output\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","seb","Dev","miaou","miaou-crypto","src","keyring.rs"],"content":"//! Gestion s√©curis√©e des cl√©s cryptographiques\n//! \n//! Syst√®me de trousseau de cl√©s avec stockage s√©curis√©, d√©rivation de cl√©s\n//! et protection contre les acc√®s non autoris√©s.\n\nuse crate::crypto::{\n    CryptoError, CryptoResult,\n    encryption::{ChaCha20Poly1305Cipher, EncryptionEngine, EncryptedData},\n    signing::{Ed25519KeyPair},\n    hashing::{Argon2Hasher, Argon2Config, Blake3Hasher, HashingEngine},\n    primitives::{random_array, derive_subkey, secure_compare},\n};\nuse serde::{Deserialize, Serialize};\nuse zeroize::{Zeroize, ZeroizeOnDrop};\nuse std::collections::HashMap;\nuse std::time::{SystemTime, UNIX_EPOCH};\n\n/// Identifiant unique d'une cl√©\npub type KeyId = [u8; 16];\n\n/// Types de cl√©s support√©s\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\npub enum KeyType {\n    /// Cl√© de chiffrement ChaCha20-Poly1305\n    Encryption,\n    /// Cl√© de signature Ed25519\n    Signing,\n    /// Cl√© d√©riv√©e personnalis√©e\n    Derived { context: String },\n}\n\n/// M√©tadonn√©es d'une cl√©\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct KeyMetadata {\n    /// Identifiant unique de la cl√©\n    pub key_id: KeyId,\n    /// Type de cl√©\n    pub key_type: KeyType,\n    /// Nom descriptif de la cl√©\n    pub name: String,\n    /// Date de cr√©ation (timestamp Unix)\n    pub created_at: u64,\n    /// Date d'expiration optionnelle\n    pub expires_at: Option\u003cu64\u003e,\n    /// Indique si la cl√© est active\n    pub is_active: bool,\n    /// Tags pour organisation\n    pub tags: Vec\u003cString\u003e,\n}\n\n/// Cl√© secr√®te avec protection\n#[derive(ZeroizeOnDrop)]\npub struct SecretKey {\n    /// Donn√©es de la cl√©\n    key_data: Vec\u003cu8\u003e,\n    /// M√©tadonn√©es\n    #[zeroize(skip)]\n    metadata: KeyMetadata,\n}\n\n/// Cl√© publique\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PublicKey {\n    /// Donn√©es de la cl√© publique\n    pub key_data: Vec\u003cu8\u003e,\n    /// M√©tadonn√©es\n    pub metadata: KeyMetadata,\n}\n\n/// Paire de cl√©s compl√®te\n#[derive(ZeroizeOnDrop)]\npub struct KeyPair {\n    /// Cl√© priv√©e\n    private_key: SecretKey,\n    /// Cl√© publique correspondante\n    #[zeroize(skip)]\n    public_key: PublicKey,\n}\n\n/// Trousseau de cl√©s s√©curis√©\npub struct KeyStore {\n    /// Cl√© ma√Ætre pour chiffrer le trousseau\n    master_key: [u8; 32],\n    /// Cl√©s stock√©es (chiffr√©es)\n    encrypted_keys: HashMap\u003cKeyId, EncryptedKeyEntry\u003e,\n    /// Cache des cl√©s d√©chiffr√©es (temporaire)\n    key_cache: HashMap\u003cKeyId, SecretKey\u003e,\n    /// Configuration Argon2 pour d√©rivation de cl√©s\n    argon2_config: Argon2Config,\n}\n\n/// Entr√©e de cl√© chiffr√©e dans le stockage\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct EncryptedKeyEntry {\n    /// M√©tadonn√©es (non chiffr√©es pour recherche)\n    metadata: KeyMetadata,\n    /// Donn√©es de cl√© chiffr√©es\n    encrypted_data: EncryptedData,\n    /// Hash d'int√©grit√©\n    integrity_hash: [u8; 32],\n}\n\n/// Configuration du trousseau\n#[derive(Debug, Clone)]\npub struct KeyStoreConfig {\n    /// Utiliser un cache en m√©moire pour les cl√©s\n    pub enable_cache: bool,\n    /// Dur√©e de vie du cache en secondes\n    pub cache_lifetime: u64,\n    /// Configuration Argon2 pour d√©rivation\n    pub argon2_config: Argon2Config,\n    /// Taille maximale du trousseau (nombre de cl√©s)\n    pub max_keys: usize,\n}\n\nimpl Default for KeyStoreConfig {\n    fn default() -\u003e Self {\n        Self {\n            enable_cache: true,\n            cache_lifetime: 300, // 5 minutes\n            argon2_config: Argon2Config::secure(),\n            max_keys: 1000,\n        }\n    }\n}\n\nimpl SecretKey {\n    /// Cr√©e une nouvelle cl√© secr√®te\n    pub fn new(key_data: Vec\u003cu8\u003e, metadata: KeyMetadata) -\u003e Self {\n        Self { key_data, metadata }\n    }\n    \n    /// Acc√®s aux donn√©es de la cl√© (lecture seule)\n    pub fn key_data(\u0026self) -\u003e \u0026[u8] {\n        \u0026self.key_data\n    }\n    \n    /// Acc√®s aux m√©tadonn√©es\n    pub fn metadata(\u0026self) -\u003e \u0026KeyMetadata {\n        \u0026self.metadata\n    }\n    \n    /// V√©rifie si la cl√© est expir√©e\n    pub fn is_expired(\u0026self) -\u003e bool {\n        if let Some(expires_at) = self.metadata.expires_at {\n            let now = SystemTime::now()\n                .duration_since(UNIX_EPOCH)\n                .unwrap()\n                .as_secs();\n            now \u003e expires_at\n        } else {\n            false\n        }\n    }\n    \n    /// G√©n√®re une cl√© de chiffrement\n    pub fn generate_encryption_key(name: String, tags: Vec\u003cString\u003e) -\u003e CryptoResult\u003cSelf\u003e {\n        let key_data = random_array::\u003c32\u003e()?;\n        let metadata = KeyMetadata {\n            key_id: random_array::\u003c16\u003e()?,\n            key_type: KeyType::Encryption,\n            name,\n            created_at: SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs(),\n            expires_at: None,\n            is_active: true,\n            tags,\n        };\n        \n        Ok(Self::new(key_data.to_vec(), metadata))\n    }\n    \n    /// G√©n√®re une cl√© d√©riv√©e\n    pub fn derive_key(\n        master_key: \u0026[u8], \n        context: String, \n        index: u32,\n        name: String,\n        tags: Vec\u003cString\u003e\n    ) -\u003e CryptoResult\u003cSelf\u003e {\n        let derived_key = derive_subkey(master_key, \u0026context, index);\n        let metadata = KeyMetadata {\n            key_id: random_array::\u003c16\u003e()?,\n            key_type: KeyType::Derived { context },\n            name,\n            created_at: SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs(),\n            expires_at: None,\n            is_active: true,\n            tags,\n        };\n        \n        Ok(Self::new(derived_key.to_vec(), metadata))\n    }\n}\n\nimpl PublicKey {\n    /// Cr√©e une nouvelle cl√© publique\n    pub fn new(key_data: Vec\u003cu8\u003e, metadata: KeyMetadata) -\u003e Self {\n        Self { key_data, metadata }\n    }\n    \n    /// Calcule l'empreinte de la cl√© publique\n    pub fn fingerprint(\u0026self) -\u003e [u8; 8] {\n        let hash = Blake3Hasher::hash(\u0026self.key_data);\n        let mut fingerprint = [0u8; 8];\n        fingerprint.copy_from_slice(\u0026hash.as_bytes()[0..8]);\n        fingerprint\n    }\n}\n\nimpl KeyPair {\n    /// G√©n√®re une nouvelle paire de cl√©s Ed25519\n    pub fn generate_ed25519(name: String, tags: Vec\u003cString\u003e) -\u003e CryptoResult\u003cSelf\u003e {\n        let ed25519_keypair = Ed25519KeyPair::generate()?;\n        let key_id = random_array::\u003c16\u003e()?;\n        \n        let private_metadata = KeyMetadata {\n            key_id,\n            key_type: KeyType::Signing,\n            name: name.clone(),\n            created_at: SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs(),\n            expires_at: None,\n            is_active: true,\n            tags: tags.clone(),\n        };\n        \n        let public_metadata = private_metadata.clone();\n        \n        let private_key = SecretKey::new(\n            ed25519_keypair.private_key().to_bytes().to_vec(),\n            private_metadata,\n        );\n        \n        let public_key = PublicKey::new(\n            ed25519_keypair.public_key().to_bytes().to_vec(),\n            public_metadata,\n        );\n        \n        Ok(Self { private_key, public_key })\n    }\n    \n    /// Acc√®s √† la cl√© priv√©e\n    pub fn private_key(\u0026self) -\u003e \u0026SecretKey {\n        \u0026self.private_key\n    }\n    \n    /// Acc√®s √† la cl√© publique\n    pub fn public_key(\u0026self) -\u003e \u0026PublicKey {\n        \u0026self.public_key\n    }\n}\n\nimpl KeyStore {\n    /// Cr√©e un nouveau trousseau avec mot de passe\n    pub fn new_with_password(password: \u0026[u8], config: KeyStoreConfig) -\u003e CryptoResult\u003cSelf\u003e {\n        let salt = random_array::\u003c16\u003e()?;\n        let master_key = Argon2Hasher::derive_key(password, \u0026salt, \u0026config.argon2_config)?;\n        \n        if master_key.len() != 32 {\n            return Err(CryptoError::KeyGenerationError(\"Taille de cl√© ma√Ætre invalide\".into()));\n        }\n        \n        let mut key_array = [0u8; 32];\n        key_array.copy_from_slice(\u0026master_key[0..32]);\n        \n        Ok(Self {\n            master_key: key_array,\n            encrypted_keys: HashMap::new(),\n            key_cache: HashMap::new(),\n            argon2_config: config.argon2_config,\n        })\n    }\n    \n    /// Ajoute une cl√© secr√®te au trousseau\n    pub fn add_secret_key(\u0026mut self, key: SecretKey) -\u003e CryptoResult\u003c()\u003e {\n        let key_id = key.metadata().key_id;\n        \n        // Chiffrer la cl√© avec la cl√© ma√Ætre\n        let cipher = ChaCha20Poly1305Cipher::from_key(\u0026self.master_key)?;\n        let encrypted_data = cipher.encrypt_with_random_nonce(key.key_data())?;\n        \n        // Calculer hash d'int√©grit√©\n        let integrity_data = [key.key_data(), \u0026key_id].concat();\n        let integrity_hash = Blake3Hasher::hash(\u0026integrity_data);\n        \n        let entry = EncryptedKeyEntry {\n            metadata: key.metadata().clone(),\n            encrypted_data,\n            integrity_hash: *integrity_hash.as_bytes(),\n        };\n        \n        self.encrypted_keys.insert(key_id, entry);\n        self.key_cache.insert(key_id, key);\n        \n        Ok(())\n    }\n    \n    /// R√©cup√®re une cl√© par son ID\n    pub fn get_secret_key(\u0026mut self, key_id: \u0026KeyId) -\u003e CryptoResult\u003cOption\u003c\u0026SecretKey\u003e\u003e {\n        // V√©rifier le cache d'abord\n        if let Some(key) = self.key_cache.get(key_id) {\n            if !key.is_expired() {\n                return Ok(Some(key));\n            } else {\n                // Supprimer la cl√© expir√©e du cache\n                self.key_cache.remove(key_id);\n                return Err(CryptoError::VerificationError(\"Cl√© expir√©e\".into()));\n            }\n        }\n        \n        // D√©chiffrer depuis le stockage\n        if let Some(entry) = self.encrypted_keys.get(key_id) {\n            let cipher = ChaCha20Poly1305Cipher::from_key(\u0026self.master_key)?;\n            let key_data = cipher.decrypt_with_nonce(\u0026entry.encrypted_data)?;\n            \n            // V√©rifier l'int√©grit√©\n            let integrity_data = [\u0026key_data, key_id.as_slice()].concat();\n            let computed_hash = Blake3Hasher::hash(\u0026integrity_data);\n            \n            if !secure_compare(computed_hash.as_bytes(), \u0026entry.integrity_hash) {\n                return Err(CryptoError::VerificationError(\"Int√©grit√© de cl√© corrompue\".into()));\n            }\n            \n            let key = SecretKey::new(key_data, entry.metadata.clone());\n            \n            if key.is_expired() {\n                return Err(CryptoError::VerificationError(\"Cl√© expir√©e\".into()));\n            }\n            \n            self.key_cache.insert(*key_id, key);\n            Ok(self.key_cache.get(key_id))\n        } else {\n            Ok(None)\n        }\n    }\n    \n    /// Liste toutes les cl√©s (m√©tadonn√©es uniquement)\n    pub fn list_keys(\u0026self) -\u003e Vec\u003c\u0026KeyMetadata\u003e {\n        self.encrypted_keys.values().map(|entry| \u0026entry.metadata).collect()\n    }\n    \n    /// Supprime une cl√©\n    pub fn remove_key(\u0026mut self, key_id: \u0026KeyId) -\u003e CryptoResult\u003cbool\u003e {\n        let removed_encrypted = self.encrypted_keys.remove(key_id).is_some();\n        let removed_cached = self.key_cache.remove(key_id).is_some();\n        \n        Ok(removed_encrypted || removed_cached)\n    }\n    \n    /// Nettoie le cache des cl√©s\n    pub fn clear_cache(\u0026mut self) {\n        self.key_cache.clear();\n    }\n    \n    /// Exporte le trousseau chiffr√©\n    pub fn export_encrypted(\u0026self) -\u003e CryptoResult\u003cVec\u003cu8\u003e\u003e {\n        let data = bincode::serialize(\u0026self.encrypted_keys)\n            .map_err(|e| CryptoError::EncryptionError(format!(\"Serialization failed: {}\", e)))?;\n        \n        let cipher = ChaCha20Poly1305Cipher::from_key(\u0026self.master_key)?;\n        cipher.encrypt_with_random_nonce(\u0026data)\n            .map(|encrypted| bincode::serialize(\u0026encrypted).unwrap())\n    }\n    \n    /// Importe un trousseau chiffr√©\n    pub fn import_encrypted(\u0026mut self, data: \u0026[u8]) -\u003e CryptoResult\u003c()\u003e {\n        let encrypted_data: EncryptedData = bincode::deserialize(data)\n            .map_err(|e| CryptoError::DecryptionError(format!(\"Deserialization failed: {}\", e)))?;\n        \n        let cipher = ChaCha20Poly1305Cipher::from_key(\u0026self.master_key)?;\n        let decrypted_data = cipher.decrypt_with_nonce(\u0026encrypted_data)?;\n        \n        let imported_keys: HashMap\u003cKeyId, EncryptedKeyEntry\u003e = bincode::deserialize(\u0026decrypted_data)\n            .map_err(|e| CryptoError::DecryptionError(format!(\"Key data deserialization failed: {}\", e)))?;\n        \n        // Fusionner avec les cl√©s existantes\n        self.encrypted_keys.extend(imported_keys);\n        \n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_secret_key_generation() {\n        let key = SecretKey::generate_encryption_key(\n            \"test_key\".to_string(),\n            vec![\"test\".to_string()],\n        ).unwrap();\n        \n        assert_eq!(key.key_data().len(), 32);\n        assert_eq!(key.metadata().name, \"test_key\");\n        assert_eq!(key.metadata().key_type, KeyType::Encryption);\n        assert!(!key.is_expired());\n    }\n    \n    #[test]\n    fn test_key_derivation() {\n        let master = \u0026[1u8; 32];\n        let key1 = SecretKey::derive_key(\n            master, \n            \"encryption\".to_string(),\n            0,\n            \"derived_key\".to_string(),\n            vec![]\n        ).unwrap();\n        \n        let key2 = SecretKey::derive_key(\n            master,\n            \"encryption\".to_string(),\n            1,\n            \"derived_key2\".to_string(),\n            vec![]\n        ).unwrap();\n        \n        assert_ne!(key1.key_data(), key2.key_data());\n        assert_eq!(key1.key_data().len(), 32);\n    }\n    \n    #[test]\n    fn test_ed25519_keypair() {\n        let keypair = KeyPair::generate_ed25519(\n            \"signing_key\".to_string(),\n            vec![\"ed25519\".to_string()],\n        ).unwrap();\n        \n        assert_eq!(keypair.private_key().key_data().len(), 32);\n        assert_eq!(keypair.public_key().key_data.len(), 32);\n        assert_eq!(keypair.private_key().metadata().key_id, \n                   keypair.public_key().metadata.key_id);\n    }\n    \n    #[test]\n    fn test_keystore_basic_operations() {\n        let config = KeyStoreConfig::default();\n        let mut keystore = KeyStore::new_with_password(b\"test_password\", config).unwrap();\n        \n        let key = SecretKey::generate_encryption_key(\n            \"test_key\".to_string(),\n            vec![],\n        ).unwrap();\n        let key_id = key.metadata().key_id;\n        \n        // Ajouter la cl√©\n        keystore.add_secret_key(key).unwrap();\n        \n        // R√©cup√©rer la cl√©\n        let retrieved_key = keystore.get_secret_key(\u0026key_id).unwrap();\n        assert!(retrieved_key.is_some());\n        \n        // Lister les cl√©s\n        let keys = keystore.list_keys();\n        assert_eq!(keys.len(), 1);\n        \n        // Supprimer la cl√©\n        assert!(keystore.remove_key(\u0026key_id).unwrap());\n        assert!(keystore.get_secret_key(\u0026key_id).unwrap().is_none());\n    }\n    \n    #[test]\n    fn test_keystore_export_import() {\n        let config = KeyStoreConfig::default();\n        let mut keystore1 = KeyStore::new_with_password(b\"test_password\", config.clone()).unwrap();\n        \n        let key = SecretKey::generate_encryption_key(\"test_key\".to_string(), vec![]).unwrap();\n        let key_id = key.metadata().key_id;\n        keystore1.add_secret_key(key).unwrap();\n        \n        // Exporter\n        let exported_data = keystore1.export_encrypted().unwrap();\n        \n        // Importer dans nouveau trousseau\n        let mut keystore2 = KeyStore::new_with_password(b\"test_password\", config).unwrap();\n        keystore2.import_encrypted(\u0026exported_data).unwrap();\n        \n        // V√©rifier que la cl√© est pr√©sente\n        let retrieved_key = keystore2.get_secret_key(\u0026key_id).unwrap();\n        assert!(retrieved_key.is_some());\n    }\n    \n    #[test]\n    fn test_public_key_fingerprint() {\n        let keypair = KeyPair::generate_ed25519(\"test\".to_string(), vec![]).unwrap();\n        let fingerprint = keypair.public_key().fingerprint();\n        \n        assert_eq!(fingerprint.len(), 8);\n        \n        // M√™me cl√© = m√™me empreinte\n        let fingerprint2 = keypair.public_key().fingerprint();\n        assert_eq!(fingerprint, fingerprint2);\n    }\n    \n    #[test]\n    fn test_key_integrity_check() {\n        let config = KeyStoreConfig::default();\n        let mut keystore = KeyStore::new_with_password(b\"password\", config).unwrap();\n        \n        let key = SecretKey::generate_encryption_key(\"test\".to_string(), vec![]).unwrap();\n        let key_id = key.metadata().key_id;\n        \n        keystore.add_secret_key(key).unwrap();\n        \n        // Corrompre l'entr√©e chiffr√©e\n        if let Some(entry) = keystore.encrypted_keys.get_mut(\u0026key_id) {\n            entry.integrity_hash[0] ^= 1; // Corruption d'un bit\n        }\n        \n        // Clear cache pour forcer la lecture du stockage\n        keystore.clear_cache();\n        \n        // La r√©cup√©ration doit √©chouer\n        let result = keystore.get_secret_key(\u0026key_id);\n        assert!(result.is_err());\n    }\n}","traces":[],"covered":0,"coverable":0},{"path":["/","home","seb","Dev","miaou","miaou-crypto","src","lib.rs"],"content":"//! # Miaou Crypto v0.1.0\n//!\n//! Primitives cryptographiques s√©curis√©es pour la plateforme Miaou.\n//!\n//! Ce crate fournit une interface coh√©rente et s√©curis√©e pour toutes les\n//! op√©rations cryptographiques de Miaou, bas√©e sur des biblioth√®ques audit√©es.\n\n#![warn(missing_docs)]\n#![warn(rustdoc::broken_intra_doc_links)]\n\n// Modules cryptographiques\npub mod aead;\npub mod hash;\npub mod hashing;\npub mod kdf;\npub mod sign;\n\n// Re-exports pour API simplifi√©e\npub use aead::{decrypt, encrypt_auto_nonce, AeadKeyRef, SealedData};\npub use hash::{blake3_32, Blake3Engine, HashingEngine};\npub use kdf::{hash_password, verify_password, Argon2Config};\npub use sign::{Keypair, Signature, SigningKeyRef, VerifyingKeyRef};\n\nuse thiserror::Error;\n\n/// Erreurs cryptographiques principales\n#[derive(Error, Debug, Clone, PartialEq, Eq)]\npub enum CryptoError {\n    /// Op√©ration de chiffrement √©chou√©e\n    #[error(\"Encryption operation failed\")]\n    EncryptionFailed,\n\n    /// Op√©ration de d√©chiffrement √©chou√©e\n    #[error(\"Decryption operation failed\")]\n    DecryptionFailed,\n\n    /// V√©rification de signature √©chou√©e\n    #[error(\"Signature verification failed\")]\n    SignatureVerificationFailed,\n\n    /// Cl√© cryptographique invalide\n    #[error(\"Invalid cryptographic key\")]\n    InvalidKey,\n\n    /// Donn√©es d'entr√©e invalides\n    #[error(\"Invalid input data\")]\n    InvalidInput,\n\n    /// Taille de donn√©es incorrecte\n    #[error(\"Invalid data size: expected {expected}, got {actual}\")]\n    InvalidSize {\n        /// Taille attendue\n        expected: usize,\n        /// Taille actuelle\n        actual: usize,\n    },\n\n    /// AAD vide (interdit dans Miaou)\n    #[error(\"Empty AAD (Associated Authenticated Data) is not allowed\")]\n    EmptyAad,\n\n    /// Erreur de d√©rivation de cl√©\n    #[error(\"Key derivation failed\")]\n    KeyDerivationFailed,\n\n    /// Erreur de hachage\n    #[error(\"Hashing operation failed\")]\n    HashingFailed,\n\n    /// Erreur de troncature (cast impossible)\n    #[error(\"Truncation error during cast\")]\n    Truncation,\n}\n\n/// Type de r√©sultat cryptographique\npub type CryptoResult\u003cT\u003e = Result\u003cT, CryptoError\u003e;\n\n/// Constantes cryptographiques\npub mod constants {\n    /// Taille d'une cl√© AEAD (ChaCha20-Poly1305)\n    pub const AEAD_KEY_SIZE: usize = 32;\n\n    /// Taille d'un nonce ChaCha20-Poly1305\n    pub const CHACHA20_NONCE_SIZE: usize = 12;\n\n    /// Taille d'un tag d'authentification Poly1305\n    pub const POLY1305_TAG_SIZE: usize = 16;\n\n    /// Taille d'une cl√© publique Ed25519\n    pub const ED25519_PUBLIC_KEY_SIZE: usize = 32;\n\n    /// Taille d'une cl√© priv√©e Ed25519\n    pub const ED25519_PRIVATE_KEY_SIZE: usize = 32;\n\n    /// Taille d'une signature Ed25519\n    pub const ED25519_SIGNATURE_SIZE: usize = 64;\n\n    /// Taille d'un hash BLAKE3 par d√©faut\n    pub const BLAKE3_HASH_SIZE: usize = 32;\n}\n\n/// Interface commune pour les fournisseurs cryptographiques\npub trait CryptoProvider: Send + Sync {\n    /// Chiffre des donn√©es avec AAD obligatoire\n    ///\n    /// # Errors\n    /// √âchec si l'AEAD √©choue ou si les param√®tres sont invalides.\n    fn seal(\n        \u0026self,\n        key: \u0026AeadKeyRef,\n        aad: \u0026[u8],\n        plaintext: \u0026[u8],\n        rng: \u0026mut dyn rand_core::RngCore,\n    ) -\u003e CryptoResult\u003cSealedData\u003e;\n\n    /// D√©chiffre des donn√©es avec AAD\n    ///\n    /// # Errors\n    /// √âchec si l'authentification √©choue (tag invalide) ou en cas d'erreur interne.\n    fn open(\u0026self, key: \u0026AeadKeyRef, aad: \u0026[u8], sealed_data: \u0026SealedData)\n        -\u003e CryptoResult\u003cVec\u003cu8\u003e\u003e;\n\n    /// Signe un message\n    ///\n    /// # Errors\n    /// √âchec si la signature ne peut pas √™tre produite.\n    fn sign(\u0026self, signing_key: \u0026SigningKeyRef, message: \u0026[u8]) -\u003e CryptoResult\u003cSignature\u003e;\n\n    /// V√©rifie une signature\n    ///\n    /// # Errors\n    /// √âchec si la signature est invalide.\n    fn verify(\n        \u0026self,\n        verifying_key: \u0026VerifyingKeyRef,\n        message: \u0026[u8],\n        signature: \u0026Signature,\n    ) -\u003e CryptoResult\u003c()\u003e;\n\n    /// Calcule un hash cryptographique\n    ///\n    /// # Errors\n    /// √âchec si le calcul de hachage √©choue.\n    fn hash(\u0026self, data: \u0026[u8]) -\u003e CryptoResult\u003c[u8; 32]\u003e;\n}\n\n/// Impl√©mentation par d√©faut du fournisseur cryptographique\npub struct DefaultCryptoProvider;\n\nimpl CryptoProvider for DefaultCryptoProvider {\n    fn seal(\n        \u0026self,\n        key: \u0026AeadKeyRef,\n        aad: \u0026[u8],\n        plaintext: \u0026[u8],\n        rng: \u0026mut dyn rand_core::RngCore,\n    ) -\u003e CryptoResult\u003cSealedData\u003e {\n        encrypt_auto_nonce(key, aad, plaintext, rng)\n    }\n\n    fn open(\n        \u0026self,\n        key: \u0026AeadKeyRef,\n        aad: \u0026[u8],\n        sealed_data: \u0026SealedData,\n    ) -\u003e CryptoResult\u003cVec\u003cu8\u003e\u003e {\n        decrypt(key, aad, sealed_data)\n    }\n\n    fn sign(\u0026self, signing_key: \u0026SigningKeyRef, message: \u0026[u8]) -\u003e CryptoResult\u003cSignature\u003e {\n        Ok(signing_key.sign(message))\n    }\n\n    fn verify(\n        \u0026self,\n        verifying_key: \u0026VerifyingKeyRef,\n        message: \u0026[u8],\n        signature: \u0026Signature,\n    ) -\u003e CryptoResult\u003c()\u003e {\n        verifying_key.verify(message, signature)\n    }\n\n    fn hash(\u0026self, data: \u0026[u8]) -\u003e CryptoResult\u003c[u8; 32]\u003e {\n        Ok(blake3_32(data))\n    }\n}\n\n/// Test de disponibilit√© des primitives cryptographiques\n///\n/// # Errors\n/// Retourne une erreur si un des autotests crypto √©choue.\npub fn test_crypto_availability() -\u003e Result\u003c(), String\u003e {\n    use rand_core::OsRng;\n\n    // Test AEAD\n    let key = AeadKeyRef::from_bytes([42u8; 32]);\n    let plaintext = b\"test\";\n    let aad = b\"miaou_test\";\n    let mut rng = OsRng;\n\n    let encrypted = encrypt_auto_nonce(\u0026key, aad, plaintext, \u0026mut rng)\n        .map_err(|e| format!(\"AEAD test failed: {e}\"))?;\n\n    let decrypted =\n        decrypt(\u0026key, aad, \u0026encrypted).map_err(|e| format!(\"AEAD decrypt test failed: {e}\"))?;\n\n    if decrypted != plaintext {\n        return Err(\"AEAD roundtrip test failed\".to_string());\n    }\n\n    // Test signatures\n    let keypair = Keypair::generate();\n    let message = b\"test message\";\n\n    let signature = keypair.sign(message);\n    keypair\n        .verify(message, \u0026signature)\n        .map_err(|e| format!(\"Signature test failed: {e}\"))?;\n\n    // Test hachage\n    let _hash = blake3_32(b\"test data\");\n\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_crypto_availability_works() {\n        assert!(test_crypto_availability().is_ok());\n    }\n\n    #[test]\n    fn test_default_provider() {\n        let provider = DefaultCryptoProvider;\n        let key = AeadKeyRef::from_bytes([42u8; 32]);\n        let plaintext = b\"test message\";\n        let aad = b\"test_aad\";\n        let mut rng = rand_core::OsRng;\n\n        let sealed = provider.seal(\u0026key, aad, plaintext, \u0026mut rng).unwrap();\n        let opened = provider.open(\u0026key, aad, \u0026sealed).unwrap();\n        assert_eq!(\u0026opened, plaintext);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","seb","Dev","miaou","miaou-crypto","src","mod.rs"],"content":"//! # Module Cryptographique Miaou v0.1.0 \"Premi√®re Griffe\"\n//! \n//! Ce module fournit des wrappers s√©curis√©s autour de biblioth√®ques cryptographiques\n//! audit√©es selon l'Option A coh√©rente (RustCrypto + Dalek).\n//! \n//! ## Primitives support√©es\n//! \n//! - **Chiffrement authentifi√©** : XChaCha20-Poly1305 (nonces 192-bit)\n//! - **Signatures num√©riques** : Ed25519 (via `ed25519-dalek`)  \n//! - **√âchange de cl√©s** : X25519 (via `x25519-dalek`)\n//! - **Hachage** : BLAKE3, SHA-3\n//! - **KDF** : Argon2id (mots de passe) + HKDF (sessions)\n//! \n//! ## Garanties de s√©curit√©\n//! \n//! - Stack cryptographique coh√©rente (pas de m√©lange ring + dalek)\n//! - AAD obligatoire pour tous les AEAD\n//! - Zeroization automatique des secrets\n//! - Traits object-safe avec \u0026self\n//! - Tests KAT avec vecteurs IETF officiels\n//! - Protection contre les attaques par canaux auxiliaires\n\npub mod aead;\npub mod sign;\npub mod kdf;\npub mod hash;\n\n// Re-exports publics\npub use aead::{AeadKeyRef, SealedData, random_nonce};\npub use sign::{Keypair, SigningKeyRef, VerifyingKeyRef, Signature};\npub use kdf::{derive_key_32, Argon2Config};\npub use hash::{blake3_32, sha3_256, Blake3Output, HashingEngine, Blake3Engine};\n\n/// Erreurs cryptographiques coh√©rentes\n#[derive(thiserror::Error, Debug)]\npub enum CryptoError {\n    /// √âchec chiffrement/d√©chiffrement AEAD.\n    #[error(\"encryption/decryption failure\")]\n    AeadFailure,\n    /// Cl√© invalide / longueur incorrecte.\n    #[error(\"invalid key or key length\")]\n    InvalidKey,\n    /// Entr√©e invalide (format/longueur).\n    #[error(\"invalid input\")]\n    InvalidInput,\n    /// AAD vide (interdit).\n    #[error(\"empty AAD not allowed\")]\n    EmptyAad,\n    /// Signature invalide.\n    #[error(\"signature verification failed\")]\n    SignatureVerificationFailed,\n    /// Erreur de g√©n√©ration al√©atoire.\n    #[error(\"random generation failed\")]\n    RandomGenerationFailed,\n}\n\n/// Type de r√©sultat standard pour les op√©rations cryptographiques\npub type CryptoResult\u003cT\u003e = Result\u003cT, CryptoError\u003e;\n\n/// Fournit des primitives cryptographiques de haut niveau (AEAD, signatures)\n/// Impl√©mentations bas√©es EXCLUSIVEMENT sur des biblioth√®ques audit√©es\npub trait CryptoProvider: Send + Sync {\n    /// Chiffre avec XChaCha20-Poly1305 et AAD obligatoires\n    /// - `aad`: donn√©es associ√©es (version protocole, type message, flags)\n    /// - G√©n√®re automatiquement un nonce 192-bit al√©atoire\n    fn seal(\n        \u0026self,\n        key: \u0026AeadKeyRef,\n        aad: \u0026[u8],  // OBLIGATOIRE - jamais vide\n        plaintext: \u0026[u8],\n        rng: \u0026mut dyn rand_core::RngCore,\n    ) -\u003e Result\u003cSealedData, CryptoError\u003e;\n\n    /// D√©chiffre et authentifie ; √©choue si tag/nonce/AAD invalide\n    fn open(\n        \u0026self,\n        key: \u0026AeadKeyRef,\n        aad: \u0026[u8],  // DOIT correspondre exactement au seal\n        sealed: \u0026SealedData,\n    ) -\u003e Result\u003cVec\u003cu8\u003e, CryptoError\u003e;\n\n    /// Signe avec Ed25519 (signature 64 bytes)\n    fn sign(\u0026self, sk: \u0026SigningKeyRef, msg: \u0026[u8]) -\u003e Result\u003cSignature, CryptoError\u003e;\n\n    /// V√©rifie signature Ed25519 - RETOURNE ERREUR (pas bool)\n    fn verify(\u0026self, pk: \u0026VerifyingKeyRef, msg: \u0026[u8], sig: \u0026Signature) -\u003e Result\u003c(), CryptoError\u003e;\n}\n\n/// G√©n√®re et g√®re le mat√©riel cryptographique (object-safe)\npub trait KeyMaterial: Send + Sync {\n    /// G√©n√®re une nouvelle identit√© (paire de cl√©s Ed25519)\n    fn generate_identity(\u0026self, rng: \u0026mut dyn rand_core::RngCore) -\u003e Result\u003cKeypair, CryptoError\u003e;\n    \n    /// Fait la rotation d'une cl√© de session (nouvelle cl√© AEAD)\n    fn rotate_session_key(\u0026self, rng: \u0026mut dyn rand_core::RngCore) -\u003e Result\u003cAeadKeyRef, CryptoError\u003e;\n}\n\n/// Taille standard des nonces pour ChaCha20-Poly1305 (12 bytes)\npub const NONCE_SIZE: usize = 12;\n\n/// Taille standard des cl√©s pour ChaCha20-Poly1305 (32 bytes) \npub const KEY_SIZE: usize = 32;\n\n/// Taille des signatures Ed25519 (64 bytes)\npub const SIGNATURE_SIZE: usize = 64;\n\n/// Taille des cl√©s publiques Ed25519 (32 bytes)\npub const PUBLIC_KEY_SIZE: usize = 32;\n\n/// Teste la disponibilit√© des fonctions cryptographiques\npub fn test_crypto_availability() -\u003e Result\u003c(), String\u003e {\n    use rand_core::OsRng;\n    \n    // Test BLAKE3\n    let hash1 = blake3_32(b\"test\");\n    let hash2 = blake3_32(b\"test\");\n    if hash1 != hash2 {\n        return Err(\"Test de hachage √©chou√©\".into());\n    }\n    \n    // Test g√©n√©ration al√©atoire\n    let mut rng = OsRng;\n    let random1 = random_nonce(\u0026mut rng);\n    let random2 = random_nonce(\u0026mut rng);\n    \n    if random1 == random2 {\n        return Err(\"G√©n√©rateur al√©atoire d√©faillant\".into());\n    }\n    \n    // Test AEAD roundtrip basique\n    let key = AeadKeyRef::from_bytes([42u8; 32]);\n    let nonce = random_nonce(\u0026mut rng);\n    \n    match aead::encrypt(\u0026key, nonce, b\"test_aad\", b\"test_message\") {\n        Ok(sealed) =\u003e {\n            match aead::decrypt(\u0026key, b\"test_aad\", \u0026sealed) {\n                Ok(decrypted) =\u003e {\n                    if decrypted != b\"test_message\" {\n                        return Err(\"Test AEAD roundtrip √©chou√©\".into());\n                    }\n                }\n                Err(_) =\u003e return Err(\"Test AEAD decrypt √©chou√©\".into()),\n            }\n        }\n        Err(_) =\u003e return Err(\"Test AEAD encrypt √©chou√©\".into()),\n    }\n    \n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_core::OsRng;\n\n    #[test]\n    fn test_constants() {\n        assert_eq!(NONCE_SIZE, 12);  // ChaCha20 nonce\n        assert_eq!(KEY_SIZE, 32);\n        assert_eq!(SIGNATURE_SIZE, 64);\n        assert_eq!(PUBLIC_KEY_SIZE, 32);\n    }\n\n    #[test]\n    fn test_crypto_availability() {\n        // La fonction retourne Result\u003c(), String\u003e\n        let result = crate::crypto::test_crypto_availability();\n        assert!(result.is_ok(), \"Test crypto availability failed: {:?}\", result);\n    }\n    \n    #[test]\n    fn test_aead_aad_enforcement() {\n        let key = AeadKeyRef::from_bytes([42u8; 32]);\n        let mut rng = OsRng;\n        let nonce = random_nonce(\u0026mut rng);\n        \n        // AAD vide doit √™tre rejet√©e\n        let result = aead::encrypt(\u0026key, nonce, b\"\", b\"plaintext\");\n        assert!(result.is_err());\n        \n        // AAD non-vide doit fonctionner\n        let result = aead::encrypt(\u0026key, nonce, b\"version:1\", b\"plaintext\");\n        assert!(result.is_ok());\n    }\n}","traces":[],"covered":0,"coverable":0},{"path":["/","home","seb","Dev","miaou","miaou-crypto","src","primitives.rs"],"content":"//! Primitives cryptographiques de base\n//! \n//! Fonctions utilitaires s√©curis√©es pour op√©rations cryptographiques communes.\n\nuse crate::{CryptoError, CryptoResult};\nuse crate::crypto::hashing::{Blake3Hasher, HashingEngine};\nuse ring::rand::{SecureRandom, SystemRandom};\nuse subtle::ConstantTimeEq;\nuse zeroize::Zeroize;\n\n/// G√©n√©rateur de nombres al√©atoires cryptographiquement s√ªr\nstatic SECURE_RNG: std::sync::LazyLock\u003cSystemRandom\u003e = std::sync::LazyLock::new(|| SystemRandom::new());\n\n/// G√©n√®re des bytes al√©atoires cryptographiquement s√ªrs\n/// \n/// # Arguments\n/// * `length` - Nombre de bytes √† g√©n√©rer\n/// \n/// # Returns\n/// * `Vec\u003cu8\u003e` - Bytes al√©atoires g√©n√©r√©s\n/// \n/// # Examples\n/// ```\n/// use miaou::crypto::primitives::random_bytes;\n/// \n/// let random_data = random_bytes(32).unwrap();\n/// assert_eq!(random_data.len(), 32);\n/// ```\npub fn random_bytes(length: usize) -\u003e CryptoResult\u003cVec\u003cu8\u003e\u003e {\n    let mut bytes = vec![0u8; length];\n    (\u0026*SECURE_RNG)\n        .fill(\u0026mut bytes)\n        .map_err(|e| CryptoError::KeyGenerationError(format!(\"RNG failed: {:?}\", e)))?;\n    Ok(bytes)\n}\n\n/// G√©n√®re un tableau de bytes al√©atoires de taille fixe\n/// \n/// # Examples\n/// ```\n/// use miaou::crypto::primitives::random_array;\n/// \n/// let random_key: [u8; 32] = random_array().unwrap();\n/// assert_eq!(random_key.len(), 32);\n/// ```\npub fn random_array\u003cconst N: usize\u003e() -\u003e CryptoResult\u003c[u8; N]\u003e {\n    let mut array = [0u8; N];\n    (\u0026*SECURE_RNG)\n        .fill(\u0026mut array)\n        .map_err(|e| CryptoError::KeyGenerationError(format!(\"RNG failed: {:?}\", e)))?;\n    Ok(array)\n}\n\n/// Comparaison en temps constant pour √©viter les attaques par canaux auxiliaires\n/// \n/// # Arguments\n/// * `a` - Premier slice √† comparer\n/// * `b` - Second slice √† comparer\n/// \n/// # Returns\n/// * `bool` - true si les slices sont identiques, false sinon\n/// \n/// # Security\n/// Cette fonction utilise une comparaison en temps constant pour √©viter\n/// les attaques par analyse temporelle.\n/// \n/// # Examples\n/// ```\n/// use miaou::crypto::primitives::secure_compare;\n/// \n/// let data1 = b\"secret\";\n/// let data2 = b\"secret\";\n/// let data3 = b\"public\";\n/// \n/// assert!(secure_compare(data1, data2));\n/// assert!(!secure_compare(data1, data3));\n/// ```\npub fn secure_compare(a: \u0026[u8], b: \u0026[u8]) -\u003e bool {\n    // V√©rification des longueurs d'abord\n    if a.len() != b.len() {\n        return false;\n    }\n    \n    // Comparaison en temps constant\n    a.ct_eq(b).into()\n}\n\n/// XOR de deux slices de m√™me taille\n/// \n/// # Arguments\n/// * `a` - Premier slice\n/// * `b` - Second slice (doit avoir la m√™me taille que `a`)\n/// \n/// # Returns\n/// * `Result\u003cVec\u003cu8\u003e, CryptoError\u003e` - XOR des deux slices\n/// \n/// # Examples\n/// ```\n/// use miaou::crypto::primitives::xor_bytes;\n/// \n/// let a = \u0026[0xFF, 0x00, 0xAA];\n/// let b = \u0026[0x0F, 0xFF, 0x55];\n/// let result = xor_bytes(a, b).unwrap();\n/// assert_eq!(result, vec![0xF0, 0xFF, 0xFF]);\n/// ```\npub fn xor_bytes(a: \u0026[u8], b: \u0026[u8]) -\u003e CryptoResult\u003cVec\u003cu8\u003e\u003e {\n    if a.len() != b.len() {\n        return Err(CryptoError::InvalidDataSize {\n            expected: a.len(),\n            actual: b.len(),\n        });\n    }\n    \n    let result: Vec\u003cu8\u003e = a.iter().zip(b.iter()).map(|(x, y)| x ^ y).collect();\n    Ok(result)\n}\n\n/// Combine deux cl√©s de mani√®re s√©curis√©e (XOR apr√®s hachage)\n/// \n/// # Arguments\n/// * `key1` - Premi√®re cl√©\n/// * `key2` - Seconde cl√©  \n/// \n/// # Returns\n/// * `[u8; 32]` - Cl√© combin√©e de 32 bytes\n/// \n/// # Security\n/// Les cl√©s sont d'abord hach√©es avec BLAKE3 avant XOR pour √©viter\n/// les faiblesses cryptographiques du XOR direct.\npub fn combine_keys(key1: \u0026[u8], key2: \u0026[u8]) -\u003e [u8; 32] {\n    use crate::crypto::hashing::Blake3Hasher;\n    \n    let hash1 = Blake3Hasher::hash(key1);\n    let hash2 = Blake3Hasher::hash(key2);\n    \n    let mut combined = [0u8; 32];\n    for i in 0..32 {\n        combined[i] = hash1.as_bytes()[i] ^ hash2.as_bytes()[i];\n    }\n    \n    combined\n}\n\n/// D√©rive une sous-cl√© √† partir d'une cl√© ma√Ætre et d'un contexte\n/// \n/// # Arguments\n/// * `master_key` - Cl√© ma√Ætre\n/// * `context` - Contexte de d√©rivation (ex: \"encryption\", \"signature\")\n/// * `index` - Index de la sous-cl√© (pour g√©n√©rer plusieurs cl√©s)\n/// \n/// # Returns\n/// * `[u8; 32]` - Sous-cl√© d√©riv√©e\n/// \n/// # Examples\n/// ```\n/// use miaou::crypto::primitives::derive_subkey;\n/// \n/// let master = \u0026[0u8; 32];\n/// let encryption_key = derive_subkey(master, \"encryption\", 0);\n/// let signing_key = derive_subkey(master, \"signing\", 0);\n/// \n/// assert_ne!(encryption_key, signing_key);\n/// ```\npub fn derive_subkey(master_key: \u0026[u8], context: \u0026str, index: u32) -\u003e [u8; 32] {\n    let context_with_index = format!(\"miaou.{}.{}\", context, index);\n    let combined = [master_key, context_with_index.as_bytes()].concat();\n    let hash = blake3::hash(\u0026combined);\n    *hash.as_bytes()\n}\n\n/// M√©lange s√©curis√© de donn√©es (shuffle cryptographique)\n/// \n/// # Arguments\n/// * `data` - Donn√©es √† m√©langer\n/// * `seed` - Graine pour le m√©lange (doit √™tre al√©atoire)\n/// \n/// # Returns\n/// * `Vec\u003cu8\u003e` - Donn√©es m√©lang√©es\n/// \n/// # Security\n/// Utilise Fisher-Yates avec un PRNG seed√© pour un m√©lange d√©terministe\n/// mais cryptographiquement s√ªr.\npub fn secure_shuffle(data: \u0026[u8], seed: \u0026[u8; 32]) -\u003e Vec\u003cu8\u003e {\n    use rand::{Rng, SeedableRng};\n    use rand_chacha::ChaCha20Rng;\n    \n    let mut rng = ChaCha20Rng::from_seed(*seed);\n    let mut result = data.to_vec();\n    \n    // Fisher-Yates shuffle\n    for i in (1..result.len()).rev() {\n        let j = rng.gen_range(0..=i);\n        result.swap(i, j);\n    }\n    \n    result\n}\n\n/// G√©n√®re un sel al√©atoire pour Argon2 ou autres KDF\n/// \n/// # Returns\n/// * `[u8; 16]` - Sel al√©atoire de 16 bytes\npub fn generate_salt() -\u003e CryptoResult\u003c[u8; 16]\u003e {\n    random_array::\u003c16\u003e()\n}\n\n/// G√©n√®re un nonce al√©atoire pour ChaCha20-Poly1305\n/// \n/// # Returns\n/// * `[u8; 12]` - Nonce al√©atoire de 12 bytes\npub fn generate_nonce() -\u003e CryptoResult\u003c[u8; 12]\u003e {\n    random_array::\u003c12\u003e()\n}\n\n/// Efface de mani√®re s√©curis√©e un buffer en m√©moire\n/// \n/// # Arguments\n/// * `buffer` - Buffer mutable √† effacer\n/// \n/// # Security\n/// Utilise zeroize pour garantir que les donn√©es sensibles\n/// sont bien effac√©es de la m√©moire.\npub fn secure_erase(buffer: \u0026mut [u8]) {\n    buffer.zeroize();\n}\n\n/// G√©n√©rateur d'identifiants uniques cryptographiquement s√ªrs\npub struct SecureIdGenerator {\n    counter: std::sync::atomic::AtomicU64,\n    node_id: [u8; 8],\n}\n\nimpl SecureIdGenerator {\n    /// Cr√©e un nouveau g√©n√©rateur avec un ID de n≈ìud al√©atoire\n    pub fn new() -\u003e CryptoResult\u003cSelf\u003e {\n        let node_id = random_array::\u003c8\u003e()?;\n        Ok(Self {\n            counter: std::sync::atomic::AtomicU64::new(0),\n            node_id,\n        })\n    }\n    \n    /// G√©n√®re un ID unique de 16 bytes\n    pub fn generate_id(\u0026self) -\u003e [u8; 16] {\n        use std::sync::atomic::Ordering;\n        \n        let counter = self.counter.fetch_add(1, Ordering::SeqCst);\n        let timestamp = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap()\n            .as_millis() as u64;\n        \n        let mut id = [0u8; 16];\n        id[0..8].copy_from_slice(\u0026timestamp.to_be_bytes());\n        id[8..16].copy_from_slice(\u0026(counter ^ u64::from_be_bytes(self.node_id)).to_be_bytes());\n        \n        id\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_random_bytes() {\n        let bytes1 = random_bytes(32).unwrap();\n        let bytes2 = random_bytes(32).unwrap();\n        \n        assert_eq!(bytes1.len(), 32);\n        assert_eq!(bytes2.len(), 32);\n        assert_ne!(bytes1, bytes2); // Probabilit√© n√©gligeable d'√™tre √©gaux\n    }\n    \n    #[test]\n    fn test_random_array() {\n        let array1: [u8; 16] = random_array().unwrap();\n        let array2: [u8; 16] = random_array().unwrap();\n        \n        assert_ne!(array1, array2);\n    }\n    \n    #[test]\n    fn test_secure_compare() {\n        let data1 = b\"secret_data\";\n        let data2 = b\"secret_data\";\n        let data3 = b\"public_data\";\n        let data4 = b\"secret\"; // Longueur diff√©rente\n        \n        assert!(secure_compare(data1, data2));\n        assert!(!secure_compare(data1, data3));\n        assert!(!secure_compare(data1, data4));\n    }\n    \n    #[test]\n    fn test_xor_bytes() {\n        let a = \u0026[0xFF, 0x00, 0xAA, 0x55];\n        let b = \u0026[0x0F, 0xFF, 0x55, 0xAA];\n        let expected = vec![0xF0, 0xFF, 0xFF, 0xFF];\n        \n        let result = xor_bytes(a, b).unwrap();\n        assert_eq!(result, expected);\n        \n        // Test tailles diff√©rentes\n        let c = \u0026[0xFF];\n        assert!(xor_bytes(a, c).is_err());\n    }\n    \n    #[test]\n    fn test_combine_keys() {\n        let key1 = \u0026[1u8; 32];\n        let key2 = \u0026[2u8; 32];\n        let key3 = \u0026[1u8; 32]; // Identique √† key1\n        \n        let combined1 = combine_keys(key1, key2);\n        let combined2 = combine_keys(key1, key3);\n        let combined3 = combine_keys(key2, key1); // Ordre diff√©rent\n        \n        assert_ne!(combined1, combined2);\n        assert_eq!(combined1, combined3); // XOR est commutatif apr√®s hash\n    }\n    \n    #[test]\n    fn test_derive_subkey() {\n        let master = \u0026[0u8; 32];\n        \n        let enc_key = derive_subkey(master, \"encryption\", 0);\n        let sig_key = derive_subkey(master, \"signing\", 0);\n        let enc_key2 = derive_subkey(master, \"encryption\", 1);\n        \n        // Contextes diff√©rents = cl√©s diff√©rentes\n        assert_ne!(enc_key, sig_key);\n        \n        // Index diff√©rents = cl√©s diff√©rentes\n        assert_ne!(enc_key, enc_key2);\n        \n        // D√©terminisme\n        let enc_key_again = derive_subkey(master, \"encryption\", 0);\n        assert_eq!(enc_key, enc_key_again);\n    }\n    \n    #[test]\n    fn test_secure_shuffle() {\n        let data = b\"Hello, World!\";\n        let seed1 = [1u8; 32];\n        let seed2 = [2u8; 32];\n        \n        let shuffled1 = secure_shuffle(data, \u0026seed1);\n        let shuffled2 = secure_shuffle(data, \u0026seed2);\n        let shuffled1_again = secure_shuffle(data, \u0026seed1);\n        \n        // M√™me seed = m√™me r√©sultat\n        assert_eq!(shuffled1, shuffled1_again);\n        \n        // Seeds diff√©rents = r√©sultats diff√©rents (tr√®s probable)\n        assert_ne!(shuffled1, shuffled2);\n        \n        // M√™me longueur\n        assert_eq!(shuffled1.len(), data.len());\n    }\n    \n    #[test]\n    fn test_salt_and_nonce_generation() {\n        let salt1 = generate_salt().unwrap();\n        let salt2 = generate_salt().unwrap();\n        let nonce1 = generate_nonce().unwrap();\n        let nonce2 = generate_nonce().unwrap();\n        \n        assert_eq!(salt1.len(), 16);\n        assert_eq!(nonce1.len(), 12);\n        assert_ne!(salt1, salt2);\n        assert_ne!(nonce1, nonce2);\n    }\n    \n    #[test]\n    fn test_secure_erase() {\n        let mut buffer = vec![0xAA; 100];\n        secure_erase(\u0026mut buffer);\n        \n        // V√©rifier que tout est √† z√©ro\n        assert!(buffer.iter().all(|\u0026x| x == 0));\n    }\n    \n    #[test]\n    fn test_secure_id_generator() {\n        let generator = SecureIdGenerator::new().unwrap();\n        \n        let id1 = generator.generate_id();\n        let id2 = generator.generate_id();\n        \n        assert_eq!(id1.len(), 16);\n        assert_eq!(id2.len(), 16);\n        assert_ne!(id1, id2);\n    }\n    \n    #[test]\n    fn test_secure_id_generator_uniqueness() {\n        let generator = SecureIdGenerator::new().unwrap();\n        let mut ids = std::collections::HashSet::new();\n        \n        // G√©n√©rer 1000 IDs et v√©rifier l'unicit√©\n        for _ in 0..1000 {\n            let id = generator.generate_id();\n            assert!(ids.insert(id), \"ID dupliqu√© d√©tect√©\");\n        }\n    }\n}","traces":[],"covered":0,"coverable":0},{"path":["/","home","seb","Dev","miaou","miaou-crypto","src","sign.rs"],"content":"//! # Signatures Ed25519 (v0.1)\n//!\n//! G√©n√®re une paire, signe et v√©rifie des messages (aucun Debug sur secrets).\n//! Utilise ed25519-dalek v2 avec zeroization automatique.\n\nuse crate::CryptoError;\nuse ed25519_dalek::{Signature as DalekSignature, Signer, SigningKey, Verifier, VerifyingKey};\nuse rand_core::{CryptoRng, OsRng, RngCore};\nuse zeroize::ZeroizeOnDrop;\n\n/// Cl√© de signature secr√®te (zeroized on drop, non clonable, non affichable)\n#[derive(ZeroizeOnDrop)]\npub struct SigningKeyRef {\n    inner: SigningKey,\n}\n\nimpl SigningKeyRef {\n    /// Cr√©e une cl√© de signature depuis 32 octets.\n    #[must_use]\n    pub fn from_bytes(bytes: [u8; 32]) -\u003e Self {\n        Self {\n            inner: SigningKey::from_bytes(\u0026bytes),\n        }\n    }\n\n    /// G√©n√®re une nouvelle cl√© de signature al√©atoire.\n    #[must_use]\n    pub fn generate\u003cR: RngCore + CryptoRng\u003e(rng: \u0026mut R) -\u003e Self {\n        Self {\n            inner: SigningKey::generate(rng),\n        }\n    }\n\n    /// Retourne la cl√© publique correspondante.\n    #[must_use]\n    pub fn verifying_key(\u0026self) -\u003e VerifyingKeyRef {\n        VerifyingKeyRef {\n            inner: self.inner.verifying_key(),\n        }\n    }\n\n    /// Retourne les octets de la cl√© secr√®te (usage keystore).\n    #[must_use]\n    pub fn to_bytes(\u0026self) -\u003e [u8; 32] {\n        self.inner.to_bytes()\n    }\n\n    /// Signe un message.\n    #[must_use]\n    pub fn sign(\u0026self, msg: \u0026[u8]) -\u003e Signature {\n        Signature {\n            inner: self.inner.sign(msg),\n        }\n    }\n}\n\n// Pas de Debug pour √©viter les fuites\nimpl std::fmt::Debug for SigningKeyRef {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"SigningKeyRef([REDACTED])\")\n    }\n}\n\n/// Cl√© de v√©rification publique\n#[derive(Clone, Copy, Debug, PartialEq, Eq)]\npub struct VerifyingKeyRef {\n    inner: VerifyingKey,\n}\n\nimpl VerifyingKeyRef {\n    /// Cr√©e une cl√© de v√©rification depuis 32 octets.\n    ///\n    /// # Errors\n    /// √âchec si les octets ne repr√©sentent pas une cl√© publique Ed25519 valide.\n    pub fn from_bytes(bytes: [u8; 32]) -\u003e Result\u003cSelf, CryptoError\u003e {\n        VerifyingKey::from_bytes(\u0026bytes)\n            .map(|inner| Self { inner })\n            .map_err(|_| CryptoError::InvalidKey)\n    }\n\n    /// Retourne les octets de la cl√© publique.\n    #[must_use]\n    pub fn to_bytes(\u0026self) -\u003e [u8; 32] {\n        self.inner.to_bytes()\n    }\n\n    /// V√©rifie une signature.\n    ///\n    /// # Errors\n    /// √âchec si la signature est invalide pour le message donn√©.\n    pub fn verify(\u0026self, msg: \u0026[u8], sig: \u0026Signature) -\u003e Result\u003c(), CryptoError\u003e {\n        self.inner\n            .verify(msg, \u0026sig.inner)\n            .map_err(|_| CryptoError::SignatureVerificationFailed)\n    }\n\n    /// Encode la cl√© publique en hexad√©cimal.\n    #[must_use]\n    pub fn to_hex(\u0026self) -\u003e String {\n        hex::encode(self.to_bytes())\n    }\n\n    /// D√©code une cl√© publique depuis l'hexad√©cimal.\n    ///\n    /// # Errors\n    /// √âchec si `hex_str` n'est pas une cha√Æne hexad√©cimale valide de 32 octets.\n    pub fn from_hex(hex_str: \u0026str) -\u003e Result\u003cSelf, CryptoError\u003e {\n        let bytes = hex::decode(hex_str).map_err(|_| CryptoError::InvalidInput)?;\n\n        if bytes.len() != 32 {\n            return Err(CryptoError::InvalidKey);\n        }\n\n        let mut key_bytes = [0u8; 32];\n        key_bytes.copy_from_slice(\u0026bytes);\n\n        Self::from_bytes(key_bytes)\n    }\n}\n\n/// Signature Ed25519 (64 bytes)\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct Signature {\n    inner: DalekSignature,\n}\n\nimpl Signature {\n    /// Cr√©e une signature depuis 64 octets.\n    ///\n    /// # Errors\n    /// √âchec si les octets ne repr√©sentent pas une signature Ed25519 valide.\n    pub fn from_bytes(bytes: [u8; 64]) -\u003e Result\u003cSelf, CryptoError\u003e {\n        Ok(Self {\n            inner: DalekSignature::from_bytes(\u0026bytes),\n        })\n    }\n\n    /// Retourne les octets de la signature.\n    #[must_use]\n    pub fn to_bytes(\u0026self) -\u003e [u8; 64] {\n        self.inner.to_bytes()\n    }\n\n    /// Encode la signature en hexad√©cimal.\n    #[must_use]\n    pub fn to_hex(\u0026self) -\u003e String {\n        hex::encode(self.to_bytes())\n    }\n\n    /// D√©code une signature depuis l'hexad√©cimal.\n    ///\n    /// # Errors\n    /// √âchec si `hex_str` n'est pas une cha√Æne hexad√©cimale valide de 64 octets.\n    pub fn from_hex(hex_str: \u0026str) -\u003e Result\u003cSelf, CryptoError\u003e {\n        let bytes = hex::decode(hex_str).map_err(|_| CryptoError::InvalidInput)?;\n\n        if bytes.len() != 64 {\n            return Err(CryptoError::InvalidInput);\n        }\n\n        let mut sig_bytes = [0u8; 64];\n        sig_bytes.copy_from_slice(\u0026bytes);\n\n        Self::from_bytes(sig_bytes)\n    }\n}\n\n/// Paire de cl√©s (secret/public)\npub struct Keypair {\n    /// Cl√© secr√®te (non clonable, non affichable).\n    pub secret: SigningKeyRef,\n    /// Cl√© publique (v√©rification).\n    pub public: VerifyingKeyRef,\n}\n\nimpl Keypair {\n    /// G√©n√®re une paire Ed25519.\n    #[must_use]\n    pub fn generate() -\u003e Self {\n        let secret = SigningKeyRef {\n            inner: SigningKey::generate(\u0026mut OsRng),\n        };\n        let public = secret.verifying_key();\n        Self { secret, public }\n    }\n\n    /// G√©n√®re une paire avec un RNG sp√©cifique.\n    #[must_use]\n    pub fn generate_with_rng\u003cR: RngCore + CryptoRng\u003e(rng: \u0026mut R) -\u003e Self {\n        let secret = SigningKeyRef::generate(rng);\n        let public = secret.verifying_key();\n        Self { secret, public }\n    }\n\n    /// Cr√©e une paire depuis une cl√© secr√®te.\n    #[must_use]\n    pub fn from_secret_key(secret: SigningKeyRef) -\u003e Self {\n        let public = secret.verifying_key();\n        Self { secret, public }\n    }\n\n    /// Cr√©e une paire depuis les octets d'une cl√© priv√©e.\n    ///\n    /// # Errors\n    /// Cette fonction ne peut pas √©chouer car `SigningKeyRef::from_bytes` est infaillible.\n    pub fn from_private_bytes(bytes: [u8; 32]) -\u003e Result\u003cSelf, CryptoError\u003e {\n        let secret = SigningKeyRef::from_bytes(bytes);\n        let public = secret.verifying_key();\n        Ok(Self { secret, public })\n    }\n\n    /// Signe un message.\n    #[must_use]\n    pub fn sign(\u0026self, msg: \u0026[u8]) -\u003e Signature {\n        self.secret.sign(msg)\n    }\n\n    /// V√©rifie une signature.\n    ///\n    /// # Errors\n    /// √âchec si la signature est invalide pour le message donn√©.\n    pub fn verify(\u0026self, msg: \u0026[u8], sig: \u0026Signature) -\u003e Result\u003c(), CryptoError\u003e {\n        self.public.verify(msg, sig)\n    }\n\n    /// Retourne les octets de la cl√© publique.\n    #[must_use]\n    pub fn public_bytes(\u0026self) -\u003e [u8; 32] {\n        self.public.to_bytes()\n    }\n\n    /// Retourne les octets de la cl√© secr√®te (usage keystore).\n    #[must_use]\n    pub fn secret_bytes(\u0026self) -\u003e [u8; 32] {\n        self.secret.to_bytes()\n    }\n\n    /// Retourne une r√©f√©rence vers la cl√© publique.\n    #[must_use]\n    pub const fn public_key(\u0026self) -\u003e \u0026VerifyingKeyRef {\n        \u0026self.public\n    }\n\n    /// Retourne une r√©f√©rence vers la cl√© secr√®te.\n    #[must_use]\n    pub const fn secret_key(\u0026self) -\u003e \u0026SigningKeyRef {\n        \u0026self.secret\n    }\n}\n\n// Pas de Debug pour √©viter les fuites de la cl√© secr√®te\nimpl std::fmt::Debug for Keypair {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"Keypair\")\n            .field(\"public\", \u0026self.public)\n            .field(\"secret\", \u0026\"[REDACTED]\")\n            .finish()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_keypair_generation() {\n        let keypair = Keypair::generate();\n        let message = b\"test message\";\n\n        let signature = keypair.sign(message);\n        assert!(keypair.verify(message, \u0026signature).is_ok());\n    }\n\n    #[test]\n    fn test_signature_verification() {\n        let keypair = Keypair::generate();\n        let message = b\"hello world\";\n\n        let signature = keypair.sign(message);\n\n        // Bonne signature\n        assert!(keypair.public.verify(message, \u0026signature).is_ok());\n\n        // Mauvais message\n        assert!(keypair.public.verify(b\"wrong message\", \u0026signature).is_err());\n    }\n\n    #[test]\n    fn test_key_serialization() {\n        let keypair = Keypair::generate();\n\n        // Test s√©rialisation cl√© publique\n        let public_bytes = keypair.public.to_bytes();\n        let public_restored = VerifyingKeyRef::from_bytes(public_bytes).unwrap();\n        assert_eq!(keypair.public, public_restored);\n\n        // Test s√©rialisation signature\n        let message = b\"test\";\n        let signature = keypair.sign(message);\n        let sig_bytes = signature.to_bytes();\n        let sig_restored = Signature::from_bytes(sig_bytes).unwrap();\n        assert_eq!(signature, sig_restored);\n    }\n\n    #[test]\n    fn test_hex_encoding() {\n        let keypair = Keypair::generate();\n\n        // Test hex cl√© publique\n        let hex = keypair.public.to_hex();\n        let restored = VerifyingKeyRef::from_hex(\u0026hex).unwrap();\n        assert_eq!(keypair.public, restored);\n\n        // Test hex signature\n        let signature = keypair.sign(b\"test\");\n        let hex_sig = signature.to_hex();\n        let restored_sig = Signature::from_hex(\u0026hex_sig).unwrap();\n        assert_eq!(signature, restored_sig);\n    }\n\n    #[test]\n    fn test_zeroization() {\n        // Test que SigningKeyRef impl√©mente ZeroizeOnDrop\n        fn assert_zeroize_on_drop\u003cT: ZeroizeOnDrop\u003e() {}\n        assert_zeroize_on_drop::\u003cSigningKeyRef\u003e();\n    }\n\n    #[test]\n    fn test_no_debug_on_secrets() {\n        // Les types secrets ne doivent pas leak d'informations via Debug\n        let keypair = Keypair::generate();\n        let debug_str = format!(\"{:?}\", keypair);\n        assert!(debug_str.contains(\"[REDACTED]\"));\n        assert!(!debug_str.contains(\"SigningKey\"));\n    }\n\n    #[test]\n    fn test_signing_key_ref_from_bytes() {\n        let bytes = [42u8; 32];\n        let signing_key = SigningKeyRef::from_bytes(bytes);\n        \n        // Should be able to create a signing key from bytes\n        let public_key = signing_key.verifying_key();\n        assert_eq!(public_key.to_bytes().len(), 32);\n    }\n\n    #[test]\n    fn test_signing_key_ref_generate_with_rng() {\n        let mut rng = rand_core::OsRng;\n        let signing_key = SigningKeyRef::generate(\u0026mut rng);\n        \n        // Should generate a valid signing key\n        let public_key = signing_key.verifying_key();\n        assert_eq!(public_key.to_bytes().len(), 32);\n    }\n\n    #[test]\n    fn test_signing_key_ref_to_bytes() {\n        let signing_key = SigningKeyRef::generate(\u0026mut rand_core::OsRng);\n        let bytes = signing_key.to_bytes();\n        \n        assert_eq!(bytes.len(), 32);\n        \n        // Should be able to recreate the same key\n        let recreated = SigningKeyRef::from_bytes(bytes);\n        let original_public = signing_key.verifying_key();\n        let recreated_public = recreated.verifying_key();\n        \n        assert_eq!(original_public.to_bytes(), recreated_public.to_bytes());\n    }\n\n    #[test]\n    fn test_signing_key_ref_debug_redacted() {\n        let signing_key = SigningKeyRef::generate(\u0026mut rand_core::OsRng);\n        let debug_str = format!(\"{:?}\", signing_key);\n        \n        assert!(debug_str.contains(\"SigningKeyRef([REDACTED])\"));\n    }\n\n    #[test]\n    fn test_verifying_key_ref_from_bytes_invalid() {\n        // Test with invalid bytes (should error)\n        let invalid_bytes = [0xFFu8; 32];\n        match VerifyingKeyRef::from_bytes(invalid_bytes) {\n            Ok(_) =\u003e {}, // Ed25519 accepts most 32-byte arrays\n            Err(e) =\u003e assert!(matches!(e, CryptoError::InvalidKey)),\n        }\n    }\n\n    #[test]\n    fn test_verifying_key_ref_from_hex_invalid() {\n        // Invalid hex string\n        assert!(VerifyingKeyRef::from_hex(\"invalid_hex\").is_err());\n        \n        // Wrong length\n        assert!(VerifyingKeyRef::from_hex(\"deadbeef\").is_err());\n        \n        // Too long\n        let too_long = \"a\".repeat(100);\n        assert!(VerifyingKeyRef::from_hex(\u0026too_long).is_err());\n    }\n\n    #[test]\n    fn test_signature_from_bytes_to_bytes() {\n        let keypair = Keypair::generate();\n        let message = b\"test message\";\n        let signature = keypair.sign(message);\n        \n        let signature_bytes = signature.to_bytes();\n        assert_eq!(signature_bytes.len(), 64);\n        \n        let recreated_signature = Signature::from_bytes(signature_bytes).unwrap();\n        assert_eq!(signature, recreated_signature);\n    }\n\n    #[test]\n    fn test_signature_from_hex_invalid() {\n        // Invalid hex\n        assert!(Signature::from_hex(\"invalid_hex\").is_err());\n        \n        // Wrong length\n        assert!(Signature::from_hex(\"deadbeef\").is_err());\n        \n        // Too long\n        let too_long = \"a\".repeat(200);\n        assert!(Signature::from_hex(\u0026too_long).is_err());\n    }\n\n    #[test]\n    fn test_keypair_generate_with_rng() {\n        let mut rng = rand_core::OsRng;\n        let keypair1 = Keypair::generate_with_rng(\u0026mut rng);\n        let keypair2 = Keypair::generate_with_rng(\u0026mut rng);\n        \n        // Should generate different keypairs\n        assert_ne!(keypair1.public_bytes(), keypair2.public_bytes());\n        assert_ne!(keypair1.secret_bytes(), keypair2.secret_bytes());\n    }\n\n    #[test]\n    fn test_keypair_from_secret_key() {\n        let secret_key = SigningKeyRef::generate(\u0026mut rand_core::OsRng);\n        let public_key = secret_key.verifying_key();\n        \n        let keypair = Keypair::from_secret_key(secret_key);\n        \n        // Should have same public key\n        assert_eq!(keypair.public.to_bytes(), public_key.to_bytes());\n    }\n\n    #[test]\n    fn test_keypair_from_private_bytes() {\n        let original_keypair = Keypair::generate();\n        let private_bytes = original_keypair.secret_bytes();\n        \n        let recreated_keypair = Keypair::from_private_bytes(private_bytes).unwrap();\n        \n        // Should have same keys\n        assert_eq!(original_keypair.public_bytes(), recreated_keypair.public_bytes());\n        assert_eq!(original_keypair.secret_bytes(), recreated_keypair.secret_bytes());\n    }\n\n    #[test]\n    fn test_keypair_public_bytes_secret_bytes() {\n        let keypair = Keypair::generate();\n        \n        let public_bytes = keypair.public_bytes();\n        let secret_bytes = keypair.secret_bytes();\n        \n        assert_eq!(public_bytes.len(), 32);\n        assert_eq!(secret_bytes.len(), 32);\n        \n        // Should match direct access\n        assert_eq!(public_bytes, keypair.public.to_bytes());\n        assert_eq!(secret_bytes, keypair.secret.to_bytes());\n    }\n\n    #[test]\n    fn test_keypair_key_references() {\n        let keypair = Keypair::generate();\n        \n        let public_key_ref = keypair.public_key();\n        let secret_key_ref = keypair.secret_key();\n        \n        // Should match direct access\n        assert_eq!(public_key_ref.to_bytes(), keypair.public.to_bytes());\n        \n        let message = b\"test\";\n        let sig1 = secret_key_ref.sign(message);\n        let sig2 = keypair.secret.sign(message);\n        assert_eq!(sig1, sig2);\n    }\n\n    #[test]\n    fn test_keypair_debug_format() {\n        let keypair = Keypair::generate();\n        let debug_str = format!(\"{:?}\", keypair);\n        \n        // Should contain public key info but redact secret\n        assert!(debug_str.contains(\"Keypair\"));\n        assert!(debug_str.contains(\"public\"));\n        assert!(debug_str.contains(\"[REDACTED]\"));\n    }\n\n    #[test]\n    fn test_sign_verify_wrong_message_fails() {\n        let keypair = Keypair::generate();\n        let message1 = b\"correct message\";\n        let message2 = b\"wrong message\";\n        \n        let signature = keypair.sign(message1);\n        \n        // Correct message should verify\n        assert!(keypair.verify(message1, \u0026signature).is_ok());\n        \n        // Wrong message should fail\n        assert!(keypair.verify(message2, \u0026signature).is_err());\n    }\n\n    #[test]\n    fn test_verifying_key_verify_wrong_signature_fails() {\n        let keypair1 = Keypair::generate();\n        let keypair2 = Keypair::generate();\n        let message = b\"test message\";\n        \n        let signature = keypair1.sign(message);\n        \n        // Correct key should verify\n        assert!(keypair1.public.verify(message, \u0026signature).is_ok());\n        \n        // Wrong key should fail\n        assert!(keypair2.public.verify(message, \u0026signature).is_err());\n    }\n\n    #[test]\n    fn test_cross_compatibility() {\n        // Test that all sign/verify combinations work\n        let keypair = Keypair::generate();\n        let message = b\"cross compatibility test\";\n        \n        // Sign with secret key, verify with public key\n        let sig1 = keypair.secret.sign(message);\n        assert!(keypair.public.verify(message, \u0026sig1).is_ok());\n        \n        // Sign with keypair, verify with public key\n        let sig2 = keypair.sign(message);\n        assert!(keypair.public.verify(message, \u0026sig2).is_ok());\n        \n        // Sign with keypair, verify with keypair\n        let sig3 = keypair.sign(message);\n        assert!(keypair.verify(message, \u0026sig3).is_ok());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","seb","Dev","miaou","miaou-crypto","src","signing.rs"],"content":"//! Signatures num√©riques avec Ed25519\n//! \n//! Impl√©mentation des signatures num√©riques EdDSA avec courbes Ed25519\n//! selon RFC 8032 pour authentifier les messages Miaou.\n\nuse crate::crypto::{CryptoError, CryptoResult, SIGNATURE_SIZE, PUBLIC_KEY_SIZE};\nuse ed25519_dalek::{\n    Signature, Signer, Keypair, PublicKey, SecretKey, Verifier,\n};\nuse rand::rngs::OsRng;\nuse zeroize::{Zeroize, ZeroizeOnDrop};\nuse serde::{Deserialize, Serialize};\n\n/// Trait pour les moteurs de signature\npub trait SigningEngine {\n    type PrivateKey;\n    type PublicKey;\n    type Signature;\n    \n    /// G√©n√®re une nouvelle paire de cl√©s\n    fn generate_keypair() -\u003e CryptoResult\u003c(Self::PrivateKey, Self::PublicKey)\u003e;\n    \n    /// Signe un message\n    fn sign(private_key: \u0026Self::PrivateKey, message: \u0026[u8]) -\u003e CryptoResult\u003cSelf::Signature\u003e;\n    \n    /// V√©rifie une signature\n    fn verify(public_key: \u0026Self::PublicKey, message: \u0026[u8], signature: \u0026Self::Signature) -\u003e CryptoResult\u003cbool\u003e;\n}\n\n/// Cl√© priv√©e Ed25519 avec protection zeroize\n#[derive(ZeroizeOnDrop)]\npub struct Ed25519PrivateKey {\n    key: SigningKey,\n}\n\n/// Cl√© publique Ed25519\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub struct Ed25519PublicKey {\n    key: VerifyingKey,\n}\n\n/// Signature Ed25519\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub struct Ed25519Signature {\n    signature: Signature,\n}\n\n/// Paire de cl√©s Ed25519 compl√®te\n#[derive(ZeroizeOnDrop)]\npub struct Ed25519KeyPair {\n    private_key: Ed25519PrivateKey,\n    #[zeroize(skip)]\n    public_key: Ed25519PublicKey,\n}\n\n/// Signeur Ed25519 principal\npub struct Ed25519Signer;\n\nimpl Ed25519PrivateKey {\n    /// Cr√©e une cl√© priv√©e √† partir de bytes\n    pub fn from_bytes(bytes: \u0026[u8; 32]) -\u003e CryptoResult\u003cSelf\u003e {\n        let key = SigningKey::from_bytes(bytes);\n        Ok(Self { key })\n    }\n    \n    /// Exporte la cl√© priv√©e en bytes (attention : sensible !)\n    pub fn to_bytes(\u0026self) -\u003e [u8; 32] {\n        self.key.to_bytes()\n    }\n    \n    /// D√©rive la cl√© publique correspondante\n    pub fn public_key(\u0026self) -\u003e Ed25519PublicKey {\n        Ed25519PublicKey {\n            key: self.key.verifying_key(),\n        }\n    }\n}\n\nimpl Ed25519PublicKey {\n    /// Cr√©e une cl√© publique √† partir de bytes\n    pub fn from_bytes(bytes: \u0026[u8; PUBLIC_KEY_SIZE]) -\u003e CryptoResult\u003cSelf\u003e {\n        let key = VerifyingKey::from_bytes(bytes)\n            .map_err(|e| CryptoError::InvalidKeyFormat)?;\n        Ok(Self { key })\n    }\n    \n    /// Exporte la cl√© publique en bytes\n    pub fn to_bytes(\u0026self) -\u003e [u8; PUBLIC_KEY_SIZE] {\n        self.key.to_bytes()\n    }\n    \n    /// Empreinte de la cl√© publique (hash des premiers 8 bytes)\n    pub fn fingerprint(\u0026self) -\u003e [u8; 8] {\n        let bytes = self.to_bytes();\n        let mut hasher = blake3::Hasher::new();\n        hasher.update(\u0026bytes);\n        let hash = hasher.finalize();\n        let hash_bytes = hash.as_bytes();\n        [\n            hash_bytes[0], hash_bytes[1], hash_bytes[2], hash_bytes[3],\n            hash_bytes[4], hash_bytes[5], hash_bytes[6], hash_bytes[7],\n        ]\n    }\n}\n\nimpl Ed25519Signature {\n    /// Cr√©e une signature √† partir de bytes\n    pub fn from_bytes(bytes: \u0026[u8; SIGNATURE_SIZE]) -\u003e CryptoResult\u003cSelf\u003e {\n        let signature = Signature::from_bytes(bytes);\n        Ok(Self { signature })\n    }\n    \n    /// Exporte la signature en bytes\n    pub fn to_bytes(\u0026self) -\u003e [u8; SIGNATURE_SIZE] {\n        self.signature.to_bytes()\n    }\n}\n\nimpl Ed25519KeyPair {\n    /// G√©n√®re une nouvelle paire de cl√©s\n    pub fn generate() -\u003e CryptoResult\u003cSelf\u003e {\n        let signing_key = SigningKey::generate(\u0026mut OsRng);\n        let private_key = Ed25519PrivateKey { key: signing_key };\n        let public_key = private_key.public_key();\n        \n        Ok(Self {\n            private_key,\n            public_key,\n        })\n    }\n    \n    /// Acc√®s √† la cl√© priv√©e\n    pub fn private_key(\u0026self) -\u003e \u0026Ed25519PrivateKey {\n        \u0026self.private_key\n    }\n    \n    /// Acc√®s √† la cl√© publique\n    pub fn public_key(\u0026self) -\u003e \u0026Ed25519PublicKey {\n        \u0026self.public_key\n    }\n    \n    /// Signe un message avec cette paire de cl√©s\n    pub fn sign(\u0026self, message: \u0026[u8]) -\u003e CryptoResult\u003cEd25519Signature\u003e {\n        let signature = self.private_key.key.sign(message);\n        Ok(Ed25519Signature { signature })\n    }\n    \n    /// V√©rifie une signature avec la cl√© publique de cette paire\n    pub fn verify(\u0026self, message: \u0026[u8], signature: \u0026Ed25519Signature) -\u003e CryptoResult\u003cbool\u003e {\n        match self.public_key.key.verify(message, \u0026signature.signature) {\n            Ok(()) =\u003e Ok(true),\n            Err(_) =\u003e Ok(false),\n        }\n    }\n}\n\nimpl SigningEngine for Ed25519Signer {\n    type PrivateKey = Ed25519PrivateKey;\n    type PublicKey = Ed25519PublicKey;\n    type Signature = Ed25519Signature;\n    \n    fn generate_keypair() -\u003e CryptoResult\u003c(Self::PrivateKey, Self::PublicKey)\u003e {\n        let keypair = Ed25519KeyPair::generate()?;\n        // Nous devons cloner car on ne peut pas move out of ZeroizeOnDrop\n        let signing_key = SigningKey::from_bytes(\u0026keypair.private_key.to_bytes());\n        let private_key = Ed25519PrivateKey { key: signing_key };\n        let public_key = private_key.public_key();\n        \n        Ok((private_key, public_key))\n    }\n    \n    fn sign(private_key: \u0026Self::PrivateKey, message: \u0026[u8]) -\u003e CryptoResult\u003cSelf::Signature\u003e {\n        let signature = private_key.key.sign(message);\n        Ok(Ed25519Signature { signature })\n    }\n    \n    fn verify(\n        public_key: \u0026Self::PublicKey, \n        message: \u0026[u8], \n        signature: \u0026Self::Signature\n    ) -\u003e CryptoResult\u003cbool\u003e {\n        match public_key.key.verify(message, \u0026signature.signature) {\n            Ok(()) =\u003e Ok(true),\n            Err(_) =\u003e Ok(false),\n        }\n    }\n}\n\n/// Gestionnaire de signatures avec v√©rification d'int√©grit√©\npub struct SignatureVerifier {\n    known_keys: std::collections::HashMap\u003c[u8; 8], Ed25519PublicKey\u003e,\n}\n\nimpl SignatureVerifier {\n    /// Cr√©e un nouveau v√©rificateur\n    pub fn new() -\u003e Self {\n        Self {\n            known_keys: std::collections::HashMap::new(),\n        }\n    }\n    \n    /// Ajoute une cl√© publique de confiance\n    pub fn add_trusted_key(\u0026mut self, public_key: Ed25519PublicKey) {\n        let fingerprint = public_key.fingerprint();\n        self.known_keys.insert(fingerprint, public_key);\n    }\n    \n    /// V√©rifie une signature avec une cl√© connue\n    pub fn verify_with_fingerprint(\n        \u0026self,\n        fingerprint: \u0026[u8; 8],\n        message: \u0026[u8],\n        signature: \u0026Ed25519Signature,\n    ) -\u003e CryptoResult\u003cbool\u003e {\n        let public_key = self.known_keys.get(fingerprint)\n            .ok_or_else(|| CryptoError::VerificationError(\"Cl√© publique inconnue\".into()))?;\n        \n        Ed25519Signer::verify(public_key, message, signature)\n    }\n    \n    /// Nombre de cl√©s de confiance\n    pub fn trusted_key_count(\u0026self) -\u003e usize {\n        self.known_keys.len()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_ed25519_keypair_generation() {\n        let keypair = Ed25519KeyPair::generate().unwrap();\n        let public_key = keypair.public_key();\n        \n        // V√©rifier les tailles\n        assert_eq!(public_key.to_bytes().len(), PUBLIC_KEY_SIZE);\n        assert_eq!(keypair.private_key().to_bytes().len(), 32);\n    }\n    \n    #[test]\n    fn test_ed25519_sign_verify() {\n        let keypair = Ed25519KeyPair::generate().unwrap();\n        let message = b\"Message de test pour Miaou\";\n        \n        let signature = keypair.sign(message).unwrap();\n        assert_eq!(signature.to_bytes().len(), SIGNATURE_SIZE);\n        \n        let is_valid = keypair.verify(message, \u0026signature).unwrap();\n        assert!(is_valid);\n    }\n    \n    #[test]\n    fn test_ed25519_sign_verify_wrong_message() {\n        let keypair = Ed25519KeyPair::generate().unwrap();\n        let message = b\"Message original\";\n        let wrong_message = b\"Message modifie\";\n        \n        let signature = keypair.sign(message).unwrap();\n        let is_valid = keypair.verify(wrong_message, \u0026signature).unwrap();\n        \n        assert!(!is_valid);\n    }\n    \n    #[test]\n    fn test_ed25519_signer_trait() {\n        let (private_key, public_key) = Ed25519Signer::generate_keypair().unwrap();\n        let message = b\"Test du trait SigningEngine\";\n        \n        let signature = Ed25519Signer::sign(\u0026private_key, message).unwrap();\n        let is_valid = Ed25519Signer::verify(\u0026public_key, message, \u0026signature).unwrap();\n        \n        assert!(is_valid);\n    }\n    \n    #[test]\n    fn test_public_key_fingerprint() {\n        let keypair1 = Ed25519KeyPair::generate().unwrap();\n        let keypair2 = Ed25519KeyPair::generate().unwrap();\n        \n        let fingerprint1 = keypair1.public_key().fingerprint();\n        let fingerprint2 = keypair2.public_key().fingerprint();\n        \n        assert_ne!(fingerprint1, fingerprint2);\n        assert_eq!(fingerprint1.len(), 8);\n    }\n    \n    #[test]\n    fn test_signature_verifier() {\n        let mut verifier = SignatureVerifier::new();\n        let keypair = Ed25519KeyPair::generate().unwrap();\n        let message = b\"Message avec verificateur\";\n        \n        // Ajouter la cl√© publique\n        verifier.add_trusted_key(keypair.public_key().clone());\n        assert_eq!(verifier.trusted_key_count(), 1);\n        \n        // Signer et v√©rifier\n        let signature = keypair.sign(message).unwrap();\n        let fingerprint = keypair.public_key().fingerprint();\n        \n        let is_valid = verifier.verify_with_fingerprint(\u0026fingerprint, message, \u0026signature).unwrap();\n        assert!(is_valid);\n    }\n    \n    #[test]\n    fn test_key_serialization() {\n        let keypair = Ed25519KeyPair::generate().unwrap();\n        let public_key = keypair.public_key();\n        \n        // S√©rialisation/d√©s√©rialisation de la cl√© publique\n        let bytes = public_key.to_bytes();\n        let restored_key = Ed25519PublicKey::from_bytes(\u0026bytes).unwrap();\n        \n        assert_eq!(public_key.to_bytes(), restored_key.to_bytes());\n    }\n}","traces":[],"covered":0,"coverable":0},{"path":["/","home","seb","Dev","miaou","src","core.rs"],"content":"// Module core - Logique m√©tier commune\n// Fonctionnalit√©s partag√©es entre toutes les plateformes\n\n/// Noyau central de l'application Miaou\npub struct MiaouCore {\n    /// Version actuelle de Miaou\n    pub version: String,\n    /// √âtat d'initialisation\n    pub initialized: bool,\n}\n\nimpl MiaouCore {\n    /// Cr√©e une nouvelle instance du noyau\n    pub fn new() -\u003e Self {\n        Self {\n            version: env!(\"CARGO_PKG_VERSION\").to_string(),\n            initialized: false,\n        }\n    }\n\n    /// Initialise le noyau Miaou\n    pub fn initialize(\u0026mut self) -\u003e Result\u003c(), String\u003e {\n        // Initialisation commune √† toutes les plateformes\n        self.initialized = true;\n        Ok(())\n    }\n\n    /// Retourne la version actuelle\n    pub fn get_version(\u0026self) -\u003e \u0026str {\n        \u0026self.version\n    }\n}\n\nimpl Default for MiaouCore {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}","traces":[],"covered":0,"coverable":0},{"path":["/","home","seb","Dev","miaou","src","lib.rs"],"content":"//! # Miaou v0.1.0 \"Premi√®re Griffe\"\n//!\n//! **Phase 1 :** Fondations cryptographiques et architecture modulaire\n//!\n//! ## Vue d'ensemble\n//!\n//! Cette version √©tablit les fondations cryptographiques s√©curis√©es de Miaou,\n//! une plateforme de communication d√©centralis√©e. Elle impl√©mente les primitives\n//! cryptographiques essentielles selon les principes de s√©curit√©, performance\n//! et d√©centralisation du projet.\n//!\n//! ## Architecture modulaire\n//!\n//! Miaou v0.1.0 adopte une architecture modulaire avec des crates s√©par√©s :\n//! - `miaou-crypto` : Primitives cryptographiques s√©curis√©es\n//! - `miaou-core` : Logique m√©tier centrale et abstractions\n//! - `miaou-cli` : Interface en ligne de commande\n\n#![warn(missing_docs)]\n#![warn(rustdoc::broken_intra_doc_links)]\n\n// Re-exports des crates modulaires\npub use miaou_core as core;\npub use miaou_crypto as crypto;\n\n// Re-exports pour compatibilit√© API\npub use miaou_core::{\n    initialize,\n    storage::{ProfileHandle, ProfileId, SecureStorage},\n    version_info, PlatformInterface, DEVELOPMENT_PHASE, VERSION, VERSION_NAME,\n};\n\npub use miaou_crypto::{\n    aead::{decrypt, encrypt_auto_nonce, AeadKeyRef, SealedData},\n    constants,\n    hash::{blake3_32, Blake3Engine, HashingEngine},\n    kdf::{hash_password, verify_password, Argon2Config},\n    sign::{Keypair, Signature, SigningKeyRef, VerifyingKeyRef},\n    CryptoError, CryptoProvider, CryptoResult, DefaultCryptoProvider,\n};\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_modular_architecture() {\n        // Test que les re-exports fonctionnent\n        let info = version_info();\n        assert!(info.contains(\"Miaou\"));\n\n        // Test crypto\n        assert!(crypto::test_crypto_availability().is_ok());\n\n        // Test core\n        assert!(initialize().is_ok());\n    }\n\n    #[test]\n    fn test_crypto_re_exports() {\n        // Test AEAD\n        let key = AeadKeyRef::from_bytes([42u8; 32]);\n        let plaintext = b\"test\";\n        let aad = b\"test_aad\";\n        let mut rng = rand_core::OsRng;\n\n        let encrypted = encrypt_auto_nonce(\u0026key, aad, plaintext, \u0026mut rng).unwrap();\n        let decrypted = decrypt(\u0026key, aad, \u0026encrypted).unwrap();\n        assert_eq!(\u0026decrypted, plaintext);\n\n        // Test signatures\n        let keypair = Keypair::generate();\n        let message = b\"test message\";\n        let signature = keypair.sign(message);\n        assert!(keypair.verify(message, \u0026signature).is_ok());\n\n        // Test hachage\n        let hash1 = blake3_32(b\"test\");\n        let hash2 = blake3_32(b\"test\");\n        assert_eq!(hash1, hash2);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","seb","Dev","miaou","src","mobile.rs"],"content":"// Module mobile - Sp√©cifique aux plateformes mobiles\n// Fonctionnalit√©s communes Android et iOS\n\nuse crate::{PlatformInterface, core::MiaouCore};\n\n/// Plateforme mobile (Android/iOS)\npub struct MobilePlatform {\n    core: MiaouCore,\n    platform_name: \u0026'static str,\n}\n\nimpl MobilePlatform {\n    /// Cr√©e une nouvelle plateforme mobile\n    pub fn new(platform_name: \u0026'static str) -\u003e Self {\n        Self {\n            core: MiaouCore::new(),\n            platform_name,\n        }\n    }\n}\n\nimpl PlatformInterface for MobilePlatform {\n    fn initialize(\u0026mut self) -\u003e Result\u003c(), String\u003e {\n        self.core.initialize()?;\n        println!(\"Initialisation mobile pour {}\", self.platform_name);\n        Ok(())\n    }\n\n    fn get_platform_name(\u0026self) -\u003e \u0026'static str {\n        self.platform_name\n    }\n}\n\n// Interface Android via JNI\n#[cfg(target_os = \"android\")]\npub mod android {\n    use jni::JNIEnv;\n    use jni::objects::{JClass, JString};\n    use jni::sys::jstring;\n    use super::*;\n\n    #[no_mangle]\n    pub extern \"system\" fn Java_net_nethttp_miaou_MiaouLib_hello(\n        env: JNIEnv,\n        _class: JClass,\n    ) -\u003e jstring {\n        let output = env.new_string(\"Miaou Android\")\n            .expect(\"Impossible de cr√©er une string Java\");\n        output.into_inner()\n    }\n\n    #[no_mangle]\n    pub extern \"system\" fn Java_net_nethttp_miaou_MiaouLib_initialize(\n        _env: JNIEnv,\n        _class: JClass,\n    ) {\n        let mut platform = MobilePlatform::new(\"Android\");\n        let _ = platform.initialize();\n    }\n}\n\n// Interface iOS via Objective-C\n#[cfg(target_os = \"ios\")]\npub mod ios {\n    use std::ffi::{CStr, CString};\n    use std::os::raw::c_char;\n    use super::*;\n\n    #[no_mangle]\n    pub extern \"C\" fn miaou_hello() -\u003e *const c_char {\n        let hello = CString::new(\"Miaou iOS\").unwrap();\n        hello.into_raw()\n    }\n\n    #[no_mangle]\n    pub extern \"C\" fn miaou_initialize() {\n        let mut platform = MobilePlatform::new(\"iOS\");\n        let _ = platform.initialize();\n    }\n\n    #[no_mangle]\n    pub extern \"C\" fn miaou_free_string(ptr: *mut c_char) {\n        if !ptr.is_null() {\n            unsafe {\n                CString::from_raw(ptr);\n            }\n        }\n    }\n}","traces":[],"covered":0,"coverable":0},{"path":["/","home","seb","Dev","miaou","templates","rustdoc_template.rs"],"content":"//! # Miaou v{VERSION} \"{VERSION_NAME}\"\n//! \n//! **Phase {PHASE_NUMBER} :** {PHASE_DESCRIPTION}\n//! \n//! ## Vue d'ensemble\n//! \n//! {VERSION_OVERVIEW_DESCRIPTION}\n//! \n//! Cette version de Miaou impl√©mente {KEY_FEATURES_SUMMARY} selon les principes\n//! de s√©curit√©, performance et d√©centralisation du projet.\n//! \n//! ## Architecture\n//! \n//! ```text\n//! {ASCII_ARCHITECTURE_DIAGRAM}\n//! ```\n//! \n//! ## Modules principaux\n//! \n//! - [`crypto`] - Primitives cryptographiques audit√©es (Phase 1+)\n//! - [`network`] - Communication P2P d√©centralis√©e (Phase 2+)\n//! - [`blockchain`] - Syst√®me √©conomique et croquettes (Phase 3+)\n//! - [`interfaces`] - Applications multi-plateformes (Phase 4+)\n//! - [`bridges`] - Interop√©rabilit√© protocoles existants (Phase 5+)\n//! - [`advanced`] - Fonctionnalit√©s avanc√©es et IA (Phase 6+)\n//! - [`governance`] - Gouvernance d√©centralis√©e et DAO (Phase 7+)\n//! \n//! ## Exemples d'usage rapide\n//! \n//! ### Cryptographie (Phase 1+)\n//! ```rust\n//! use miaou::crypto::{ChaCha20Poly1305, Ed25519};\n//! \n//! // Chiffrement authentifi√©\n//! let key = ChaCha20Poly1305::generate_key()?;\n//! let encrypted = key.encrypt(b\"Hello, Miaou!\", b\"unique_nonce_12\")?;\n//! let decrypted = key.decrypt(\u0026encrypted, b\"unique_nonce_12\")?;\n//! \n//! // Signatures num√©riques\n//! let keypair = Ed25519::generate_keypair()?;\n//! let signature = keypair.sign(b\"Message to sign\")?;\n//! assert!(keypair.verify(b\"Message to sign\", \u0026signature)?);\n//! ```\n//! \n//! ### R√©seau P2P (Phase 2+)\n//! ```rust\n//! use miaou::network::{P2PNode, PeerDiscovery};\n//! \n//! let mut node = P2PNode::new().await?;\n//! node.start_discovery().await?;\n//! \n//! // Envoi de message chiffr√©\n//! let peer_id = node.discover_peers().await?.first().unwrap();\n//! node.send_encrypted_message(peer_id, b\"Hello from Miaou!\").await?;\n//! ```\n//! \n//! ### Interface utilisateur (Phase 4+)\n//! ```rust\n//! use miaou::interfaces::{DesktopApp, MobileApp};\n//! \n//! // Application desktop\n//! let app = DesktopApp::new().await?;\n//! app.show_main_window().await?;\n//! \n//! // Support mobile\n//! #[cfg(target_os = \"android\")]\n//! let mobile_app = MobileApp::initialize_android()?;\n//! \n//! #[cfg(target_os = \"ios\")]\n//! let mobile_app = MobileApp::initialize_ios()?;\n//! ```\n//! \n//! ## S√©curit√© et audit\n//! \n//! ### Propri√©t√©s cryptographiques garanties\n//! \n//! - **Confidentialit√© :** Chiffrement ChaCha20-Poly1305 authenticated\n//! - **Int√©grit√© :** AEAD (Authenticated Encryption with Associated Data)\n//! - **Authenticit√© :** Signatures Ed25519 avec v√©rification obligatoire\n//! - **Forward Secrecy :** Double Ratchet pour messagerie (Phase 2+)\n//! - **Post-Quantum Ready :** Architecture pr√©par√©e aux algorithmes quantiques\n//! \n//! ### Standards et conformit√©\n//! \n//! - **RFC 8439 :** ChaCha20-Poly1305 AEAD\n//! - **RFC 8032 :** EdDSA signatures avec Ed25519\n//! - **RFC 3526 :** Diffie-Hellman groups pour √©changes de cl√©s\n//! - **NIST SP 800-185 :** SHAKE et fonctions d√©riv√©es\n//! - **Signal Protocol :** Double Ratchet pour messagerie s√©curis√©e\n//! \n//! ### Audit et tests\n//! \n//! ```rust\n//! // Tests avec vecteurs NIST officiels\n//! #[cfg(test)]\n//! mod crypto_known_answer_tests {\n//!     use super::*;\n//!     \n//!     #[test]\n//!     fn test_chacha20_poly1305_nist_vectors() {\n//!         // Vecteurs de test officiels IETF RFC 8439\n//!         let test_vectors = load_nist_test_vectors();\n//!         for vector in test_vectors {\n//!             let result = ChaCha20Poly1305::encrypt(\u0026vector.key, \u0026vector.plaintext, \u0026vector.nonce);\n//!             assert_eq!(result.unwrap(), vector.expected_ciphertext);\n//!         }\n//!     }\n//! }\n//! ```\n//! \n//! ## Performance et benchmarks\n//! \n//! ### Objectifs de performance par phase\n//! \n//! | Phase | M√©trique | Objectif | Actuel |\n//! |-------|----------|----------|---------|\n//! | 1 | Chiffrement | \u003e1GB/s | {CRYPTO_PERF} |\n//! | 2 | Latence P2P | \u003c100ms | {NETWORK_LATENCY} |\n//! | 3 | Tx/seconde | \u003e1000 | {BLOCKCHAIN_TPS} |\n//! | 4 | Startup time | \u003c2s | {STARTUP_TIME} |\n//! | 5 | Bridge latency | \u003c200ms | {BRIDGE_LATENCY} |\n//! | 6 | AI response | \u003c500ms | {AI_RESPONSE_TIME} |\n//! | 7 | Governance | \u003e10k votes/min | {GOVERNANCE_THROUGHPUT} |\n//! \n//! ### Benchmarks automatis√©s\n//! \n//! ```bash\n//! # Ex√©cution des benchmarks\n//! cargo bench\n//! \n//! # G√©n√©ration des rapports\n//! cargo bench -- --output-format html\n//! ```\n//! \n//! ## Compatibilit√© et plateformes\n//! \n//! ### Plateformes support√©es\n//! \n//! - **Desktop :** Linux, macOS, Windows (via Tauri)\n//! - **Mobile :** Android (API 21+), iOS (13.0+) \n//! - **Web :** Tous navigateurs modernes avec WebAssembly\n//! - **Serveur :** Linux x86_64, ARM64\n//! \n//! ### Versions Rust\n//! \n//! - **Minimum support√© :** Rust 1.70.0\n//! - **Recommand√© :** Rust stable (derni√®re version)\n//! - **Features requises :** `std`, editions 2021\n//! \n//! ## Changelog et migration\n//! \n//! ### Changements depuis v{PREVIOUS_VERSION}\n//! \n//! #### üéâ Nouvelles fonctionnalit√©s\n//! - {NEW_FEATURE_1}\n//! - {NEW_FEATURE_2}\n//! - {NEW_FEATURE_3}\n//! \n//! #### üîÑ Am√©liorations\n//! - {IMPROVEMENT_1}\n//! - {IMPROVEMENT_2}\n//! \n//! #### ‚ö†Ô∏è Breaking changes\n//! - {BREAKING_CHANGE_1}\n//! - {BREAKING_CHANGE_2}\n//! \n//! #### üêõ Corrections\n//! - {BUG_FIX_1}\n//! - {BUG_FIX_2}\n//! \n//! ### Guide de migration\n//! \n//! ```rust\n//! // Ancien code (v{PREVIOUS_VERSION})\n//! let old_api = OldMiaouClient::new();\n//! old_api.deprecated_method();\n//! \n//! // Nouveau code (v{VERSION})\n//! let new_api = MiaouClient::new().await?;\n//! new_api.improved_method().await?;\n//! ```\n//! \n//! ## Contribution et d√©veloppement\n//! \n//! ### Structure du projet\n//! \n//! ```text\n//! miaou/\n//! ‚îú‚îÄ‚îÄ src/\n//! ‚îÇ   ‚îú‚îÄ‚îÄ crypto/          # Primitives cryptographiques\n//! ‚îÇ   ‚îú‚îÄ‚îÄ network/         # Communication P2P\n//! ‚îÇ   ‚îú‚îÄ‚îÄ blockchain/      # Syst√®me √©conomique\n//! ‚îÇ   ‚îú‚îÄ‚îÄ interfaces/      # Applications utilisateur\n//! ‚îÇ   ‚îî‚îÄ‚îÄ lib.rs          # Point d'entr√©e principal\n//! ‚îú‚îÄ‚îÄ tests/\n//! ‚îÇ   ‚îú‚îÄ‚îÄ integration/     # Tests d'int√©gration\n//! ‚îÇ   ‚îú‚îÄ‚îÄ crypto_vectors/  # Vecteurs de test crypto\n//! ‚îÇ   ‚îî‚îÄ‚îÄ benchmarks/      # Benchmarks performance\n//! ‚îú‚îÄ‚îÄ docs/               # Documentation compl√®te\n//! ‚îî‚îÄ‚îÄ examples/           # Exemples d'usage\n//! ```\n//! \n//! ### Standards de d√©veloppement\n//! \n//! - **TDD obligatoire :** Tests avant code\n//! - **Couverture ‚â•90% :** Validation automatique\n//! - **Documentation :** 100% APIs publiques document√©es\n//! - **S√©curit√© :** Audit continu des d√©pendances\n//! - **Performance :** Benchmarks sur chaque PR\n//! \n//! ## Ressources et liens\n//! \n//! - **Repository :** \u003chttps://github.com/yrbane/miaou\u003e\n//! - **Documentation :** \u003chttps://docs.rs/miaou\u003e\n//! - **Changelog :** \u003chttps://github.com/yrbane/miaou/blob/main/CHANGELOG.md\u003e\n//! - **Issues :** \u003chttps://github.com/yrbane/miaou/issues\u003e\n//! - **Discussions :** \u003chttps://github.com/yrbane/miaou/discussions\u003e\n//! \n//! ---\n//! \n//! *Miaou - Communication d√©centralis√©e, s√©curis√©e et libre* üê±\n\n#![doc = include_str!(\"../README.md\")]\n#![doc(\n    html_logo_url = \"https://raw.githubusercontent.com/yrbane/miaou/main/assets/logo.svg\",\n    html_favicon_url = \"https://raw.githubusercontent.com/yrbane/miaou/main/assets/favicon.ico\",\n    html_root_url = \"https://docs.rs/miaou/\"\n)]\n\n// Configuration de documentation avanc√©e\n#![warn(missing_docs)]\n#![warn(rustdoc::missing_doc_code_examples)]\n#![warn(rustdoc::broken_intra_doc_links)]\n\n// Re-exports publics pour API simplifi√©e\npub use crypto::*;\npub use network::*;\npub use interfaces::*;\n\n// Modules principaux\npub mod crypto;\npub mod network;\npub mod blockchain;\npub mod interfaces;\npub mod bridges;\npub mod advanced;\npub mod governance;\n\n// Modules utilitaires\npub mod error;\npub mod config;\npub mod logging;","traces":[],"covered":0,"coverable":0},{"path":["/","home","seb","Dev","miaou","tests","crypto","basic_tests.rs"],"content":"//! Tests de base pour validation de Phase 1\n//! \n//! Tests simplifi√©s pour valider l'architecture cryptographique de base.\n\nuse miaou::crypto::{\n    hashing::{Blake3Hasher, Blake3Output, HashingEngine, Argon2Hasher, Argon2Config},\n    primitives::{random_bytes, secure_compare},\n    CryptoResult,\n};\n\n#[test]\nfn test_blake3_basic() {\n    let data = b\"test data for blake3\";\n    let hash1 = Blake3Hasher::hash(data);\n    let hash2 = Blake3Hasher::hash(data);\n    \n    // M√™me donn√©es = m√™me hash\n    assert_eq!(hash1, hash2);\n    \n    // Donn√©es diff√©rentes = hash diff√©rents\n    let hash3 = Blake3Hasher::hash(b\"different data\");\n    assert_ne!(hash1, hash3);\n}\n\n#[test]\nfn test_blake3_hex_encoding() {\n    let data = b\"test\";\n    let hash = Blake3Hasher::hash(data);\n    \n    let hex_string = hash.to_hex();\n    assert!(!hex_string.is_empty());\n    assert_eq!(hex_string.len(), 64); // 32 bytes * 2 chars/byte\n    \n    let decoded = Blake3Output::from_hex(\u0026hex_string).unwrap();\n    assert_eq!(hash, decoded);\n}\n\n#[test]\nfn test_random_bytes_generation() {\n    let bytes1 = random_bytes(32).unwrap();\n    let bytes2 = random_bytes(32).unwrap();\n    \n    assert_eq!(bytes1.len(), 32);\n    assert_eq!(bytes2.len(), 32);\n    assert_ne!(bytes1, bytes2); // Tr√®s improbable qu'ils soient identiques\n}\n\n#[test]\nfn test_secure_compare() {\n    let data1 = vec![1, 2, 3, 4, 5];\n    let data2 = vec![1, 2, 3, 4, 5];\n    let data3 = vec![1, 2, 3, 4, 6];\n    \n    assert!(secure_compare(\u0026data1, \u0026data2));\n    assert!(!secure_compare(\u0026data1, \u0026data3));\n}\n\n#[test]\nfn test_argon2_basic() {\n    let password = b\"test_password\";\n    let salt = b\"test_salt_16_bytes\";\n    let config = Argon2Config::fast_insecure();\n    \n    let key1 = Argon2Hasher::derive_key(password, salt, \u0026config).unwrap();\n    let key2 = Argon2Hasher::derive_key(password, salt, \u0026config).unwrap();\n    \n    assert_eq!(key1, key2);\n    assert_eq!(key1.len(), config.output_length as usize);\n}\n\n#[test]\nfn test_argon2_password_verification() {\n    let password = b\"secret_password\";\n    let config = Argon2Config::fast_insecure();\n    \n    let hash = Argon2Hasher::hash_password(password, \u0026config).unwrap();\n    \n    assert!(Argon2Hasher::verify_password(password, \u0026hash).unwrap());\n    assert!(!Argon2Hasher::verify_password(b\"wrong_password\", \u0026hash).unwrap());\n}\n\n#[test]\nfn test_crypto_constants() {\n    use miaou::crypto::{NONCE_SIZE, KEY_SIZE, SIGNATURE_SIZE, PUBLIC_KEY_SIZE};\n    \n    assert_eq!(NONCE_SIZE, 12);\n    assert_eq!(KEY_SIZE, 32);\n    assert_eq!(SIGNATURE_SIZE, 64);\n    assert_eq!(PUBLIC_KEY_SIZE, 32);\n}\n\n#[test]\nfn test_crypto_availability() {\n    assert!(miaou::initialize().is_ok());\n}\n\n#[test]\nfn test_blake3_context_different() {\n    let data = b\"same data\";\n    let hash1 = Blake3Hasher::hash_with_context(data, \"context1\");\n    let hash2 = Blake3Hasher::hash_with_context(data, \"context2\");\n    \n    assert_ne!(hash1, hash2);\n}\n\n#[test]\nfn test_blake3_keyed_hashing() {\n    let key = [42u8; 32];\n    let data = b\"test data\";\n    \n    let hash1 = Blake3Hasher::hash_keyed(\u0026key, data);\n    let hash2 = Blake3Hasher::hash_keyed(\u0026key, data);\n    \n    assert_eq!(hash1, hash2);\n    \n    // Avec une cl√© diff√©rente\n    let key2 = [43u8; 32];\n    let hash3 = Blake3Hasher::hash_keyed(\u0026key2, data);\n    assert_ne!(hash1, hash3);\n}\n\n#[test] \nfn test_blake3_multiple_items() {\n    let items = [b\"part1\".as_slice(), b\"part2\".as_slice(), b\"part3\".as_slice()];\n    let hash1 = Blake3Hasher::hash_multiple(\u0026items);\n    \n    // M√™me donn√©es = m√™me hash\n    let hash2 = Blake3Hasher::hash_multiple(\u0026items);\n    assert_eq!(hash1, hash2);\n    \n    // Ordre diff√©rent = hash diff√©rent\n    let items_reordered = [b\"part2\".as_slice(), b\"part1\".as_slice(), b\"part3\".as_slice()];\n    let hash3 = Blake3Hasher::hash_multiple(\u0026items_reordered);\n    assert_ne!(hash1, hash3);\n}\n\n#[test]\nfn test_performance_basic() {\n    use std::time::Instant;\n    \n    let data = vec![0x42; 1024]; // 1KB\n    let start = Instant::now();\n    \n    for _ in 0..1000 {\n        let _hash = Blake3Hasher::hash(\u0026data);\n    }\n    \n    let duration = start.elapsed();\n    println!(\"1000 hashes de 1KB: {:?}\", duration);\n    \n    // Test basique de performance (devrait √™tre rapide)\n    assert!(duration.as_millis() \u003c 1000);\n}","traces":[],"covered":0,"coverable":0},{"path":["/","home","seb","Dev","miaou","tests","crypto","integration_tests.rs"],"content":"//! Tests d'int√©gration cryptographiques\n//! \n//! Tests de sc√©narios r√©alistes combinant plusieurs composants cryptographiques.\n\nuse miaou::crypto::{\n    encryption::{ChaCha20Poly1305Cipher, EncryptionEngine},\n    signing::{Ed25519KeyPair, Ed25519Signer, SigningEngine},\n    hashing::{Blake3Hasher, Argon2Hasher, Argon2Config},\n    keyring::{KeyStore, KeyStoreConfig, SecretKey, KeyPair},\n    primitives::{derive_subkey, SecureIdGenerator},\n};\n\n/// Test d'un sc√©nario complet de communication s√©curis√©e\n#[test]\nfn test_secure_communication_scenario() {\n    // Alice et Bob g√©n√®rent leurs paires de cl√©s\n    let alice_keypair = Ed25519KeyPair::generate().unwrap();\n    let bob_keypair = Ed25519KeyPair::generate().unwrap();\n    \n    // Alice veut envoyer un message chiffr√© et sign√© √† Bob\n    let message = b\"Message secret d'Alice pour Bob dans Miaou\";\n    \n    // 1. Alice g√©n√®re une cl√© de session √©ph√©m√®re\n    let session_cipher = ChaCha20Poly1305Cipher::generate_key().unwrap();\n    \n    // 2. Alice chiffre le message avec la cl√© de session\n    let encrypted_message = session_cipher.encrypt_with_random_nonce(message).unwrap();\n    \n    // 3. Alice signe le message chiffr√© pour authentification\n    let signature = alice_keypair.sign(\u0026encrypted_message.ciphertext).unwrap();\n    \n    // 4. Alice s√©rialise tout pour transmission\n    let communication_packet = CommunicationPacket {\n        encrypted_message,\n        signature: signature.to_bytes(),\n        sender_public_key: alice_keypair.public_key().to_bytes(),\n    };\n    \n    let serialized = bincode::serialize(\u0026communication_packet).unwrap();\n    \n    // === TRANSMISSION R√âSEAU (simul√©e) ===\n    \n    // 5. Bob re√ßoit et d√©s√©rialise\n    let received_packet: CommunicationPacket = bincode::deserialize(\u0026serialized).unwrap();\n    \n    // 6. Bob v√©rifie la signature\n    let alice_public_key = miaou::crypto::signing::Ed25519PublicKey::from_bytes(\n        \u0026received_packet.sender_public_key\n    ).unwrap();\n    let received_signature = miaou::crypto::signing::Ed25519Signature::from_bytes(\n        \u0026received_packet.signature\n    ).unwrap();\n    \n    let signature_valid = Ed25519Signer::verify(\n        \u0026alice_public_key,\n        \u0026received_packet.encrypted_message.ciphertext,\n        \u0026received_signature\n    ).unwrap();\n    \n    assert!(signature_valid, \"Signature invalide\");\n    \n    // 7. Bob d√©chiffre le message (il faudrait un √©change de cl√©s en pratique)\n    let decrypted = session_cipher.decrypt_with_nonce(\u0026received_packet.encrypted_message).unwrap();\n    \n    assert_eq!(decrypted, message);\n}\n\n#[derive(serde::Serialize, serde::Deserialize)]\nstruct CommunicationPacket {\n    encrypted_message: miaou::crypto::encryption::EncryptedData,\n    signature: [u8; 64],\n    sender_public_key: [u8; 32],\n}\n\n/// Test d'un trousseau de cl√©s complet avec hi√©rarchie\n#[test]\nfn test_hierarchical_key_management() {\n    let config = KeyStoreConfig {\n        argon2_config: Argon2Config::fast_insecure(), // Pour test rapide\n        ..KeyStoreConfig::default()\n    };\n    \n    let mut keystore = KeyStore::new_with_password(b\"master_password_123\", config).unwrap();\n    \n    // Cr√©er une hi√©rarchie de cl√©s\n    let master_seed = b\"master_seed_for_miaou_user_alice\";\n    \n    // Cl√©s de niveau 1 : par cat√©gorie\n    let encryption_master = derive_subkey(master_seed, \"encryption\", 0);\n    let signing_master = derive_subkey(master_seed, \"signing\", 0);\n    let storage_master = derive_subkey(master_seed, \"storage\", 0);\n    \n    // Cl√©s de niveau 2 : par usage sp√©cifique\n    let message_key = derive_subkey(\u0026encryption_master, \"messages\", 0);\n    let file_key = derive_subkey(\u0026encryption_master, \"files\", 0);\n    let metadata_key = derive_subkey(\u0026storage_master, \"metadata\", 0);\n    \n    // Ajouter au trousseau\n    let keys = vec![\n        (\"encryption_master\", encryption_master.to_vec()),\n        (\"signing_master\", signing_master.to_vec()),\n        (\"storage_master\", storage_master.to_vec()),\n        (\"message_key\", message_key.to_vec()),\n        (\"file_key\", file_key.to_vec()),\n        (\"metadata_key\", metadata_key.to_vec()),\n    ];\n    \n    let mut key_ids = Vec::new();\n    \n    for (name, key_data) in keys {\n        let secret_key = SecretKey::new(\n            key_data,\n            miaou::crypto::keyring::KeyMetadata {\n                key_id: miaou::crypto::primitives::random_array().unwrap(),\n                key_type: miaou::crypto::keyring::KeyType::Derived {\n                    context: name.to_string()\n                },\n                name: name.to_string(),\n                created_at: std::time::SystemTime::now()\n                    .duration_since(std::time::UNIX_EPOCH)\n                    .unwrap()\n                    .as_secs(),\n                expires_at: None,\n                is_active: true,\n                tags: vec![\"hierarchical\".to_string()],\n            }\n        );\n        \n        let key_id = secret_key.metadata().key_id;\n        key_ids.push((name, key_id));\n        keystore.add_secret_key(secret_key).unwrap();\n    }\n    \n    // V√©rifier que toutes les cl√©s sont r√©cup√©rables\n    for (name, key_id) in \u0026key_ids {\n        let retrieved = keystore.get_secret_key(key_id).unwrap();\n        assert!(retrieved.is_some(), \"Cl√© {} non trouv√©e\", name);\n        assert_eq!(retrieved.unwrap().metadata().name, *name);\n    }\n    \n    // Test export/import du trousseau\n    let exported = keystore.export_encrypted().unwrap();\n    \n    let mut new_keystore = KeyStore::new_with_password(\n        b\"master_password_123\", \n        KeyStoreConfig {\n            argon2_config: Argon2Config::fast_insecure(),\n            ..KeyStoreConfig::default()\n        }\n    ).unwrap();\n    \n    new_keystore.import_encrypted(\u0026exported).unwrap();\n    \n    // V√©rifier que l'import a fonctionn√©\n    for (name, key_id) in \u0026key_ids {\n        let retrieved = new_keystore.get_secret_key(key_id).unwrap();\n        assert!(retrieved.is_some(), \"Cl√© {} non trouv√©e apr√®s import\", name);\n    }\n}\n\n/// Test de performance et r√©sistance aux attaques\n#[test]\nfn test_crypto_performance_and_security() {\n    let start = std::time::Instant::now();\n    \n    // Test de performance du chiffrement\n    let cipher = ChaCha20Poly1305Cipher::generate_key().unwrap();\n    let large_data = vec![0x42; 1024 * 1024]; // 1MB\n    \n    let encrypted = cipher.encrypt_with_random_nonce(\u0026large_data).unwrap();\n    let decrypted = cipher.decrypt_with_nonce(\u0026encrypted).unwrap();\n    \n    assert_eq!(decrypted, large_data);\n    \n    let encryption_time = start.elapsed();\n    println!(\"Chiffrement/d√©chiffrement 1MB: {:?}\", encryption_time);\n    \n    // Test de performance des signatures\n    let start = std::time::Instant::now();\n    let keypair = Ed25519KeyPair::generate().unwrap();\n    let message = b\"Message pour test de performance de signature\";\n    \n    for _ in 0..1000 {\n        let signature = keypair.sign(message).unwrap();\n        let valid = keypair.verify(message, \u0026signature).unwrap();\n        assert!(valid);\n    }\n    \n    let signing_time = start.elapsed();\n    println!(\"1000 signatures/v√©rifications: {:?}\", signing_time);\n    \n    // Test de performance du hachage\n    let start = std::time::Instant::now();\n    let data = vec![0x33; 1024 * 1024]; // 1MB\n    \n    for _ in 0..10 {\n        let _hash = Blake3Hasher::hash(\u0026data);\n    }\n    \n    let hashing_time = start.elapsed();\n    println!(\"10 hachages de 1MB: {:?}\", hashing_time);\n    \n    // Les performances doivent √™tre raisonnables (ajustez selon votre mat√©riel)\n    assert!(encryption_time.as_millis() \u003c 1000, \"Chiffrement trop lent\");\n    assert!(signing_time.as_millis() \u003c 1000, \"Signatures trop lentes\");\n    assert!(hashing_time.as_millis() \u003c 1000, \"Hachage trop lent\");\n}\n\n/// Test de s√©curit√© : tentatives d'attaques courantes\n#[test]\nfn test_security_against_common_attacks() {\n    // Test contre r√©utilisation de nonce\n    let cipher = ChaCha20Poly1305Cipher::generate_key().unwrap();\n    let nonce = [0u8; 12]; // Nonce fixe (MAUVAISE PRATIQUE)\n    \n    let message1 = b\"Premier message\";\n    let message2 = b\"Second message\";\n    \n    let ciphertext1 = cipher.encrypt(message1, \u0026nonce).unwrap();\n    let ciphertext2 = cipher.encrypt(message2, \u0026nonce).unwrap();\n    \n    // M√™me nonce = probl√®me de s√©curit√© d√©tectable\n    // En pratique, on ne devrait jamais faire √ßa\n    assert_ne!(ciphertext1, ciphertext2); // Toujours diff√©rents gr√¢ce au contenu\n    \n    // Test contre modification de ciphertext\n    let mut corrupted_ciphertext = ciphertext1.clone();\n    corrupted_ciphertext[0] ^= 1; // Corruption d'un bit\n    \n    let decrypt_result = cipher.decrypt(\u0026corrupted_ciphertext, \u0026nonce);\n    assert!(decrypt_result.is_err(), \"D√©chiffrement corrompu aurait d√ª √©chouer\");\n    \n    // Test contre cl√©s faibles\n    let weak_key = [0u8; 32]; // Cl√© nulle\n    let weak_cipher = ChaCha20Poly1305Cipher::from_key(\u0026weak_key).unwrap();\n    \n    // M√™me avec une cl√© faible, l'algorithme doit fonctionner\n    let encrypted = weak_cipher.encrypt_with_random_nonce(b\"test\").unwrap();\n    let decrypted = weak_cipher.decrypt_with_nonce(\u0026encrypted).unwrap();\n    assert_eq!(decrypted, b\"test\");\n    \n    // Test contre signatures malform√©es\n    let keypair = Ed25519KeyPair::generate().unwrap();\n    let message = b\"Test message\";\n    let valid_signature = keypair.sign(message).unwrap();\n    \n    // Signature avec tous les bits √† 1 (invalide)\n    let invalid_signature = miaou::crypto::signing::Ed25519Signature::from_bytes(\u0026[0xFF; 64]).unwrap();\n    let verification = keypair.verify(message, \u0026invalid_signature).unwrap();\n    assert!(!verification, \"Signature invalide accept√©e\");\n    \n    // Signature avec tous les bits √† 0 (invalide)\n    let zero_signature = miaou::crypto::signing::Ed25519Signature::from_bytes(\u0026[0x00; 64]).unwrap();\n    let verification = keypair.verify(message, \u0026zero_signature).unwrap();\n    assert!(!verification, \"Signature nulle accept√©e\");\n}\n\n/// Test de g√©n√©ration d'identifiants uniques\n#[test]\nfn test_unique_id_generation() {\n    let generator = SecureIdGenerator::new().unwrap();\n    let mut ids = std::collections::HashSet::new();\n    \n    // G√©n√©rer beaucoup d'IDs rapidement\n    for _ in 0..10000 {\n        let id = generator.generate_id();\n        assert!(ids.insert(id), \"ID dupliqu√© d√©tect√©\");\n    }\n    \n    // Test sur plusieurs g√©n√©rateurs (simulation de n≈ìuds diff√©rents)\n    let generator2 = SecureIdGenerator::new().unwrap();\n    let generator3 = SecureIdGenerator::new().unwrap();\n    \n    for _ in 0..1000 {\n        let id1 = generator.generate_id();\n        let id2 = generator2.generate_id();\n        let id3 = generator3.generate_id();\n        \n        assert!(ids.insert(id1));\n        assert!(ids.insert(id2));\n        assert!(ids.insert(id3));\n    }\n    \n    println!(\"G√©n√©r√© {} IDs uniques\", ids.len());\n}\n\n/// Test de sc√©nario de sauvegarde et r√©cup√©ration\n#[test]\nfn test_backup_and_recovery_scenario() {\n    // Simulation d'un utilisateur qui sauvegarde ses cl√©s\n    let original_password = b\"user_password_123\";\n    let config = KeyStoreConfig {\n        argon2_config: Argon2Config::fast_insecure(),\n        ..KeyStoreConfig::default()\n    };\n    \n    let mut original_keystore = KeyStore::new_with_password(original_password, config.clone()).unwrap();\n    \n    // Cr√©er plusieurs cl√©s importantes\n    let encryption_keypair = KeyPair::generate_ed25519(\"main_encryption\".to_string(), vec![\"primary\".to_string()]).unwrap();\n    let signing_keypair = KeyPair::generate_ed25519(\"main_signing\".to_string(), vec![\"primary\".to_string()]).unwrap();\n    \n    let encryption_key_id = encryption_keypair.private_key().metadata().key_id;\n    let signing_key_id = signing_keypair.private_key().metadata().key_id;\n    \n    original_keystore.add_secret_key(\n        SecretKey::new(\n            encryption_keypair.private_key().key_data().to_vec(),\n            encryption_keypair.private_key().metadata().clone()\n        )\n    ).unwrap();\n    \n    original_keystore.add_secret_key(\n        SecretKey::new(\n            signing_keypair.private_key().key_data().to_vec(),\n            signing_keypair.private_key().metadata().clone()\n        )\n    ).unwrap();\n    \n    // Sauvegarder\n    let backup_data = original_keystore.export_encrypted().unwrap();\n    \n    // Simulation : l'utilisateur perd son trousseau et doit le restaurer\n    let mut recovered_keystore = KeyStore::new_with_password(original_password, config).unwrap();\n    recovered_keystore.import_encrypted(\u0026backup_data).unwrap();\n    \n    // V√©rifier que les cl√©s sont r√©cup√©r√©es\n    let recovered_encryption = recovered_keystore.get_secret_key(\u0026encryption_key_id).unwrap();\n    let recovered_signing = recovered_keystore.get_secret_key(\u0026signing_key_id).unwrap();\n    \n    assert!(recovered_encryption.is_some());\n    assert!(recovered_signing.is_some());\n    \n    // V√©rifier que les cl√©s fonctionnent encore\n    let test_message = b\"Test apr√®s r√©cup√©ration\";\n    \n    // Test de chiffrement\n    let recovered_enc_data = recovered_encryption.unwrap().key_data();\n    let mut enc_key_array = [0u8; 32];\n    enc_key_array.copy_from_slice(\u0026recovered_enc_data[0..32]);\n    let cipher = ChaCha20Poly1305Cipher::from_key(\u0026enc_key_array).unwrap();\n    \n    let encrypted = cipher.encrypt_with_random_nonce(test_message).unwrap();\n    let decrypted = cipher.decrypt_with_nonce(\u0026encrypted).unwrap();\n    assert_eq!(decrypted, test_message);\n    \n    // Test de signature\n    let recovered_sign_data = recovered_signing.unwrap().key_data();\n    let mut sign_key_array = [0u8; 32];\n    sign_key_array.copy_from_slice(\u0026recovered_sign_data[0..32]);\n    let private_key = miaou::crypto::signing::Ed25519PrivateKey::from_bytes(\u0026sign_key_array).unwrap();\n    \n    let signature = Ed25519Signer::sign(\u0026private_key, test_message).unwrap();\n    let public_key = private_key.public_key();\n    let is_valid = Ed25519Signer::verify(\u0026public_key, test_message, \u0026signature).unwrap();\n    assert!(is_valid);\n    \n    println!(\"Sauvegarde et r√©cup√©ration r√©ussies !\");\n}","traces":[],"covered":0,"coverable":0},{"path":["/","home","seb","Dev","miaou","tests","crypto","known_answer_tests.rs"],"content":"//! Tests cryptographiques avec vecteurs connus (KAT - Known Answer Tests)\n//! \n//! Ces tests utilisent des vecteurs officiels NIST/IETF pour valider\n//! l'impl√©mentation cryptographique de Miaou.\n\nuse miaou::crypto::{\n    encryption::{ChaCha20Poly1305Cipher, EncryptionEngine},\n    signing::{Ed25519Signer, SigningEngine, Ed25519PrivateKey, Ed25519PublicKey, Ed25519Signature},\n    hashing::{Blake3Hasher, HashingEngine, Blake3Output},\n};\n\n/// Tests ChaCha20-Poly1305 avec vecteurs RFC 8439\n#[cfg(test)]\nmod chacha20_poly1305_kat {\n    use super::*;\n    \n    #[test]\n    fn test_rfc8439_vector_1() {\n        // Vecteur de test officiel RFC 8439 Section 2.8.2\n        let key = [\n            0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n            0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n            0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,\n            0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,\n        ];\n        \n        let nonce = [\n            0x07, 0x00, 0x00, 0x00, 0x40, 0x41, 0x42, 0x43,\n            0x44, 0x45, 0x46, 0x47,\n        ];\n        \n        let plaintext = b\"Ladies and Gentlemen of the class of '99: If I could offer you only one tip for the future, sunscreen would be it.\";\n        \n        let expected_ciphertext = hex::decode(\n            \"d31a8d34648e60db7b86afbc53ef7ec2a4aded51296e08fea9e2b5a736ee62d63dbea45e8ca9671282fafb69da92728b1a71de0a9e060b2905d6a5b67ecd3b3692ddbd7f2d778b8c9803aee328091b58fab324e4fad675945585808b4831d7bc3ff4def08e4b7a9de576d26586cec64b6116177be3a9b38d89dd78f9de04dbd945f35f014b0e99e1e24e8ccac5b3a0b67ad4bec756b3c6b6bf5c0f325e33234e13b4b4c8bb1ab5e65b86f8b9e066ae4b3f8c93b9c4c89ee99b9ae6dc0e7a7c6ec6d0c0d0c0\"\n        ).unwrap();\n        \n        let cipher = ChaCha20Poly1305Cipher::from_key(\u0026key).unwrap();\n        let ciphertext = cipher.encrypt(plaintext, \u0026nonce).unwrap();\n        \n        // V√©rifier que notre impl√©mentation produit le r√©sultat attendu\n        assert_eq!(ciphertext.len(), plaintext.len() + 16); // +16 pour le tag Poly1305\n        \n        // V√©rifier que le d√©chiffrement fonctionne\n        let decrypted = cipher.decrypt(\u0026ciphertext, \u0026nonce).unwrap();\n        assert_eq!(decrypted, plaintext);\n    }\n    \n    #[test]\n    fn test_rfc8439_vector_2() {\n        // Test avec donn√©es vides\n        let key = [0u8; 32];\n        let nonce = [0u8; 12];\n        let plaintext = b\"\";\n        \n        let cipher = ChaCha20Poly1305Cipher::from_key(\u0026key).unwrap();\n        let ciphertext = cipher.encrypt(plaintext, \u0026nonce).unwrap();\n        \n        // M√™me avec donn√©es vides, on doit avoir un tag de 16 bytes\n        assert_eq!(ciphertext.len(), 16);\n        \n        let decrypted = cipher.decrypt(\u0026ciphertext, \u0026nonce).unwrap();\n        assert_eq!(decrypted, plaintext);\n    }\n    \n    #[test]\n    fn test_chacha20_poly1305_incremental_nonce() {\n        // Test avec nonces incr√©mentaux (usage typique)\n        let key = [1u8; 32];\n        let plaintext = b\"Message test avec nonce incremental\";\n        \n        let cipher = ChaCha20Poly1305Cipher::from_key(\u0026key).unwrap();\n        \n        for i in 0u32..10 {\n            let mut nonce = [0u8; 12];\n            nonce[8..12].copy_from_slice(\u0026i.to_le_bytes());\n            \n            let ciphertext = cipher.encrypt(plaintext, \u0026nonce).unwrap();\n            let decrypted = cipher.decrypt(\u0026ciphertext, \u0026nonce).unwrap();\n            \n            assert_eq!(decrypted, plaintext);\n        }\n    }\n}\n\n/// Tests Ed25519 avec vecteurs RFC 8032\n#[cfg(test)]\nmod ed25519_kat {\n    use super::*;\n    \n    #[test]\n    fn test_rfc8032_vector_1() {\n        // Vecteur de test officiel RFC 8032 Section 7.1\n        let private_key_bytes = hex::decode(\n            \"9d61b19deffd5a60ba844af492ec2cc44449c5697b326919703bac031cae7f60\"\n        ).unwrap();\n        \n        let public_key_bytes = hex::decode(\n            \"d75a980182b10ab7d54bfed3c964073a0ee172f3daa62325af021a68f707511a\"\n        ).unwrap();\n        \n        let message = hex::decode(\"\").unwrap(); // Message vide\n        \n        let expected_signature = hex::decode(\n            \"e5564300c360ac729086e2cc806e828a84877f1eb8e5d974d873e065224901555fb8821590a33bacc61e39701cf9b46bd25bf5f0595bbe24655141438e7a100b\"\n        ).unwrap();\n        \n        // Cr√©er les cl√©s\n        let mut private_key_array = [0u8; 32];\n        private_key_array.copy_from_slice(\u0026private_key_bytes);\n        let private_key = Ed25519PrivateKey::from_bytes(\u0026private_key_array).unwrap();\n        \n        let mut public_key_array = [0u8; 32];\n        public_key_array.copy_from_slice(\u0026public_key_bytes);\n        let public_key = Ed25519PublicKey::from_bytes(\u0026public_key_array).unwrap();\n        \n        // V√©rifier que notre cl√© publique correspond\n        assert_eq!(private_key.public_key().to_bytes(), public_key.to_bytes());\n        \n        // Signer et v√©rifier\n        let signature = Ed25519Signer::sign(\u0026private_key, \u0026message).unwrap();\n        let mut expected_sig_array = [0u8; 64];\n        expected_sig_array.copy_from_slice(\u0026expected_signature);\n        let expected_sig = Ed25519Signature::from_bytes(\u0026expected_sig_array).unwrap();\n        \n        // Notre signature doit correspondre au vecteur attendu\n        assert_eq!(signature.to_bytes(), expected_sig.to_bytes());\n        \n        // V√©rification doit r√©ussir\n        assert!(Ed25519Signer::verify(\u0026public_key, \u0026message, \u0026signature).unwrap());\n    }\n    \n    #[test]\n    fn test_rfc8032_vector_3() {\n        // Vecteur avec message non vide\n        let private_key_bytes = hex::decode(\n            \"c5aa8df43f9f837bedb7442f31dcb7b166d38535076f094b85ce3a2e0b4458f7\"\n        ).unwrap();\n        \n        let message = hex::decode(\"af82\").unwrap();\n        \n        let expected_signature = hex::decode(\n            \"6291d657deec24024827e69c3abe01a30ce548a284743a445e3680d7db5ac3ac18ff9b538d16f290ae67f760984dc6594a7c15e9716ed28dc027beceea1ec40a\"\n        ).unwrap();\n        \n        let mut private_key_array = [0u8; 32];\n        private_key_array.copy_from_slice(\u0026private_key_bytes);\n        let private_key = Ed25519PrivateKey::from_bytes(\u0026private_key_array).unwrap();\n        \n        let signature = Ed25519Signer::sign(\u0026private_key, \u0026message).unwrap();\n        \n        let mut expected_sig_array = [0u8; 64];\n        expected_sig_array.copy_from_slice(\u0026expected_signature);\n        let expected_sig = Ed25519Signature::from_bytes(\u0026expected_sig_array).unwrap();\n        \n        assert_eq!(signature.to_bytes(), expected_sig.to_bytes());\n        \n        let public_key = private_key.public_key();\n        assert!(Ed25519Signer::verify(\u0026public_key, \u0026message, \u0026signature).unwrap());\n    }\n    \n    #[test]\n    fn test_ed25519_malformed_signature() {\n        // Test avec signature malform√©e (doit √©chouer)\n        let private_key_bytes = [1u8; 32];\n        let private_key = Ed25519PrivateKey::from_bytes(\u0026private_key_bytes).unwrap();\n        let public_key = private_key.public_key();\n        \n        let message = b\"test message\";\n        let valid_signature = Ed25519Signer::sign(\u0026private_key, message).unwrap();\n        \n        // Corrompre la signature\n        let mut corrupted_sig_bytes = valid_signature.to_bytes();\n        corrupted_sig_bytes[0] ^= 1;\n        let corrupted_signature = Ed25519Signature::from_bytes(\u0026corrupted_sig_bytes).unwrap();\n        \n        // La v√©rification doit √©chouer\n        assert!(!Ed25519Signer::verify(\u0026public_key, message, \u0026corrupted_signature).unwrap());\n    }\n}\n\n/// Tests BLAKE3 avec vecteurs officiels\n#[cfg(test)]\nmod blake3_kat {\n    use super::*;\n    \n    #[test]\n    fn test_blake3_empty_input() {\n        // Hash de l'entr√©e vide selon sp√©cification BLAKE3\n        let input = b\"\";\n        let hash = Blake3Hasher::hash(input);\n        \n        let expected = \"af1349b9f5f9a1a6a0404dea36dcc9499bcb25c9adc112b7cc9a93cae41f3262\";\n        assert_eq!(hash.to_hex(), expected);\n    }\n    \n    #[test]\n    fn test_blake3_abc() {\n        // Hash de \"abc\"\n        let input = b\"abc\";\n        let hash = Blake3Hasher::hash(input);\n        \n        let expected = \"6437b3ac38465133ffb63b75273a8db548c558465d79db03fd359c6cd5bd9d85\";\n        assert_eq!(hash.to_hex(), expected);\n    }\n    \n    #[test]\n    fn test_blake3_longer_input() {\n        // Test avec message plus long\n        let input = b\"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\";\n        let hash = Blake3Hasher::hash(input);\n        \n        // V√©rifier la longueur et la coh√©rence\n        assert_eq!(hash.as_bytes().len(), 32);\n        \n        // Hash doit √™tre d√©terministe\n        let hash2 = Blake3Hasher::hash(input);\n        assert_eq!(hash, hash2);\n    }\n    \n    #[test]\n    fn test_blake3_keyed_mode() {\n        // Test du mode keyed de BLAKE3\n        let key = [0u8; 32];\n        let input = b\"test data for keyed hash\";\n        \n        let hash1 = Blake3Hasher::hash_keyed(\u0026key, input);\n        let hash2 = Blake3Hasher::hash_keyed(\u0026key, input);\n        \n        // D√©terminisme\n        assert_eq!(hash1, hash2);\n        \n        // Diff√©rent du hash normal\n        let normal_hash = Blake3Hasher::hash(input);\n        assert_ne!(hash1, normal_hash);\n        \n        // Cl√© diff√©rente = hash diff√©rent\n        let different_key = [1u8; 32];\n        let hash3 = Blake3Hasher::hash_keyed(\u0026different_key, input);\n        assert_ne!(hash1, hash3);\n    }\n    \n    #[test]\n    fn test_blake3_derive_key() {\n        // Test de d√©rivation de cl√© BLAKE3\n        let context = \"BLAKE3 2019-12-27 16:29:52 test vectors context\";\n        let key_material = b\"key material\";\n        \n        let derived_key = Blake3Hasher::derive_key(context, key_material);\n        \n        // V√©rifier la longueur\n        assert_eq!(derived_key.len(), 32);\n        \n        // D√©terminisme\n        let derived_key2 = Blake3Hasher::derive_key(context, key_material);\n        assert_eq!(derived_key, derived_key2);\n        \n        // Contexte diff√©rent = cl√© diff√©rente\n        let derived_key3 = Blake3Hasher::derive_key(\"different context\", key_material);\n        assert_ne!(derived_key, derived_key3);\n    }\n}\n\n/// Tests de performance et propri√©t√©s\n#[cfg(test)]\nmod crypto_properties {\n    use super::*;\n    use std::collections::HashSet;\n    \n    #[test]\n    fn test_encryption_uniqueness() {\n        // V√©rifier que le m√™me plaintext avec des nonces diff√©rents produit des ciphertexts diff√©rents\n        let cipher = ChaCha20Poly1305Cipher::generate_key().unwrap();\n        let plaintext = b\"Message identique\";\n        \n        let mut ciphertexts = HashSet::new();\n        \n        for _ in 0..100 {\n            let encrypted = cipher.encrypt_with_random_nonce(plaintext).unwrap();\n            let serialized = bincode::serialize(\u0026encrypted).unwrap();\n            assert!(ciphertexts.insert(serialized), \"Ciphertext dupliqu√© d√©tect√©\");\n        }\n    }\n    \n    #[test]\n    fn test_signature_uniqueness() {\n        // V√©rifier que chaque paire de cl√©s g√©n√®re des signatures diff√©rentes pour le m√™me message\n        let message = b\"Message √† signer\";\n        let mut signatures = HashSet::new();\n        \n        for _ in 0..50 {\n            let (private_key, _) = Ed25519Signer::generate_keypair().unwrap();\n            let signature = Ed25519Signer::sign(\u0026private_key, message).unwrap();\n            assert!(signatures.insert(signature.to_bytes()), \"Signature dupliqu√©e d√©tect√©e\");\n        }\n    }\n    \n    #[test]\n    fn test_hash_avalanche_effect() {\n        // V√©rifier l'effet d'avalanche : un bit chang√© doit affecter ~50% des bits de sortie\n        let input1 = b\"test message for avalanche\";\n        let mut input2 = input1.clone();\n        input2[0] ^= 1; // Changer un seul bit\n        \n        let hash1 = Blake3Hasher::hash(input1);\n        let hash2 = Blake3Hasher::hash(\u0026input2);\n        \n        // Compter les bits diff√©rents\n        let mut different_bits = 0;\n        for i in 0..32 {\n            different_bits += (hash1.as_bytes()[i] ^ hash2.as_bytes()[i]).count_ones();\n        }\n        \n        // L'effet d'avalanche doit √™tre significatif (entre 30% et 70% des bits)\n        let total_bits = 256;\n        let percentage = (different_bits as f64 / total_bits as f64) * 100.0;\n        assert!(percentage \u003e 30.0 \u0026\u0026 percentage \u003c 70.0, \n                \"Effet d'avalanche insuffisant: {}%\", percentage);\n    }\n    \n    #[test]\n    fn test_random_distribution() {\n        // V√©rifier que les g√©n√©rateurs al√©atoires ont une distribution acceptable\n        use miaou::crypto::primitives::random_bytes;\n        \n        let mut byte_counts = [0u32; 256];\n        let sample_size = 10000;\n        \n        for _ in 0..sample_size {\n            let random = random_bytes(1).unwrap();\n            byte_counts[random[0] as usize] += 1;\n        }\n        \n        // V√©rifier que chaque valeur appara√Æt au moins quelques fois\n        let min_count = sample_size / 512; // Au moins 1/512 de la distribution\n        for (value, \u0026count) in byte_counts.iter().enumerate() {\n            assert!(count \u003e= min_count, \n                   \"Valeur {} sous-repr√©sent√©e: {} occurrences\", value, count);\n        }\n    }\n}\n\n/// Tests de r√©gression et cas limites\n#[cfg(test)]\nmod edge_cases {\n    use super::*;\n    \n    #[test]\n    fn test_large_message_encryption() {\n        // Test avec message de 1MB\n        let cipher = ChaCha20Poly1305Cipher::generate_key().unwrap();\n        let large_message = vec![0xAA; 1024 * 1024];\n        \n        let encrypted = cipher.encrypt_with_random_nonce(\u0026large_message).unwrap();\n        let decrypted = cipher.decrypt_with_nonce(\u0026encrypted).unwrap();\n        \n        assert_eq!(decrypted, large_message);\n    }\n    \n    #[test]\n    fn test_zero_length_encryption() {\n        // Test avec message vide\n        let cipher = ChaCha20Poly1305Cipher::generate_key().unwrap();\n        let empty_message = b\"\";\n        \n        let encrypted = cipher.encrypt_with_random_nonce(empty_message).unwrap();\n        let decrypted = cipher.decrypt_with_nonce(\u0026encrypted).unwrap();\n        \n        assert_eq!(decrypted, empty_message);\n        assert_eq!(encrypted.ciphertext.len(), 16); // Juste le tag Poly1305\n    }\n    \n    #[test]\n    fn test_signature_edge_cases() {\n        let (private_key, public_key) = Ed25519Signer::generate_keypair().unwrap();\n        \n        // Message vide\n        let empty_sig = Ed25519Signer::sign(\u0026private_key, b\"\").unwrap();\n        assert!(Ed25519Signer::verify(\u0026public_key, b\"\", \u0026empty_sig).unwrap());\n        \n        // Message de taille maximale pratique (64KB)\n        let large_message = vec![0x42; 65536];\n        let large_sig = Ed25519Signer::sign(\u0026private_key, \u0026large_message).unwrap();\n        assert!(Ed25519Signer::verify(\u0026public_key, \u0026large_message, \u0026large_sig).unwrap());\n    }\n}","traces":[],"covered":0,"coverable":0},{"path":["/","home","seb","Dev","miaou","tests","crypto","mod.rs"],"content":"//! Tests cryptographiques pour Miaou Phase 1\n//! \n//! Module de tests pour valider les primitives cryptographiques.\n\nmod basic_tests;","traces":[],"covered":0,"coverable":0},{"path":["/","home","seb","Dev","miaou","tests","crypto","property_tests.rs"],"content":"//! Tests de propri√©t√©s cryptographiques avec proptest\n//! \n//! Ces tests v√©rifient que les impl√©mentations respectent les propri√©t√©s\n//! math√©matiques requises ind√©pendamment des entr√©es sp√©cifiques.\n\nuse miaou::crypto::{\n    encryption::{ChaCha20Poly1305Cipher, EncryptionEngine},\n    signing::{Ed25519Signer, SigningEngine},\n    hashing::{Blake3Hasher, HashingEngine},\n    primitives::{random_bytes, secure_compare, xor_bytes},\n};\nuse proptest::prelude::*;\n\nproptest! {\n    /// Propri√©t√© : encrypt(decrypt(x)) = x pour tout x valide\n    #[test]\n    fn encryption_roundtrip_property(\n        plaintext in prop::collection::vec(any::\u003cu8\u003e(), 0..1000)\n    ) {\n        let cipher = ChaCha20Poly1305Cipher::generate_key().unwrap();\n        let encrypted = cipher.encrypt_with_random_nonce(\u0026plaintext).unwrap();\n        let decrypted = cipher.decrypt_with_nonce(\u0026encrypted).unwrap();\n        \n        prop_assert_eq!(plaintext, decrypted);\n    }\n    \n    /// Propri√©t√© : le m√™me plaintext avec nonces diff√©rents produit des ciphertexts diff√©rents\n    #[test]\n    fn encryption_semantic_security(\n        plaintext in prop::collection::vec(any::\u003cu8\u003e(), 1..100),\n        nonce1 in prop::array::uniform12(any::\u003cu8\u003e()),\n        nonce2 in prop::array::uniform12(any::\u003cu8\u003e())\n    ) {\n        prop_assume!(nonce1 != nonce2);\n        \n        let cipher = ChaCha20Poly1305Cipher::generate_key().unwrap();\n        let ciphertext1 = cipher.encrypt(\u0026plaintext, \u0026nonce1).unwrap();\n        let ciphertext2 = cipher.encrypt(\u0026plaintext, \u0026nonce2).unwrap();\n        \n        prop_assert_ne!(ciphertext1, ciphertext2);\n    }\n    \n    /// Propri√©t√© : verify(sign(m, sk), m, pk) = true pour toute paire (sk, pk) valide\n    #[test]\n    fn signature_correctness_property(\n        message in prop::collection::vec(any::\u003cu8\u003e(), 0..1000)\n    ) {\n        let (private_key, public_key) = Ed25519Signer::generate_keypair().unwrap();\n        let signature = Ed25519Signer::sign(\u0026private_key, \u0026message).unwrap();\n        let is_valid = Ed25519Signer::verify(\u0026public_key, \u0026message, \u0026signature).unwrap();\n        \n        prop_assert!(is_valid);\n    }\n    \n    /// Propri√©t√© : hash(x) = hash(x) (d√©terminisme)\n    #[test]\n    fn hash_determinism_property(\n        data in prop::collection::vec(any::\u003cu8\u003e(), 0..1000)\n    ) {\n        let hash1 = Blake3Hasher::hash(\u0026data);\n        let hash2 = Blake3Hasher::hash(\u0026data);\n        \n        prop_assert_eq!(hash1, hash2);\n    }\n    \n    /// Propri√©t√© : hash(x) ‚â† hash(y) si x ‚â† y (r√©sistance aux collisions - probabiliste)\n    #[test]\n    fn hash_collision_resistance_property(\n        data1 in prop::collection::vec(any::\u003cu8\u003e(), 1..100),\n        data2 in prop::collection::vec(any::\u003cu8\u003e(), 1..100)\n    ) {\n        prop_assume!(data1 != data2);\n        \n        let hash1 = Blake3Hasher::hash(\u0026data1);\n        let hash2 = Blake3Hasher::hash(\u0026data2);\n        \n        // Note : Ce test peut th√©oriquement √©chouer avec une probabilit√© de 2^-256\n        prop_assert_ne!(hash1, hash2);\n    }\n    \n    /// Propri√©t√© : secure_compare est commutatif\n    #[test]\n    fn secure_compare_commutativity(\n        data1 in prop::collection::vec(any::\u003cu8\u003e(), 0..100),\n        data2 in prop::collection::vec(any::\u003cu8\u003e(), 0..100)\n    ) {\n        let result1 = secure_compare(\u0026data1, \u0026data2);\n        let result2 = secure_compare(\u0026data2, \u0026data1);\n        \n        prop_assert_eq!(result1, result2);\n    }\n    \n    /// Propri√©t√© : secure_compare(x, x) = true\n    #[test]\n    fn secure_compare_reflexivity(\n        data in prop::collection::vec(any::\u003cu8\u003e(), 0..100)\n    ) {\n        prop_assert!(secure_compare(\u0026data, \u0026data));\n    }\n    \n    /// Propri√©t√© : XOR est son propre inverse\n    #[test]\n    fn xor_inverse_property(\n        data1 in prop::collection::vec(any::\u003cu8\u003e(), 1..100),\n        data2 in prop::collection::vec(any::\u003cu8\u003e(), 1..100)\n    ) {\n        prop_assume!(data1.len() == data2.len());\n        \n        let xor_result = xor_bytes(\u0026data1, \u0026data2).unwrap();\n        let double_xor = xor_bytes(\u0026xor_result, \u0026data2).unwrap();\n        \n        prop_assert_eq!(data1, double_xor);\n    }\n    \n    /// Propri√©t√© : XOR est commutatif\n    #[test]\n    fn xor_commutativity(\n        data1 in prop::collection::vec(any::\u003cu8\u003e(), 1..50),\n        data2 in prop::collection::vec(any::\u003cu8\u003e(), 1..50)\n    ) {\n        prop_assume!(data1.len() == data2.len());\n        \n        let result1 = xor_bytes(\u0026data1, \u0026data2).unwrap();\n        let result2 = xor_bytes(\u0026data2, \u0026data1).unwrap();\n        \n        prop_assert_eq!(result1, result2);\n    }\n    \n    /// Propri√©t√© : Les bytes al√©atoires ont une entropie raisonnable\n    #[test]\n    fn random_bytes_entropy(\n        length in 1usize..100\n    ) {\n        let random1 = random_bytes(length).unwrap();\n        let random2 = random_bytes(length).unwrap();\n        \n        prop_assert_eq!(random1.len(), length);\n        prop_assert_eq!(random2.len(), length);\n        \n        // Probabilit√© n√©gligeable d'√™tre identiques\n        if length \u003e 4 {\n            prop_assert_ne!(random1, random2);\n        }\n    }\n    \n    /// Propri√©t√© : Le chiffrement pr√©serve la longueur (+ tag)\n    #[test]\n    fn encryption_length_property(\n        plaintext in prop::collection::vec(any::\u003cu8\u003e(), 0..500)\n    ) {\n        let cipher = ChaCha20Poly1305Cipher::generate_key().unwrap();\n        let encrypted = cipher.encrypt_with_random_nonce(\u0026plaintext).unwrap();\n        \n        // ChaCha20-Poly1305 ajoute un tag de 16 bytes\n        prop_assert_eq!(encrypted.ciphertext.len(), plaintext.len() + 16);\n        prop_assert_eq!(encrypted.nonce.len(), 12);\n    }\n    \n    /// Propri√©t√© : Les signatures ont toujours la m√™me taille\n    #[test]\n    fn signature_length_property(\n        message in prop::collection::vec(any::\u003cu8\u003e(), 0..500)\n    ) {\n        let (private_key, _) = Ed25519Signer::generate_keypair().unwrap();\n        let signature = Ed25519Signer::sign(\u0026private_key, \u0026message).unwrap();\n        \n        prop_assert_eq!(signature.to_bytes().len(), 64);\n    }\n    \n    /// Propri√©t√© : Les hashs ont toujours 32 bytes\n    #[test]\n    fn hash_length_property(\n        data in prop::collection::vec(any::\u003cu8\u003e(), 0..1000)\n    ) {\n        let hash = Blake3Hasher::hash(\u0026data);\n        prop_assert_eq!(hash.as_bytes().len(), 32);\n    }\n}\n\n/// Tests de propri√©t√©s avec donn√©es structur√©es\n#[cfg(test)]\nmod structured_property_tests {\n    use super::*;\n    use miaou::crypto::keyring::{KeyStore, KeyStoreConfig, SecretKey};\n    \n    #[test]\n    fn test_keystore_invariants() {\n        // Test que le keystore maintient ses invariants\n        let config = KeyStoreConfig {\n            argon2_config: miaou::crypto::hashing::Argon2Config::fast_insecure(),\n            ..KeyStoreConfig::default()\n        };\n        \n        let mut keystore = KeyStore::new_with_password(b\"test_password\", config).unwrap();\n        \n        // G√©n√©rer plusieurs cl√©s\n        let mut key_ids = Vec::new();\n        for i in 0..10 {\n            let key = SecretKey::generate_encryption_key(\n                format!(\"key_{}\", i),\n                vec![format!(\"tag_{}\", i)]\n            ).unwrap();\n            let key_id = key.metadata().key_id;\n            key_ids.push(key_id);\n            keystore.add_secret_key(key).unwrap();\n        }\n        \n        // V√©rifier que toutes les cl√©s sont r√©cup√©rables\n        for key_id in \u0026key_ids {\n            let retrieved = keystore.get_secret_key(key_id).unwrap();\n            assert!(retrieved.is_some());\n        }\n        \n        // V√©rifier le compte des cl√©s\n        assert_eq!(keystore.list_keys().len(), 10);\n        \n        // Supprimer quelques cl√©s\n        for key_id in \u0026key_ids[0..5] {\n            assert!(keystore.remove_key(key_id).unwrap());\n        }\n        \n        // V√©rifier que les cl√©s supprim√©es ne sont plus l√†\n        for key_id in \u0026key_ids[0..5] {\n            assert!(keystore.get_secret_key(key_id).unwrap().is_none());\n        }\n        \n        // V√©rifier que les autres sont encore l√†\n        for key_id in \u0026key_ids[5..10] {\n            let retrieved = keystore.get_secret_key(key_id).unwrap();\n            assert!(retrieved.is_some());\n        }\n    }\n    \n    #[test]\n    fn test_encryption_with_context() {\n        // Test que le contexte affecte bien le r√©sultat\n        let data = b\"test data\";\n        \n        let hash1 = Blake3Hasher::hash_with_context(data, \"context1\");\n        let hash2 = Blake3Hasher::hash_with_context(data, \"context2\");\n        let hash3 = Blake3Hasher::hash_with_context(data, \"context1\"); // M√™me contexte\n        \n        assert_ne!(hash1, hash2);\n        assert_eq!(hash1, hash3);\n    }\n    \n    #[test]\n    fn test_key_derivation_consistency() {\n        // Test que la d√©rivation de cl√©s est coh√©rente\n        use miaou::crypto::primitives::derive_subkey;\n        \n        let master_key = [0x42; 32];\n        \n        for i in 0..10 {\n            let key1 = derive_subkey(\u0026master_key, \"encryption\", i);\n            let key2 = derive_subkey(\u0026master_key, \"encryption\", i);\n            \n            // M√™me param√®tres = m√™me cl√©\n            assert_eq!(key1, key2);\n            \n            if i \u003e 0 {\n                let key_prev = derive_subkey(\u0026master_key, \"encryption\", i - 1);\n                // Index diff√©rent = cl√© diff√©rente\n                assert_ne!(key1, key_prev);\n            }\n            \n            let key_diff_context = derive_subkey(\u0026master_key, \"signing\", i);\n            // Contexte diff√©rent = cl√© diff√©rente\n            assert_ne!(key1, key_diff_context);\n        }\n    }\n}","traces":[],"covered":0,"coverable":0}]};
        var previousData = {"files":[{"path":["/","home","seb","Dev","miaou","benches","crypto_bench.rs"],"content":"// Benchmarks d√©taill√©s pour les primitives cryptographiques\n// Performance tests pour Miaou v0.1.0\n\nuse criterion::{black_box, criterion_group, criterion_main, BenchmarkId, Criterion, Throughput};\nuse miaou_crypto::{\n    aead::{decrypt, encrypt_auto_nonce, AeadKeyRef},\n    hash::blake3_32,\n    kdf::{hash_password, Argon2Config},\n    sign::Keypair,\n};\nuse rand_core::OsRng;\nuse secrecy::SecretString;\n\nfn bench_blake3_hashing(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"blake3_hashing\");\n\n    // Test diff√©rentes tailles de donn√©es\n    for size in \u0026[1024, 4096, 16384, 65536, 262_144, 1_048_576] {\n        group.throughput(Throughput::Bytes(*size as u64));\n        let data = vec![0u8; *size];\n\n        group.bench_with_input(BenchmarkId::new(\"hash\", size), size, |b, \u0026_size| {\n            b.iter(|| blake3_32(black_box(\u0026data)));\n        });\n    }\n    group.finish();\n}\n\nfn bench_ed25519_operations(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"ed25519_operations\");\n\n    let keypair = Keypair::generate();\n    let message = b\"benchmark message for signature testing\";\n    let signature = keypair.sign(message);\n\n    group.bench_function(\"key_generation\", |b| b.iter(Keypair::generate));\n\n    group.bench_function(\"signing\", |b| b.iter(|| keypair.sign(black_box(message))));\n\n    group.bench_function(\"verification\", |b| {\n        b.iter(|| {\n            keypair\n                .verify(black_box(message), black_box(\u0026signature))\n                .unwrap();\n        });\n    });\n\n    group.finish();\n}\n\nfn bench_chacha20_poly1305(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"chacha20_poly1305\");\n\n    let key = AeadKeyRef::from_bytes([42u8; 32]);\n    let aad = b\"benchmark_aad\";\n    let mut rng = OsRng;\n\n    // Test diff√©rentes tailles de donn√©es\n    for size in \u0026[64, 256, 1024, 4096, 16384] {\n        group.throughput(Throughput::Bytes(*size as u64));\n        let data = vec![0u8; *size];\n        let encrypted = encrypt_auto_nonce(\u0026key, aad, \u0026data, \u0026mut rng).unwrap();\n\n        group.bench_with_input(BenchmarkId::new(\"encrypt\", size), size, |b, \u0026_size| {\n            b.iter(|| encrypt_auto_nonce(\u0026key, aad, black_box(\u0026data), \u0026mut rng).unwrap());\n        });\n\n        group.bench_with_input(BenchmarkId::new(\"decrypt\", size), size, |b, \u0026_size| {\n            b.iter(|| decrypt(\u0026key, aad, black_box(\u0026encrypted)).unwrap());\n        });\n    }\n    group.finish();\n}\n\nfn bench_argon2_kdf(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"argon2_kdf\");\n\n    let password = SecretString::new(\"test_password_for_benchmarking\".to_string());\n\n    group.bench_function(\"fast_insecure\", |b| {\n        let config = Argon2Config::fast_insecure();\n        b.iter(|| hash_password(black_box(\u0026password), black_box(\u0026config)).unwrap());\n    });\n\n    group.bench_function(\"balanced\", |b| {\n        let config = Argon2Config::balanced();\n        b.iter(|| hash_password(black_box(\u0026password), black_box(\u0026config)).unwrap());\n    });\n\n    group.bench_function(\"secure\", |b| {\n        let config = Argon2Config::secure();\n        b.iter(|| hash_password(black_box(\u0026password), black_box(\u0026config)).unwrap());\n    });\n\n    group.finish();\n}\n\nfn bench_combined_workflow(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"combined_workflow\");\n\n    // Workflow complet : g√©n√©ration cl√© + chiffrement + signature\n    let message = b\"Complete workflow test message\";\n    let aad = b\"workflow_test\";\n    let mut rng = OsRng;\n\n    group.bench_function(\"complete_encrypt_sign\", |b| {\n        b.iter(|| {\n            // G√©n√©ration des cl√©s\n            let keypair = Keypair::generate();\n            let aead_key = AeadKeyRef::from_bytes([42u8; 32]);\n\n            // Chiffrement\n            let encrypted =\n                encrypt_auto_nonce(\u0026aead_key, aad, black_box(message), \u0026mut rng).unwrap();\n\n            // Signature du chiffr√©\n            let signature = keypair.sign(\u0026encrypted.ciphertext);\n\n            // Hash du tout pour int√©grit√©\n            let mut combined = encrypted.ciphertext.clone();\n            combined.extend_from_slice(\u0026signature.to_bytes());\n            let _hash = blake3_32(\u0026combined);\n\n            (encrypted, signature)\n        });\n    });\n\n    group.finish();\n}\n\ncriterion_group!(\n    benches,\n    bench_blake3_hashing,\n    bench_ed25519_operations,\n    bench_chacha20_poly1305,\n    bench_argon2_kdf,\n    bench_combined_workflow\n);\ncriterion_main!(benches);\n","traces":[{"line":14,"address":[1139360,1139888,1139882],"length":1,"stats":{"Line":1}},{"line":15,"address":[1139378],"length":1,"stats":{"Line":1}},{"line":18,"address":[1139416,1139491],"length":1,"stats":{"Line":2}},{"line":19,"address":[1139596],"length":1,"stats":{"Line":1}},{"line":20,"address":[1139720],"length":1,"stats":{"Line":1}},{"line":22,"address":[1134318,1134288],"length":1,"stats":{"Line":4}},{"line":23,"address":[1134352,1134326,1134370],"length":1,"stats":{"Line":3}},{"line":26,"address":[1139647],"length":1,"stats":{"Line":1}},{"line":29,"address":[1139920,1140351,1140357],"length":1,"stats":{"Line":1}},{"line":30,"address":[1139938],"length":1,"stats":{"Line":1}},{"line":32,"address":[1139976],"length":1,"stats":{"Line":1}},{"line":33,"address":[1140036],"length":1,"stats":{"Line":1}},{"line":34,"address":[1140051],"length":1,"stats":{"Line":1}},{"line":36,"address":[1134416,1134441],"length":1,"stats":{"Line":3}},{"line":38,"address":[1134489,1134512,1134530,1134464],"length":1,"stats":{"Line":5}},{"line":40,"address":[1134592],"length":1,"stats":{"Line":2}},{"line":41,"address":[1134619,1134672],"length":1,"stats":{"Line":2}},{"line":42,"address":[1134686],"length":1,"stats":{"Line":1}},{"line":43,"address":[1134694],"length":1,"stats":{"Line":1}},{"line":44,"address":[1134761],"length":1,"stats":{"Line":1}},{"line":48,"address":[1140266],"length":1,"stats":{"Line":1}},{"line":51,"address":[1140384,1141402,1141408],"length":1,"stats":{"Line":1}},{"line":52,"address":[1140402],"length":1,"stats":{"Line":1}},{"line":54,"address":[1140440],"length":1,"stats":{"Line":1}},{"line":55,"address":[1140531],"length":1,"stats":{"Line":1}},{"line":59,"address":[1140546,1140621],"length":1,"stats":{"Line":2}},{"line":60,"address":[1140726],"length":1,"stats":{"Line":1}},{"line":61,"address":[1140869],"length":1,"stats":{"Line":1}},{"line":62,"address":[1140983,1140900],"length":1,"stats":{"Line":2}},{"line":64,"address":[1134784,1134816],"length":1,"stats":{"Line":4}},{"line":65,"address":[1134904,1134880,1134824],"length":1,"stats":{"Line":3}},{"line":68,"address":[1135072,1135040],"length":1,"stats":{"Line":3}},{"line":69,"address":[1135080,1135155,1135136],"length":1,"stats":{"Line":3}},{"line":72,"address":[1140777],"length":1,"stats":{"Line":1}},{"line":75,"address":[1141809,1141440,1141815],"length":1,"stats":{"Line":1}},{"line":76,"address":[1141458],"length":1,"stats":{"Line":1}},{"line":78,"address":[1141568,1141496],"length":1,"stats":{"Line":2}},{"line":80,"address":[1135248],"length":1,"stats":{"Line":2}},{"line":81,"address":[1135271],"length":1,"stats":{"Line":1}},{"line":82,"address":[1135312,1135291,1135335],"length":1,"stats":{"Line":3}},{"line":85,"address":[1135424],"length":1,"stats":{"Line":2}},{"line":86,"address":[1135447],"length":1,"stats":{"Line":1}},{"line":87,"address":[1135488,1135511,1135467],"length":1,"stats":{"Line":3}},{"line":90,"address":[1135600],"length":1,"stats":{"Line":2}},{"line":91,"address":[1135623],"length":1,"stats":{"Line":1}},{"line":92,"address":[1135687,1135664,1135643],"length":1,"stats":{"Line":3}},{"line":95,"address":[1141728],"length":1,"stats":{"Line":1}},{"line":98,"address":[1141840,1142115,1142140],"length":1,"stats":{"Line":1}},{"line":99,"address":[1141898],"length":1,"stats":{"Line":1}},{"line":102,"address":[1141858],"length":1,"stats":{"Line":1}},{"line":103,"address":[1141878],"length":1,"stats":{"Line":1}},{"line":106,"address":[1135776],"length":1,"stats":{"Line":2}},{"line":107,"address":[1136802,1135856,1136774,1135801],"length":1,"stats":{"Line":2}},{"line":109,"address":[1135886],"length":1,"stats":{"Line":1}},{"line":110,"address":[1135908],"length":1,"stats":{"Line":1}},{"line":114,"address":[1136004,1136099],"length":1,"stats":{"Line":2}},{"line":117,"address":[1136270,1136190],"length":1,"stats":{"Line":2}},{"line":120,"address":[1136294],"length":1,"stats":{"Line":1}},{"line":121,"address":[1136328,1136399],"length":1,"stats":{"Line":2}},{"line":122,"address":[1136438],"length":1,"stats":{"Line":1}},{"line":124,"address":[1136501],"length":1,"stats":{"Line":1}},{"line":128,"address":[1142049],"length":1,"stats":{"Line":1}},{"line":131,"address":[1142167],"length":1,"stats":{"Line":1}}],"covered":63,"coverable":63},{"path":["/","home","seb","Dev","miaou","miaou-cli","src","main.rs"],"content":"//! # Miaou CLI v0.1.0\n//!\n//! Interface de ligne de commande interactive pour Miaou.\n//!\n//! Fournit une CLI compl√®te pour la gestion des profils, tests cryptographiques,\n//! et toutes les fonctionnalit√©s de base de Miaou.\n\n#![warn(missing_docs)]\n#![warn(rustdoc::broken_intra_doc_links)]\n\nuse anyhow::{Context, Result};\nuse clap::{Parser, Subcommand};\nuse miaou_core::{\n    crypto::{\n        aead::{decrypt, encrypt_auto_nonce, AeadKeyRef},\n        hash::blake3_32,\n        kdf::{hash_password, verify_password, Argon2Config},\n        sign::Keypair,\n    },\n    initialize,\n    storage::SecureStorage,\n    version_info,\n};\nuse secrecy::{ExposeSecret, SecretString};\nuse std::io::{self, Write};\nuse std::path::PathBuf;\n\n#[derive(Parser)]\n#[command(name = \"miaou-cli\")]\n#[command(about = \"Interface de ligne de commande pour Miaou v0.1.0\")]\n#[command(version = env!(\"CARGO_PKG_VERSION\"))]\nstruct Cli {\n    #[command(subcommand)]\n    command: Option\u003cCommands\u003e,\n\n    /// R√©pertoire de donn√©es Miaou\n    #[arg(long, default_value = \"~/.miaou\")]\n    data_dir: PathBuf,\n\n    /// Mode verbeux\n    #[arg(short, long)]\n    verbose: bool,\n}\n\n#[derive(Subcommand)]\nenum Commands {\n    /// Informations sur la version et l'√©tat\n    Status,\n\n    /// Tests des primitives cryptographiques\n    CryptoTest,\n\n    /// Gestion des profils utilisateur\n    Profile {\n        #[command(subcommand)]\n        action: ProfileAction,\n    },\n\n    /// Tests interactifs de chiffrement\n    TestEncrypt {\n        /// Message √† chiffrer\n        #[arg(short, long)]\n        message: Option\u003cString\u003e,\n    },\n\n    /// Tests interactifs de signature\n    TestSign {\n        /// Message √† signer\n        #[arg(short, long)]\n        message: Option\u003cString\u003e,\n    },\n\n    /// Benchmarks de performance\n    Benchmark,\n\n    /// Mode interactif (par d√©faut)\n    Interactive,\n}\n\n#[derive(Subcommand)]\nenum ProfileAction {\n    /// Cr√©er un nouveau profil\n    Create {\n        /// Nom du profil\n        name: String,\n    },\n    /// Lister les profils existants\n    List,\n    /// Supprimer un profil\n    Delete {\n        /// Nom du profil\n        name: String,\n    },\n    /// Afficher les d√©tails d'un profil\n    Show {\n        /// Nom du profil\n        name: String,\n    },\n}\n\nstruct MiaouCli {\n    data_dir: PathBuf,\n    _verbose: bool, // Pr√©vu pour les logs verbeux futurs\n    storage: SecureStorage,\n}\n\nimpl MiaouCli {\n    fn new(data_dir: PathBuf, verbose: bool) -\u003e Result\u003cSelf\u003e {\n        // Cr√©er le r√©pertoire de donn√©es si n√©cessaire\n        let data_dir = expand_path(data_dir)?;\n        std::fs::create_dir_all(\u0026data_dir)\n            .context(\"Impossible de cr√©er le r√©pertoire de donn√©es\")?;\n\n        // Initialiser le syst√®me de stockage s√©curis√©\n        let storage = SecureStorage::new(\u0026data_dir)?;\n\n        Ok(Self {\n            data_dir,\n            _verbose: verbose,\n            storage,\n        })\n    }\n\n    fn run_command(\u0026self, command: Commands) -\u003e Result\u003c()\u003e {\n        match command {\n            Commands::Status =\u003e self.show_status(),\n            Commands::CryptoTest =\u003e self.run_crypto_tests(),\n            Commands::Profile { action } =\u003e self.handle_profile(action),\n            Commands::TestEncrypt { message } =\u003e self.test_encryption(message),\n            Commands::TestSign { message } =\u003e self.test_signing(message),\n            Commands::Benchmark =\u003e self.run_benchmarks(),\n            Commands::Interactive =\u003e self.interactive_mode(),\n        }\n    }\n\n    fn show_status(\u0026self) -\u003e Result\u003c()\u003e {\n        println!(\"üê± {}\", version_info());\n        println!();\n\n        // Test d'initialisation\n        match initialize() {\n            Ok(()) =\u003e {\n                println!(\"‚úÖ Syst√®me cryptographique: OK\");\n                println!(\"‚úÖ Modules charg√©s: OK\");\n            }\n            Err(e) =\u003e {\n                println!(\"‚ùå Erreur d'initialisation: {}\", e);\n                return Ok(());\n            }\n        }\n\n        // Informations sur le r√©pertoire de donn√©es\n        println!(\"üìÅ R√©pertoire de donn√©es: {}\", self.data_dir.display());\n        println!(\"üìä Espace disque: {}\", get_disk_space(\u0026self.data_dir)?);\n\n        // Informations sur les profils\n        let profiles = self.storage.list_profiles()?;\n        println!(\"üë§ Profils configur√©s: {}\", profiles.len());\n\n        // Informations syst√®me\n        println!();\n        println!(\"üñ•Ô∏è  Plateforme: {}\", std::env::consts::OS);\n        println!(\"üèóÔ∏è  Architecture: {}\", std::env::consts::ARCH);\n\n        #[cfg(target_os = \"android\")]\n        println!(\"üì± Support Android: activ√©\");\n        #[cfg(target_os = \"ios\")]\n        println!(\"üì± Support iOS: activ√©\");\n        #[cfg(not(any(target_os = \"android\", target_os = \"ios\")))]\n        println!(\"üñ•Ô∏è  Version desktop\");\n\n        Ok(())\n    }\n\n    fn run_crypto_tests(\u0026self) -\u003e Result\u003c()\u003e {\n        println!(\"üß™ Tests des primitives cryptographiques Miaou v0.1.0\");\n        println!();\n\n        // Test AEAD (ChaCha20-Poly1305)\n        print!(\"üîí Test AEAD ChaCha20-Poly1305... \");\n        io::stdout().flush()?;\n\n        let key = AeadKeyRef::from_bytes([42u8; 32]);\n        let plaintext = b\"Message secret pour test AEAD\";\n        let aad = b\"miaou_v0.1.0_test\";\n        let mut rng = rand_core::OsRng;\n\n        let encrypted = encrypt_auto_nonce(\u0026key, aad, plaintext, \u0026mut rng)\n            .context(\"√âchec du chiffrement AEAD\")?;\n        let decrypted = decrypt(\u0026key, aad, \u0026encrypted).context(\"√âchec du d√©chiffrement AEAD\")?;\n\n        if \u0026decrypted == plaintext {\n            println!(\"‚úÖ OK\");\n        } else {\n            println!(\"‚ùå √âCHEC\");\n            return Err(anyhow::anyhow!(\n                \"Les donn√©es d√©chiffr√©es ne correspondent pas\"\n            ));\n        }\n\n        // Test signatures Ed25519\n        print!(\"‚úçÔ∏è  Test signatures Ed25519... \");\n        io::stdout().flush()?;\n\n        let keypair = Keypair::generate();\n        let message = b\"Message a signer pour test Ed25519\";\n\n        let signature = keypair.sign(message);\n        match keypair.verify(message, \u0026signature) {\n            Ok(()) =\u003e println!(\"‚úÖ OK\"),\n            Err(_) =\u003e {\n                println!(\"‚ùå √âCHEC\");\n                return Err(anyhow::anyhow!(\"√âchec de v√©rification de signature\"));\n            }\n        }\n\n        // Test hachage BLAKE3\n        print!(\"#Ô∏è‚É£  Test hachage BLAKE3... \");\n        io::stdout().flush()?;\n\n        let data = \"Donn√©es test pour hachage BLAKE3\".as_bytes();\n        let hash1 = blake3_32(data);\n        let hash2 = blake3_32(data);\n\n        if hash1 == hash2 {\n            println!(\"‚úÖ OK ({})\", hex::encode(\u0026hash1[..8]));\n        } else {\n            println!(\"‚ùå √âCHEC\");\n            return Err(anyhow::anyhow!(\"Hashes BLAKE3 inconsistants\"));\n        }\n\n        // Test Argon2 KDF\n        print!(\"üîë Test d√©rivation Argon2id... \");\n        io::stdout().flush()?;\n\n        let password = SecretString::new(\"mot_de_passe_test\".to_string());\n        let config = Argon2Config::fast_insecure(); // Rapide pour tests CLI\n\n        let hash = hash_password(\u0026password, \u0026config).context(\"√âchec du hachage Argon2\")?;\n        let valid = verify_password(\u0026password, \u0026hash).context(\"√âchec de v√©rification Argon2\")?;\n\n        if valid {\n            println!(\"‚úÖ OK\");\n        } else {\n            println!(\"‚ùå √âCHEC\");\n            return Err(anyhow::anyhow!(\"V√©rification Argon2 √©chou√©e\"));\n        }\n\n        println!();\n        println!(\"üéâ Tous les tests cryptographiques sont pass√©s avec succ√®s !\");\n\n        Ok(())\n    }\n\n    fn handle_profile(\u0026self, action: ProfileAction) -\u003e Result\u003c()\u003e {\n        match action {\n            ProfileAction::Create { name } =\u003e self.create_profile(name),\n            ProfileAction::List =\u003e self.list_profiles_cmd(),\n            ProfileAction::Delete { name } =\u003e self.delete_profile(name),\n            ProfileAction::Show { name } =\u003e self.show_profile(name),\n        }\n    }\n\n    fn create_profile(\u0026self, name: String) -\u003e Result\u003c()\u003e {\n        println!(\"üÜï Cr√©ation du profil '{}'\", name);\n\n        // Demander le mot de passe\n        let password = prompt_password(\"Mot de passe du profil: \")?;\n        let password_confirm = prompt_password(\"Confirmer le mot de passe: \")?;\n\n        if password.expose_secret() != password_confirm.expose_secret() {\n            return Err(anyhow::anyhow!(\"Les mots de passe ne correspondent pas\"));\n        }\n\n        // Cr√©er le profil avec le syst√®me de stockage s√©curis√©\n        println!(\"üîë G√©n√©ration des cl√©s cryptographiques...\");\n        let profile_id = self.storage.create_profile(\u0026name, \u0026password)?;\n\n        println!(\"‚úÖ Profil '{}' cr√©√© avec succ√®s\", name);\n        println!(\"üÜî ID: {}\", \u0026profile_id.hash[..8]);\n\n        // Charger le profil pour afficher la cl√© publique\n        if let Ok(profile) = self.storage.load_profile(\u0026profile_id, \u0026password) {\n            println!(\n                \"üîë Cl√© publique: {}\",\n                hex::encode(profile.identity_keypair.public.to_bytes())\n            );\n            println!(\n                \"üìÖ Cr√©√© le: {}\",\n                profile.metadata.created.format(\"%Y-%m-%d %H:%M:%S UTC\")\n            );\n        }\n\n        Ok(())\n    }\n\n    fn list_profiles_cmd(\u0026self) -\u003e Result\u003c()\u003e {\n        let profiles = self.storage.list_profiles()?;\n\n        if profiles.is_empty() {\n            println!(\"üë§ Aucun profil configur√©\");\n            println!(\"üí° Utilisez 'miaou-cli profile create \u003cnom\u003e' pour cr√©er un profil\");\n            return Ok(());\n        }\n\n        println!(\"üë§ Profils Miaou ({} trouv√©s):\", profiles.len());\n        println!();\n\n        for profile in profiles {\n            println!(\"  üìã {}\", profile.name);\n            println!(\"     üÜî ID: {}\", \u0026profile.id.hash[..8]);\n            println!(\n                \"     üìÖ Cr√©√©: {}\",\n                profile.created.format(\"%Y-%m-%d %H:%M:%S UTC\")\n            );\n            println!(\n                \"     üïí Dernier acc√®s: {}\",\n                profile.last_access.format(\"%Y-%m-%d %H:%M:%S UTC\")\n            );\n            println!(\n                \"     üîë Empreinte: {}...{}\",\n                \u0026profile.public_key_fingerprint[..8],\n                \u0026profile.public_key_fingerprint[profile.public_key_fingerprint.len() - 8..]\n            );\n            println!();\n        }\n\n        Ok(())\n    }\n\n    fn show_profile(\u0026self, name: String) -\u003e Result\u003c()\u003e {\n        let profiles = self.storage.list_profiles()?;\n        let profile_info = profiles\n            .iter()\n            .find(|p| p.name == name)\n            .ok_or_else(|| anyhow::anyhow!(\"Profil '{}' non trouv√©\", name))?;\n\n        // Demander le mot de passe pour charger le profil\n        let password = prompt_password(\u0026format!(\"Mot de passe pour '{}': \", name))?;\n        let profile = self.storage.load_profile(\u0026profile_info.id, \u0026password)?;\n\n        println!(\"üë§ D√©tails du profil '{}'\", profile.metadata.name);\n        println!();\n        println!(\"üÜî ID: {}\", profile.metadata.id.hash);\n        println!(\"üìÖ Cr√©√©: {}\", profile.metadata.created);\n        println!(\"üïí Dernier acc√®s: {}\", profile.metadata.last_access);\n        println!(\"üì¶ Version: {}\", profile.metadata.version);\n        println!();\n        println!(\"üîë Cl√©s cryptographiques:\");\n        println!(\n            \"   Publique: {}\",\n            hex::encode(profile.identity_keypair.public.to_bytes())\n        );\n        println!(\n            \"   Empreinte: {}\",\n            hex::encode(blake3_32(\u0026profile.identity_keypair.public.to_bytes()))\n        );\n        println!();\n        println!(\"‚öôÔ∏è  Param√®tres:\");\n        println!(\n            \"   Accepter amis auto: {}\",\n            profile.settings.auto_accept_friends\n        );\n        println!(\n            \"   Niveau chiffrement: {}\",\n            profile.settings.encryption_level\n        );\n        println!(\"   Sauvegarde: {}\", profile.settings.backup_enabled);\n        println!(\"   Th√®me: {}\", profile.settings.theme);\n\n        Ok(())\n    }\n\n    fn delete_profile(\u0026self, name: String) -\u003e Result\u003c()\u003e {\n        let profiles = self.storage.list_profiles()?;\n        let profile_info = profiles\n            .iter()\n            .find(|p| p.name == name)\n            .ok_or_else(|| anyhow::anyhow!(\"Profil '{}' non trouv√©\", name))?;\n\n        // Confirmation\n        print!(\n            \"‚ö†Ô∏è  √ätes-vous s√ªr de vouloir supprimer le profil '{}' ? [y/N]: \",\n            name\n        );\n        io::stdout().flush()?;\n\n        let mut input = String::new();\n        io::stdin().read_line(\u0026mut input)?;\n\n        if input.trim().to_lowercase() != \"y\" {\n            println!(\"Suppression annul√©e\");\n            return Ok(());\n        }\n\n        self.storage.delete_profile(\u0026profile_info.id)?;\n        println!(\"‚úÖ Profil '{}' supprim√©\", name);\n\n        Ok(())\n    }\n\n    fn test_encryption(\u0026self, message: Option\u003cString\u003e) -\u003e Result\u003c()\u003e {\n        let message = match message {\n            Some(msg) =\u003e msg,\n            None =\u003e prompt_string(\"Message √† chiffrer: \")?,\n        };\n\n        println!(\"üîí Test de chiffrement interactif\");\n        println!(\"üìù Message: {}\", message);\n\n        // G√©n√©rer une cl√© de test\n        let key = AeadKeyRef::from_bytes([42u8; 32]);\n        let aad = b\"miaou_cli_test\";\n        let mut rng = rand_core::OsRng;\n\n        // Chiffrer\n        let encrypted = encrypt_auto_nonce(\u0026key, aad, message.as_bytes(), \u0026mut rng)?;\n        println!(\n            \"üîê Chiffr√©: {} octets (tag inclus)\",\n            encrypted.ciphertext.len()\n        );\n        println!(\"üé≤ Nonce: {}\", hex::encode(\u0026encrypted.nonce));\n\n        // D√©chiffrer\n        let decrypted = decrypt(\u0026key, aad, \u0026encrypted)?;\n        let decrypted_str = String::from_utf8(decrypted)?;\n\n        println!(\"üîì D√©chiffr√©: {}\", decrypted_str);\n\n        if decrypted_str == message {\n            println!(\"‚úÖ Test de chiffrement r√©ussi !\");\n        } else {\n            println!(\"‚ùå Erreur: les donn√©es ne correspondent pas\");\n        }\n\n        Ok(())\n    }\n\n    fn test_signing(\u0026self, message: Option\u003cString\u003e) -\u003e Result\u003c()\u003e {\n        let message = match message {\n            Some(msg) =\u003e msg,\n            None =\u003e prompt_string(\"Message √† signer: \")?,\n        };\n\n        println!(\"‚úçÔ∏è  Test de signature interactif\");\n        println!(\"üìù Message: {}\", message);\n\n        // G√©n√©rer une paire de cl√©s\n        let keypair = Keypair::generate();\n        println!(\n            \"üîë Cl√© publique: {}\",\n            hex::encode(keypair.public.to_bytes())\n        );\n\n        // Signer\n        let signature = keypair.sign(message.as_bytes());\n        println!(\"‚úçÔ∏è  Signature: {}\", hex::encode(signature.to_bytes()));\n\n        // V√©rifier\n        match keypair.verify(message.as_bytes(), \u0026signature) {\n            Ok(()) =\u003e println!(\"‚úÖ Signature valide !\"),\n            Err(e) =\u003e println!(\"‚ùå Signature invalide: {:?}\", e),\n        }\n\n        Ok(())\n    }\n\n    fn run_benchmarks(\u0026self) -\u003e Result\u003c()\u003e {\n        println!(\"‚ö° Benchmarks de performance Miaou v0.1.0\");\n        println!(\"‚è±Ô∏è  Mesures approximatives (utilisez 'cargo bench' pour des mesures pr√©cises)\");\n        println!();\n\n        use std::time::Instant;\n\n        // Benchmark BLAKE3\n        let data = vec![0u8; 1024 * 1024]; // 1 MB\n        let start = Instant::now();\n        for _ in 0..100 {\n            let _ = blake3_32(\u0026data);\n        }\n        let duration = start.elapsed();\n        let throughput = (100.0 * data.len() as f64) / duration.as_secs_f64() / (1024.0 * 1024.0);\n        println!(\"üèÉ BLAKE3 (1 MB): {:.2} MiB/s\", throughput);\n\n        // Benchmark Ed25519\n        let keypair = Keypair::generate();\n        let message = b\"benchmark message\";\n        let start = Instant::now();\n        for _ in 0..1000 {\n            let _ = keypair.sign(message);\n        }\n        let duration = start.elapsed();\n        let rate = 1000.0 / duration.as_secs_f64();\n        println!(\"‚úçÔ∏è  Ed25519 signatures: {:.0} sig/s\", rate);\n\n        // Benchmark ChaCha20-Poly1305\n        let key = AeadKeyRef::from_bytes([42u8; 32]);\n        let data = vec![0u8; 1024];\n        let aad = b\"benchmark\";\n        let mut rng = rand_core::OsRng;\n        let start = Instant::now();\n        for _ in 0..1000 {\n            let _ = encrypt_auto_nonce(\u0026key, aad, \u0026data, \u0026mut rng);\n        }\n        let duration = start.elapsed();\n        let rate = 1000.0 / duration.as_secs_f64();\n        println!(\"üîí ChaCha20-Poly1305: {:.0} ops/s\", rate);\n\n        println!();\n        println!(\"üí° Pour des benchmarks d√©taill√©s: cargo bench\");\n\n        Ok(())\n    }\n\n    fn interactive_mode(\u0026self) -\u003e Result\u003c()\u003e {\n        println!(\"üê± Miaou CLI v0.1.0 - Mode interactif\");\n        println!(\"Tapez 'help' pour voir les commandes disponibles, 'quit' pour quitter\");\n        println!();\n\n        loop {\n            print!(\"miaou\u003e \");\n            io::stdout().flush()?;\n\n            let mut input = String::new();\n            io::stdin().read_line(\u0026mut input)?;\n            let input = input.trim();\n\n            if input.is_empty() {\n                continue;\n            }\n\n            match input {\n                \"quit\" | \"exit\" | \"q\" =\u003e {\n                    println!(\"üëã Au revoir !\");\n                    break;\n                }\n                \"help\" | \"h\" =\u003e {\n                    self.show_interactive_help();\n                }\n                \"status\" =\u003e {\n                    if let Err(e) = self.show_status() {\n                        println!(\"‚ùå Erreur: {}\", e);\n                    }\n                }\n                \"crypto-test\" =\u003e {\n                    if let Err(e) = self.run_crypto_tests() {\n                        println!(\"‚ùå Erreur: {}\", e);\n                    }\n                }\n                \"profiles\" =\u003e {\n                    if let Err(e) = self.list_profiles_cmd() {\n                        println!(\"‚ùå Erreur: {}\", e);\n                    }\n                }\n                \"benchmark\" =\u003e {\n                    if let Err(e) = self.run_benchmarks() {\n                        println!(\"‚ùå Erreur: {}\", e);\n                    }\n                }\n                _ =\u003e {\n                    println!(\n                        \"‚ùì Commande inconnue: '{}'. Tapez 'help' pour l'aide.\",\n                        input\n                    );\n                }\n            }\n\n            println!();\n        }\n\n        Ok(())\n    }\n\n    fn show_interactive_help(\u0026self) {\n        println!(\"üìö Commandes disponibles:\");\n        println!(\"  status        - Afficher l'√©tat du syst√®me\");\n        println!(\"  crypto-test   - Tests des primitives cryptographiques\");\n        println!(\"  profiles      - Lister les profils\");\n        println!(\"  benchmark     - Benchmarks de performance\");\n        println!(\"  help, h       - Afficher cette aide\");\n        println!(\"  quit, exit, q - Quitter\");\n        println!();\n        println!(\"üí° Utilisez les sous-commandes pour plus d'options:\");\n        println!(\"  profile create \u003cnom\u003e  - Cr√©er un profil\");\n        println!(\"  profile show \u003cnom\u003e    - Afficher un profil\");\n        println!(\"  profile delete \u003cnom\u003e  - Supprimer un profil\");\n    }\n}\n\n// Fonctions utilitaires\n\nfn expand_path(path: PathBuf) -\u003e Result\u003cPathBuf\u003e {\n    let path_str = path.to_string_lossy();\n    if path_str.starts_with(\"~/\") {\n        if let Some(home) = home::home_dir() {\n            Ok(home.join(\u0026path_str[2..]))\n        } else {\n            Ok(path)\n        }\n    } else {\n        Ok(path)\n    }\n}\n\nfn prompt_password(prompt: \u0026str) -\u003e Result\u003cSecretString\u003e {\n    print!(\"{}\", prompt);\n    io::stdout().flush()?;\n    let password = rpassword::read_password()?;\n    Ok(SecretString::new(password))\n}\n\nfn prompt_string(prompt: \u0026str) -\u003e Result\u003cString\u003e {\n    print!(\"{}\", prompt);\n    io::stdout().flush()?;\n    let mut input = String::new();\n    io::stdin().read_line(\u0026mut input)?;\n    Ok(input.trim().to_string())\n}\n\nfn get_disk_space(path: \u0026PathBuf) -\u003e Result\u003cString\u003e {\n    // Approximation simple pour l'espace disque\n    if let Ok(metadata) = std::fs::metadata(path) {\n        if metadata.is_dir() {\n            Ok(\"Disponible\".to_string())\n        } else {\n            Ok(\"Inconnu\".to_string())\n        }\n    } else {\n        Ok(\"Inconnu\".to_string())\n    }\n}\n\nfn main() -\u003e Result\u003c()\u003e {\n    let cli = Cli::parse();\n    let miaou_cli = MiaouCli::new(cli.data_dir, cli.verbose)?;\n\n    // V√©rifier l'initialisation de Miaou\n    if let Err(e) = initialize() {\n        return Err(anyhow::anyhow!(\"√âchec de l'initialisation de Miaou: {}\", e));\n    }\n\n    match cli.command {\n        Some(command) =\u003e miaou_cli.run_command(command),\n        None =\u003e miaou_cli.interactive_mode(), // Mode interactif par d√©faut\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use tempfile::TempDir;\n\n    fn create_test_cli() -\u003e Result\u003cMiaouCli\u003e {\n        let temp_dir = TempDir::new()?;\n        MiaouCli::new(temp_dir.path().to_path_buf(), false)\n    }\n\n    #[test]\n    fn test_cli_creation() {\n        let temp_dir = TempDir::new().unwrap();\n        let cli = MiaouCli::new(temp_dir.path().to_path_buf(), false);\n        assert!(cli.is_ok());\n    }\n\n    #[test]\n    fn test_expand_path_home() {\n        let path = PathBuf::from(\"~/test\");\n        let expanded = expand_path(path).unwrap();\n        // Should not contain ~ anymore\n        assert!(!expanded.to_string_lossy().contains('~'));\n    }\n\n    #[test]\n    fn test_expand_path_absolute() {\n        let path = PathBuf::from(\"/tmp/test\");\n        let expanded = expand_path(path.clone()).unwrap();\n        assert_eq!(expanded, path);\n    }\n\n    #[test]\n    fn test_expand_path_relative() {\n        let path = PathBuf::from(\"test/path\");\n        let expanded = expand_path(path.clone()).unwrap();\n        assert_eq!(expanded, path);\n    }\n\n    #[test]\n    fn test_get_disk_space() {\n        let temp_dir = TempDir::new().unwrap();\n        let result = get_disk_space(\u0026temp_dir.path().to_path_buf()).unwrap();\n        assert_eq!(result, \"Disponible\");\n    }\n\n    #[test]\n    fn test_get_disk_space_nonexistent() {\n        let path = PathBuf::from(\"/nonexistent/path\");\n        let result = get_disk_space(\u0026path).unwrap();\n        assert_eq!(result, \"Inconnu\");\n    }\n\n    #[test]\n    fn test_show_status() {\n        let cli = create_test_cli().unwrap();\n        // This test just verifies the function doesn't panic\n        // Real output testing would require capturing stdout\n        let result = cli.show_status();\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_run_crypto_tests() {\n        let cli = create_test_cli().unwrap();\n        let result = cli.run_crypto_tests();\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_profile_creation_flow() {\n        let cli = create_test_cli().unwrap();\n        \n        // Test listing empty profiles\n        let result = cli.list_profiles_cmd();\n        assert!(result.is_ok());\n        \n        // Test show non-existent profile\n        let result = cli.show_profile(\"nonexistent\".to_string());\n        assert!(result.is_err());\n        \n        // Test delete non-existent profile  \n        let result = cli.delete_profile(\"nonexistent\".to_string());\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_test_encryption() {\n        let cli = create_test_cli().unwrap();\n        let message = Some(\"Test message for encryption\".to_string());\n        let result = cli.test_encryption(message);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_test_signing() {\n        let cli = create_test_cli().unwrap();\n        let message = Some(\"Test message for signing\".to_string());\n        let result = cli.test_signing(message);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_run_benchmarks() {\n        let cli = create_test_cli().unwrap();\n        let result = cli.run_benchmarks();\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_commands_enum_creation() {\n        // Test that Commands enum variants can be created\n        let _status = Commands::Status;\n        let _crypto_test = Commands::CryptoTest;\n        let _interactive = Commands::Interactive;\n        let _benchmark = Commands::Benchmark;\n        \n        let _profile = Commands::Profile {\n            action: ProfileAction::List,\n        };\n        \n        let _test_encrypt = Commands::TestEncrypt {\n            message: Some(\"test\".to_string()),\n        };\n        \n        let _test_sign = Commands::TestSign {\n            message: Some(\"test\".to_string()),\n        };\n    }\n\n    #[test]\n    fn test_profile_action_enum_creation() {\n        // Test ProfileAction enum variants\n        let _create = ProfileAction::Create {\n            name: \"test\".to_string(),\n        };\n        let _list = ProfileAction::List;\n        let _delete = ProfileAction::Delete {\n            name: \"test\".to_string(),\n        };\n        let _show = ProfileAction::Show {\n            name: \"test\".to_string(),\n        };\n    }\n\n    #[test]\n    fn test_run_command_status() {\n        let cli = create_test_cli().unwrap();\n        let result = cli.run_command(Commands::Status);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_run_command_crypto_test() {\n        let cli = create_test_cli().unwrap();\n        let result = cli.run_command(Commands::CryptoTest);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_run_command_benchmark() {\n        let cli = create_test_cli().unwrap();\n        let result = cli.run_command(Commands::Benchmark);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_run_command_test_encrypt() {\n        let cli = create_test_cli().unwrap();\n        let result = cli.run_command(Commands::TestEncrypt {\n            message: Some(\"test message\".to_string()),\n        });\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_run_command_test_sign() {\n        let cli = create_test_cli().unwrap();\n        let result = cli.run_command(Commands::TestSign {\n            message: Some(\"test message\".to_string()),\n        });\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_run_command_profile_list() {\n        let cli = create_test_cli().unwrap();\n        let result = cli.run_command(Commands::Profile {\n            action: ProfileAction::List,\n        });\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_run_command_profile_show_nonexistent() {\n        let cli = create_test_cli().unwrap();\n        let result = cli.run_command(Commands::Profile {\n            action: ProfileAction::Show {\n                name: \"nonexistent\".to_string(),\n            },\n        });\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_run_command_profile_delete_nonexistent() {\n        let cli = create_test_cli().unwrap();\n        let result = cli.run_command(Commands::Profile {\n            action: ProfileAction::Delete {\n                name: \"nonexistent\".to_string(),\n            },\n        });\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_cli_parser_default_values() {\n        // Test that CLI struct can be constructed with default values\n        use clap::Parser;\n        \n        // Simulate command line args\n        let args = vec![\"miaou-cli\", \"status\"];\n        let cli = Cli::try_parse_from(args);\n        assert!(cli.is_ok());\n        \n        let cli = cli.unwrap();\n        assert_eq!(cli.data_dir, PathBuf::from(\"~/.miaou\"));\n        assert!(!cli.verbose);\n        assert!(matches!(cli.command, Some(Commands::Status)));\n    }\n\n    #[test]\n    fn test_cli_parser_verbose_flag() {\n        use clap::Parser;\n        \n        let args = vec![\"miaou-cli\", \"--verbose\", \"status\"];\n        let cli = Cli::try_parse_from(args);\n        assert!(cli.is_ok());\n        \n        let cli = cli.unwrap();\n        assert!(cli.verbose);\n    }\n\n    #[test]\n    fn test_cli_parser_custom_data_dir() {\n        use clap::Parser;\n        \n        let args = vec![\"miaou-cli\", \"--data-dir\", \"/tmp/custom\", \"status\"];\n        let cli = Cli::try_parse_from(args);\n        assert!(cli.is_ok());\n        \n        let cli = cli.unwrap();\n        assert_eq!(cli.data_dir, PathBuf::from(\"/tmp/custom\"));\n    }\n\n    #[test]\n    fn test_cli_parser_profile_commands() {\n        use clap::Parser;\n        \n        let test_cases = vec![\n            (vec![\"miaou-cli\", \"profile\", \"list\"], ProfileAction::List),\n            (vec![\"miaou-cli\", \"profile\", \"create\", \"alice\"], ProfileAction::Create { name: \"alice\".to_string() }),\n            (vec![\"miaou-cli\", \"profile\", \"show\", \"bob\"], ProfileAction::Show { name: \"bob\".to_string() }),\n            (vec![\"miaou-cli\", \"profile\", \"delete\", \"charlie\"], ProfileAction::Delete { name: \"charlie\".to_string() }),\n        ];\n        \n        for (args, expected_action) in test_cases {\n            let cli = Cli::try_parse_from(args).unwrap();\n            if let Some(Commands::Profile { action }) = cli.command {\n                match (action, expected_action) {\n                    (ProfileAction::List, ProfileAction::List) =\u003e {},\n                    (ProfileAction::Create { name: a }, ProfileAction::Create { name: b }) =\u003e assert_eq!(a, b),\n                    (ProfileAction::Show { name: a }, ProfileAction::Show { name: b }) =\u003e assert_eq!(a, b),\n                    (ProfileAction::Delete { name: a }, ProfileAction::Delete { name: b }) =\u003e assert_eq!(a, b),\n                    _ =\u003e panic!(\"Action mismatch\"),\n                }\n            } else {\n                panic!(\"Expected Profile command\");\n            }\n        }\n    }\n\n    #[test]\n    fn test_cli_parser_test_commands() {\n        use clap::Parser;\n        \n        // Test encrypt without message\n        let args = vec![\"miaou-cli\", \"test-encrypt\"];\n        let cli = Cli::try_parse_from(args).unwrap();\n        if let Some(Commands::TestEncrypt { message }) = cli.command {\n            assert!(message.is_none());\n        } else {\n            panic!(\"Expected TestEncrypt command\");\n        }\n        \n        // Test encrypt with message\n        let args = vec![\"miaou-cli\", \"test-encrypt\", \"--message\", \"hello\"];\n        let cli = Cli::try_parse_from(args).unwrap();\n        if let Some(Commands::TestEncrypt { message }) = cli.command {\n            assert_eq!(message, Some(\"hello\".to_string()));\n        } else {\n            panic!(\"Expected TestEncrypt command\");\n        }\n        \n        // Test sign with message\n        let args = vec![\"miaou-cli\", \"test-sign\", \"-m\", \"test\"];\n        let cli = Cli::try_parse_from(args).unwrap();\n        if let Some(Commands::TestSign { message }) = cli.command {\n            assert_eq!(message, Some(\"test\".to_string()));\n        } else {\n            panic!(\"Expected TestSign command\");\n        }\n    }\n\n    #[test]\n    fn test_directory_creation_in_new() {\n        let temp_dir = TempDir::new().unwrap();\n        let custom_path = temp_dir.path().join(\"custom_miaou\");\n        \n        // Directory doesn't exist yet\n        assert!(!custom_path.exists());\n        \n        // Creating MiaouCli should create the directory\n        let _cli = MiaouCli::new(custom_path.clone(), false).unwrap();\n        \n        // Directory should now exist\n        assert!(custom_path.exists());\n    }\n}\n","traces":[{"line":108,"address":[784189,783456],"length":1,"stats":{"Line":1}},{"line":110,"address":[783488],"length":1,"stats":{"Line":1}},{"line":111,"address":[783805,784187,783726,783639],"length":1,"stats":{"Line":2}},{"line":115,"address":[783835,784172],"length":1,"stats":{"Line":1}},{"line":117,"address":[784036],"length":1,"stats":{"Line":1}},{"line":118,"address":[783997],"length":1,"stats":{"Line":1}},{"line":124,"address":[784208],"length":1,"stats":{"Line":1}},{"line":125,"address":[784226],"length":1,"stats":{"Line":1}},{"line":126,"address":[784281],"length":1,"stats":{"Line":1}},{"line":127,"address":[784300],"length":1,"stats":{"Line":1}},{"line":128,"address":[784324],"length":1,"stats":{"Line":1}},{"line":129,"address":[784388],"length":1,"stats":{"Line":1}},{"line":130,"address":[784441],"length":1,"stats":{"Line":1}},{"line":131,"address":[784489],"length":1,"stats":{"Line":1}},{"line":132,"address":[784505],"length":1,"stats":{"Line":0}},{"line":136,"address":[784528,786047,786053],"length":1,"stats":{"Line":1}},{"line":137,"address":[784548],"length":1,"stats":{"Line":1}},{"line":138,"address":[784694],"length":1,"stats":{"Line":1}},{"line":141,"address":[784729],"length":1,"stats":{"Line":1}},{"line":143,"address":[784842],"length":1,"stats":{"Line":1}},{"line":144,"address":[784877],"length":1,"stats":{"Line":1}},{"line":146,"address":[784780],"length":1,"stats":{"Line":0}},{"line":147,"address":[786107,784812],"length":1,"stats":{"Line":0}},{"line":148,"address":[786176],"length":1,"stats":{"Line":0}},{"line":153,"address":[784917],"length":1,"stats":{"Line":1}},{"line":154,"address":[785050],"length":1,"stats":{"Line":1}},{"line":157,"address":[785382],"length":1,"stats":{"Line":1}},{"line":158,"address":[785568,785627],"length":1,"stats":{"Line":2}},{"line":161,"address":[785731],"length":1,"stats":{"Line":1}},{"line":162,"address":[785776],"length":1,"stats":{"Line":1}},{"line":163,"address":[785871],"length":1,"stats":{"Line":1}},{"line":169,"address":[785966],"length":1,"stats":{"Line":1}},{"line":172,"address":[786011],"length":1,"stats":{"Line":1}},{"line":175,"address":[790027,790290,786208],"length":1,"stats":{"Line":1}},{"line":176,"address":[786223],"length":1,"stats":{"Line":1}},{"line":177,"address":[786258],"length":1,"stats":{"Line":1}},{"line":180,"address":[786293],"length":1,"stats":{"Line":1}},{"line":181,"address":[786328],"length":1,"stats":{"Line":1}},{"line":183,"address":[786446],"length":1,"stats":{"Line":1}},{"line":184,"address":[786510],"length":1,"stats":{"Line":1}},{"line":185,"address":[786525],"length":1,"stats":{"Line":1}},{"line":188,"address":[786698,790280,786540,786758],"length":1,"stats":{"Line":2}},{"line":190,"address":[790243,786879,786970],"length":1,"stats":{"Line":2}},{"line":192,"address":[787267,787178],"length":1,"stats":{"Line":2}},{"line":193,"address":[787465,787299],"length":1,"stats":{"Line":2}},{"line":195,"address":[787328,787273],"length":1,"stats":{"Line":0}},{"line":196,"address":[787347],"length":1,"stats":{"Line":0}},{"line":202,"address":[787484],"length":1,"stats":{"Line":1}},{"line":203,"address":[787529,790203],"length":1,"stats":{"Line":1}},{"line":205,"address":[787710],"length":1,"stats":{"Line":1}},{"line":206,"address":[787729],"length":1,"stats":{"Line":1}},{"line":208,"address":[787744],"length":1,"stats":{"Line":1}},{"line":209,"address":[787820],"length":1,"stats":{"Line":1}},{"line":210,"address":[787924],"length":1,"stats":{"Line":1}},{"line":212,"address":[787895,790087],"length":1,"stats":{"Line":0}},{"line":213,"address":[790106],"length":1,"stats":{"Line":0}},{"line":218,"address":[787969],"length":1,"stats":{"Line":1}},{"line":219,"address":[790074,788014],"length":1,"stats":{"Line":1}},{"line":221,"address":[788195],"length":1,"stats":{"Line":1}},{"line":222,"address":[788284],"length":1,"stats":{"Line":1}},{"line":223,"address":[788319],"length":1,"stats":{"Line":1}},{"line":225,"address":[788338],"length":1,"stats":{"Line":1}},{"line":226,"address":[788607,788411],"length":1,"stats":{"Line":2}},{"line":228,"address":[788385,788458],"length":1,"stats":{"Line":0}},{"line":229,"address":[788477],"length":1,"stats":{"Line":0}},{"line":233,"address":[788773],"length":1,"stats":{"Line":1}},{"line":234,"address":[788818,790053],"length":1,"stats":{"Line":1}},{"line":236,"address":[788978],"length":1,"stats":{"Line":1}},{"line":237,"address":[789036],"length":1,"stats":{"Line":1}},{"line":239,"address":[789095,790038],"length":1,"stats":{"Line":1}},{"line":240,"address":[789406,789996,789335],"length":1,"stats":{"Line":2}},{"line":242,"address":[789568],"length":1,"stats":{"Line":1}},{"line":243,"address":[789598,789749],"length":1,"stats":{"Line":2}},{"line":245,"address":[789624,789572],"length":1,"stats":{"Line":0}},{"line":246,"address":[789643],"length":1,"stats":{"Line":0}},{"line":249,"address":[789768],"length":1,"stats":{"Line":1}},{"line":250,"address":[789813],"length":1,"stats":{"Line":1}},{"line":252,"address":[789858],"length":1,"stats":{"Line":1}},{"line":255,"address":[790304],"length":1,"stats":{"Line":1}},{"line":256,"address":[790323],"length":1,"stats":{"Line":1}},{"line":257,"address":[790364],"length":1,"stats":{"Line":0}},{"line":258,"address":[790413],"length":1,"stats":{"Line":1}},{"line":259,"address":[790435],"length":1,"stats":{"Line":1}},{"line":260,"address":[790489],"length":1,"stats":{"Line":1}},{"line":264,"address":[792908,790544,792615],"length":1,"stats":{"Line":0}},{"line":265,"address":[790569,790637],"length":1,"stats":{"Line":0}},{"line":268,"address":[790706,792901],"length":1,"stats":{"Line":0}},{"line":269,"address":[790978,792873,790895],"length":1,"stats":{"Line":0}},{"line":271,"address":[791124,791193],"length":1,"stats":{"Line":0}},{"line":272,"address":[792806,791301],"length":1,"stats":{"Line":0}},{"line":276,"address":[791330,791275],"length":1,"stats":{"Line":0}},{"line":277,"address":[792778,791359],"length":1,"stats":{"Line":0}},{"line":279,"address":[791689,791626],"length":1,"stats":{"Line":0}},{"line":280,"address":[791758],"length":1,"stats":{"Line":0}},{"line":283,"address":[792056,791926],"length":1,"stats":{"Line":0}},{"line":284,"address":[792192],"length":1,"stats":{"Line":0}},{"line":288,"address":[792348],"length":1,"stats":{"Line":0}},{"line":294,"address":[792672],"length":1,"stats":{"Line":0}},{"line":297,"address":[795004,792928,794901],"length":1,"stats":{"Line":1}},{"line":298,"address":[792946],"length":1,"stats":{"Line":1}},{"line":300,"address":[793195,793139],"length":1,"stats":{"Line":2}},{"line":301,"address":[794907,793218],"length":1,"stats":{"Line":2}},{"line":302,"address":[794926],"length":1,"stats":{"Line":1}},{"line":303,"address":[794971],"length":1,"stats":{"Line":1}},{"line":306,"address":[793206,793252],"length":1,"stats":{"Line":0}},{"line":307,"address":[793356],"length":1,"stats":{"Line":0}},{"line":309,"address":[793585,793401],"length":1,"stats":{"Line":0}},{"line":310,"address":[793870,793762],"length":1,"stats":{"Line":0}},{"line":311,"address":[793939],"length":1,"stats":{"Line":0}},{"line":312,"address":[794102],"length":1,"stats":{"Line":0}},{"line":316,"address":[794284],"length":1,"stats":{"Line":0}},{"line":320,"address":[794533],"length":1,"stats":{"Line":0}},{"line":325,"address":[794834],"length":1,"stats":{"Line":0}},{"line":328,"address":[793796],"length":1,"stats":{"Line":0}},{"line":331,"address":[798109,797972,795040],"length":1,"stats":{"Line":1}},{"line":332,"address":[798099,795092,795175],"length":1,"stats":{"Line":2}},{"line":333,"address":[795599,795450,795332,798062,795526],"length":1,"stats":{"Line":5}},{"line":335,"address":[795474],"length":1,"stats":{"Line":1}},{"line":336,"address":[795499,795583],"length":1,"stats":{"Line":4}},{"line":339,"address":[798030,795650],"length":1,"stats":{"Line":0}},{"line":340,"address":[797983,796097],"length":1,"stats":{"Line":0}},{"line":342,"address":[796294,796365],"length":1,"stats":{"Line":0}},{"line":343,"address":[796434],"length":1,"stats":{"Line":0}},{"line":344,"address":[796479],"length":1,"stats":{"Line":0}},{"line":345,"address":[796575],"length":1,"stats":{"Line":0}},{"line":346,"address":[796667],"length":1,"stats":{"Line":0}},{"line":347,"address":[796759],"length":1,"stats":{"Line":0}},{"line":348,"address":[796855],"length":1,"stats":{"Line":0}},{"line":349,"address":[796900],"length":1,"stats":{"Line":0}},{"line":350,"address":[796999],"length":1,"stats":{"Line":0}},{"line":354,"address":[797244],"length":1,"stats":{"Line":0}},{"line":358,"address":[797403],"length":1,"stats":{"Line":0}},{"line":359,"address":[797448],"length":1,"stats":{"Line":0}},{"line":360,"address":[797493],"length":1,"stats":{"Line":0}},{"line":364,"address":[797589],"length":1,"stats":{"Line":0}},{"line":368,"address":[797685],"length":1,"stats":{"Line":0}},{"line":369,"address":[797781],"length":1,"stats":{"Line":0}},{"line":371,"address":[797877],"length":1,"stats":{"Line":0}},{"line":374,"address":[799899,800009,798128],"length":1,"stats":{"Line":1}},{"line":375,"address":[798248,799999,798165],"length":1,"stats":{"Line":2}},{"line":376,"address":[798629,798405,798535,799962,798714],"length":1,"stats":{"Line":5}},{"line":378,"address":[798559],"length":1,"stats":{"Line":1}},{"line":379,"address":[798698,798590],"length":1,"stats":{"Line":4}},{"line":382,"address":[798771],"length":1,"stats":{"Line":0}},{"line":386,"address":[798859,799944],"length":1,"stats":{"Line":0}},{"line":388,"address":[799045],"length":1,"stats":{"Line":0}},{"line":389,"address":[799910,799052,799117],"length":1,"stats":{"Line":0}},{"line":391,"address":[799299],"length":1,"stats":{"Line":0}},{"line":392,"address":[799840],"length":1,"stats":{"Line":0}},{"line":393,"address":[799885],"length":1,"stats":{"Line":0}},{"line":396,"address":[799509,799813],"length":1,"stats":{"Line":0}},{"line":397,"address":[799640],"length":1,"stats":{"Line":0}},{"line":399,"address":[799728],"length":1,"stats":{"Line":0}},{"line":402,"address":[802357,800032,802233],"length":1,"stats":{"Line":1}},{"line":403,"address":[800052],"length":1,"stats":{"Line":1}},{"line":404,"address":[800097],"length":1,"stats":{"Line":1}},{"line":405,"address":[800164],"length":1,"stats":{"Line":0}},{"line":408,"address":[800369,800449],"length":1,"stats":{"Line":2}},{"line":409,"address":[800468],"length":1,"stats":{"Line":1}},{"line":412,"address":[800561],"length":1,"stats":{"Line":1}},{"line":413,"address":[800611],"length":1,"stats":{"Line":1}},{"line":417,"address":[800702,800631,802334],"length":1,"stats":{"Line":2}},{"line":418,"address":[800988,801061],"length":1,"stats":{"Line":2}},{"line":422,"address":[801165],"length":1,"stats":{"Line":1}},{"line":425,"address":[802303,801347],"length":1,"stats":{"Line":1}},{"line":426,"address":[801689,801569,802244],"length":1,"stats":{"Line":2}},{"line":428,"address":[801875,801946],"length":1,"stats":{"Line":2}},{"line":430,"address":[802028],"length":1,"stats":{"Line":1}},{"line":431,"address":[802075,802150],"length":1,"stats":{"Line":2}},{"line":433,"address":[802049,802101],"length":1,"stats":{"Line":0}},{"line":436,"address":[802122],"length":1,"stats":{"Line":1}},{"line":439,"address":[803738,802384],"length":1,"stats":{"Line":1}},{"line":440,"address":[802404],"length":1,"stats":{"Line":1}},{"line":441,"address":[802441],"length":1,"stats":{"Line":1}},{"line":442,"address":[802502],"length":1,"stats":{"Line":0}},{"line":445,"address":[802769,802689],"length":1,"stats":{"Line":2}},{"line":446,"address":[802788],"length":1,"stats":{"Line":1}},{"line":449,"address":[802881],"length":1,"stats":{"Line":1}},{"line":450,"address":[802900,802971],"length":1,"stats":{"Line":2}},{"line":456,"address":[803159],"length":1,"stats":{"Line":1}},{"line":457,"address":[803213],"length":1,"stats":{"Line":1}},{"line":460,"address":[803431],"length":1,"stats":{"Line":1}},{"line":461,"address":[803576],"length":1,"stats":{"Line":1}},{"line":462,"address":[803651,803521],"length":1,"stats":{"Line":0}},{"line":465,"address":[803623],"length":1,"stats":{"Line":1}},{"line":468,"address":[805858,803760,805909],"length":1,"stats":{"Line":1}},{"line":469,"address":[803805],"length":1,"stats":{"Line":1}},{"line":470,"address":[803840],"length":1,"stats":{"Line":1}},{"line":471,"address":[803875],"length":1,"stats":{"Line":1}},{"line":476,"address":[803994,803910],"length":1,"stats":{"Line":1}},{"line":477,"address":[804066,803968],"length":1,"stats":{"Line":2}},{"line":478,"address":[804081],"length":1,"stats":{"Line":1}},{"line":479,"address":[804184,805885],"length":1,"stats":{"Line":2}},{"line":481,"address":[804222],"length":1,"stats":{"Line":1}},{"line":482,"address":[804286],"length":1,"stats":{"Line":1}},{"line":483,"address":[804448],"length":1,"stats":{"Line":1}},{"line":486,"address":[804568],"length":1,"stats":{"Line":1}},{"line":487,"address":[803775],"length":1,"stats":{"Line":1}},{"line":488,"address":[804587,804666],"length":1,"stats":{"Line":2}},{"line":489,"address":[804681],"length":1,"stats":{"Line":1}},{"line":490,"address":[804766,805864],"length":1,"stats":{"Line":2}},{"line":492,"address":[804808],"length":1,"stats":{"Line":1}},{"line":493,"address":[804868],"length":1,"stats":{"Line":1}},{"line":494,"address":[804908],"length":1,"stats":{"Line":1}},{"line":497,"address":[805028],"length":1,"stats":{"Line":1}},{"line":498,"address":[805078],"length":1,"stats":{"Line":1}},{"line":499,"address":[803790],"length":1,"stats":{"Line":1}},{"line":501,"address":[805225,805155],"length":1,"stats":{"Line":2}},{"line":502,"address":[805240],"length":1,"stats":{"Line":1}},{"line":503,"address":[805776,805325],"length":1,"stats":{"Line":2}},{"line":505,"address":[805357],"length":1,"stats":{"Line":1}},{"line":506,"address":[805417],"length":1,"stats":{"Line":1}},{"line":507,"address":[805457],"length":1,"stats":{"Line":1}},{"line":509,"address":[805577],"length":1,"stats":{"Line":1}},{"line":510,"address":[805622],"length":1,"stats":{"Line":1}},{"line":512,"address":[805667],"length":1,"stats":{"Line":1}},{"line":515,"address":[808754,805936,807625],"length":1,"stats":{"Line":0}},{"line":516,"address":[805959],"length":1,"stats":{"Line":0}},{"line":517,"address":[806026],"length":1,"stats":{"Line":0}},{"line":518,"address":[806061],"length":1,"stats":{"Line":0}},{"line":521,"address":[806096],"length":1,"stats":{"Line":0}},{"line":522,"address":[806131],"length":1,"stats":{"Line":0}},{"line":524,"address":[806257],"length":1,"stats":{"Line":0}},{"line":525,"address":[806333,808730,806262],"length":1,"stats":{"Line":0}},{"line":526,"address":[806521],"length":1,"stats":{"Line":0}},{"line":528,"address":[806591],"length":1,"stats":{"Line":0}},{"line":533,"address":[806690,806768,806628],"length":1,"stats":{"Line":0}},{"line":534,"address":[806735,808664],"length":1,"stats":{"Line":0}},{"line":537,"address":[806823,806933],"length":1,"stats":{"Line":0}},{"line":538,"address":[806919,808621],"length":1,"stats":{"Line":0}},{"line":540,"address":[806939],"length":1,"stats":{"Line":0}},{"line":541,"address":[808310,807035],"length":1,"stats":{"Line":0}},{"line":542,"address":[808488,808397],"length":1,"stats":{"Line":0}},{"line":545,"address":[806988,807054],"length":1,"stats":{"Line":0}},{"line":546,"address":[807107,807994],"length":1,"stats":{"Line":0}},{"line":547,"address":[808172,808081],"length":1,"stats":{"Line":0}},{"line":550,"address":[807060,807126],"length":1,"stats":{"Line":0}},{"line":551,"address":[807179,807678],"length":1,"stats":{"Line":0}},{"line":552,"address":[807765,807856],"length":1,"stats":{"Line":0}},{"line":555,"address":[807198,807132],"length":1,"stats":{"Line":0}},{"line":556,"address":[807239,807356],"length":1,"stats":{"Line":0}},{"line":557,"address":[807534,807443],"length":1,"stats":{"Line":0}},{"line":561,"address":[807251,807204],"length":1,"stats":{"Line":0}},{"line":568,"address":[807322,808626],"length":1,"stats":{"Line":0}},{"line":571,"address":[808697],"length":1,"stats":{"Line":0}},{"line":574,"address":[808768],"length":1,"stats":{"Line":0}},{"line":575,"address":[808783],"length":1,"stats":{"Line":0}},{"line":576,"address":[808808],"length":1,"stats":{"Line":0}},{"line":577,"address":[808837],"length":1,"stats":{"Line":0}},{"line":578,"address":[808866],"length":1,"stats":{"Line":0}},{"line":579,"address":[808901],"length":1,"stats":{"Line":0}},{"line":580,"address":[808936],"length":1,"stats":{"Line":0}},{"line":581,"address":[808971],"length":1,"stats":{"Line":0}},{"line":582,"address":[809006],"length":1,"stats":{"Line":0}},{"line":583,"address":[809041],"length":1,"stats":{"Line":0}},{"line":584,"address":[809076],"length":1,"stats":{"Line":0}},{"line":585,"address":[809111],"length":1,"stats":{"Line":0}},{"line":586,"address":[809146],"length":1,"stats":{"Line":0}},{"line":592,"address":[809200,810134,810050],"length":1,"stats":{"Line":1}},{"line":593,"address":[809330,809230],"length":1,"stats":{"Line":2}},{"line":594,"address":[809337,809417,810074,809542],"length":1,"stats":{"Line":4}},{"line":595,"address":[809585,809786,809544],"length":1,"stats":{"Line":2}},{"line":596,"address":[809678,809855],"length":1,"stats":{"Line":2}},{"line":598,"address":[809708],"length":1,"stats":{"Line":0}},{"line":601,"address":[809464],"length":1,"stats":{"Line":1}},{"line":605,"address":[810176,810729,810761],"length":1,"stats":{"Line":0}},{"line":606,"address":[810202],"length":1,"stats":{"Line":0}},{"line":607,"address":[810280],"length":1,"stats":{"Line":0}},{"line":608,"address":[810496,810378],"length":1,"stats":{"Line":0}},{"line":609,"address":[810568,810673],"length":1,"stats":{"Line":0}},{"line":612,"address":[811409,811415,810768],"length":1,"stats":{"Line":0}},{"line":613,"address":[810795],"length":1,"stats":{"Line":0}},{"line":614,"address":[810883],"length":1,"stats":{"Line":0}},{"line":615,"address":[811005],"length":1,"stats":{"Line":0}},{"line":616,"address":[811010,811075],"length":1,"stats":{"Line":0}},{"line":617,"address":[811253],"length":1,"stats":{"Line":0}},{"line":620,"address":[811843,811849,811440],"length":1,"stats":{"Line":1}},{"line":622,"address":[811465,811841,811564],"length":1,"stats":{"Line":3}},{"line":623,"address":[811627,811799,811571],"length":1,"stats":{"Line":3}},{"line":624,"address":[811664,811764],"length":1,"stats":{"Line":2}},{"line":626,"address":[811633,811700],"length":1,"stats":{"Line":0}},{"line":629,"address":[811806,811500],"length":1,"stats":{"Line":2}},{"line":633,"address":[812825,812638,811872],"length":1,"stats":{"Line":0}},{"line":634,"address":[811879],"length":1,"stats":{"Line":0}},{"line":635,"address":[812029,811905,812805],"length":1,"stats":{"Line":0}},{"line":638,"address":[812292,812236],"length":1,"stats":{"Line":0}},{"line":639,"address":[812450,812361],"length":1,"stats":{"Line":0}},{"line":642,"address":[812644],"length":1,"stats":{"Line":0}},{"line":643,"address":[812772,812669],"length":1,"stats":{"Line":0}},{"line":644,"address":[812733],"length":1,"stats":{"Line":0}}],"covered":157,"coverable":290},{"path":["/","home","seb","Dev","miaou","miaou-core","src","lib.rs"],"content":"//! # Miaou Core v0.1.0\n//!\n//! Fonctionnalit√©s principales et abstractions pour la plateforme Miaou.\n//!\n//! Ce crate contient la logique m√©tier centrale, la gestion des profils\n//! et les abstractions communes utilis√©es par tous les autres composants.\n\n#![warn(missing_docs)]\n#![warn(rustdoc::broken_intra_doc_links)]\n\n// Re-export crypto primitives\npub use miaou_crypto as crypto;\n\n/// Module mobile pour les abstractions sp√©cifiques aux plateformes mobiles\npub mod mobile;\n\n/// Module de stockage s√©curis√© pour la gestion des profils utilisateur\npub mod storage;\n\n// Re-exports publics\npub use storage::{ProfileHandle, ProfileId, SecureStorage};\n\n/// Version actuelle de Miaou\npub const VERSION: \u0026str = env!(\"CARGO_PKG_VERSION\");\n\n/// Nom de la version actuelle\npub const VERSION_NAME: \u0026str = \"Premi√®re Griffe\";\n\n/// Phase de d√©veloppement actuelle\npub const DEVELOPMENT_PHASE: u8 = 1;\n\n/// Interface commune pour toutes les plateformes\npub trait PlatformInterface {\n    /// Initialise la plateforme\n    ///\n    /// # Errors\n    /// √âchec si l'initialisation de la plateforme √©choue.\n    fn initialize(\u0026mut self) -\u003e Result\u003c(), String\u003e;\n\n    /// Retourne le nom de la plateforme\n    fn get_platform_name(\u0026self) -\u003e \u0026'static str;\n\n    /// Retourne la version support√©e\n    fn get_supported_version(\u0026self) -\u003e \u0026'static str {\n        VERSION\n    }\n}\n\n/// Informations sur la version et compilation\n#[must_use]\npub fn version_info() -\u003e String {\n    format!(\"Miaou v{VERSION} \\\"{VERSION_NAME}\\\" (Phase {DEVELOPMENT_PHASE})\")\n}\n\n/// Fonction principale d'initialisation de Miaou\n///\n/// # Errors\n/// √âchec si la v√©rification des d√©pendances cryptographiques √©choue.\npub fn initialize() -\u003e Result\u003c(), String\u003e {\n    // V√©rification des d√©pendances cryptographiques\n    crypto::test_crypto_availability()?;\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_version_info() {\n        let info = version_info();\n        assert!(info.contains(\"Miaou\"));\n        assert!(info.contains(\"Premi√®re Griffe\"));\n        assert!(info.contains(\"Phase 1\"));\n    }\n\n    #[test]\n    fn test_initialize() {\n        assert!(initialize().is_ok());\n    }\n\n    #[test]\n    fn test_constants() {\n        assert_eq!(VERSION_NAME, \"Premi√®re Griffe\");\n        assert_eq!(DEVELOPMENT_PHASE, 1);\n        #[allow(clippy::const_is_empty)]\n        {\n            assert!(!VERSION.is_empty());\n        }\n    }\n}\n","traces":[{"line":44,"address":[749136],"length":1,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[663456],"length":1,"stats":{"Line":3}},{"line":52,"address":[663473],"length":1,"stats":{"Line":3}},{"line":59,"address":[663728],"length":1,"stats":{"Line":3}},{"line":61,"address":[663742],"length":1,"stats":{"Line":3}},{"line":62,"address":[663863],"length":1,"stats":{"Line":3}}],"covered":5,"coverable":7},{"path":["/","home","seb","Dev","miaou","miaou-core","src","mobile.rs"],"content":"// Module mobile - Sp√©cifique aux plateformes mobiles\n// Fonctionnalit√©s communes Android et iOS\n\nuse crate::PlatformInterface;\n\n/// Plateforme mobile (Android/iOS)\npub struct MobilePlatform {\n    initialized: bool,\n    platform_name: \u0026'static str,\n}\n\nimpl MobilePlatform {\n    /// Cr√©e une nouvelle plateforme mobile\n    #[must_use]\n    pub const fn new(platform_name: \u0026'static str) -\u003e Self {\n        Self {\n            initialized: false,\n            platform_name,\n        }\n    }\n}\n\nimpl PlatformInterface for MobilePlatform {\n    fn initialize(\u0026mut self) -\u003e Result\u003c(), String\u003e {\n        if !self.initialized {\n            self.initialized = true;\n            println!(\"Initialisation mobile pour {}\", self.platform_name);\n        }\n        Ok(())\n    }\n\n    fn get_platform_name(\u0026self) -\u003e \u0026'static str {\n        self.platform_name\n    }\n}\n\n// Interface Android via JNI\n#[cfg(target_os = \"android\")]\npub mod android {\n    use super::*;\n    use jni::objects::JClass;\n    use jni::sys::jstring;\n    use jni::JNIEnv;\n\n    #[no_mangle]\n    pub extern \"system\" fn Java_net_nethttp_miaou_MiaouLib_hello(\n        mut env: JNIEnv,\n        _class: JClass,\n    ) -\u003e jstring {\n        let output = env\n            .new_string(\"Miaou Android\")\n            .expect(\"Impossible de cr√©er une string Java\");\n        output.into_raw()\n    }\n\n    #[no_mangle]\n    pub extern \"system\" fn Java_net_nethttp_miaou_MiaouLib_initialize(\n        _env: JNIEnv,\n        _class: JClass,\n    ) {\n        let mut platform = MobilePlatform::new(\"Android\");\n        let _ = platform.initialize();\n    }\n}\n\n// Interface iOS via Objective-C\n#[cfg(target_os = \"ios\")]\npub mod ios {\n    use super::*;\n    use std::ffi::{CStr, CString};\n    use std::os::raw::c_char;\n\n    #[no_mangle]\n    pub extern \"C\" fn miaou_hello() -\u003e *const c_char {\n        let hello = CString::new(\"Miaou iOS\").unwrap();\n        hello.into_raw()\n    }\n\n    #[no_mangle]\n    pub extern \"C\" fn miaou_initialize() {\n        let mut platform = MobilePlatform::new(\"iOS\");\n        let _ = platform.initialize();\n    }\n\n    #[no_mangle]\n    pub extern \"C\" fn miaou_free_string(ptr: *mut c_char) {\n        if !ptr.is_null() {\n            unsafe {\n                CString::from_raw(ptr);\n            }\n        }\n    }\n}\n","traces":[{"line":15,"address":[706080],"length":1,"stats":{"Line":0}},{"line":24,"address":[706112],"length":1,"stats":{"Line":0}},{"line":25,"address":[706136],"length":1,"stats":{"Line":0}},{"line":26,"address":[706147],"length":1,"stats":{"Line":0}},{"line":27,"address":[706151],"length":1,"stats":{"Line":0}},{"line":29,"address":[706226],"length":1,"stats":{"Line":0}},{"line":32,"address":[706256],"length":1,"stats":{"Line":0}},{"line":33,"address":[706261],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":8},{"path":["/","home","seb","Dev","miaou","miaou-core","src","storage.rs"],"content":"// Module de stockage s√©curis√© pour Miaou v0.1.0\n// Gestion des profils utilisateur avec chiffrement des donn√©es sensibles\n\nuse crate::crypto::{\n    aead::{decrypt, encrypt_auto_nonce, AeadKeyRef},\n    hash::blake3_32,\n    kdf::{derive_key_32, generate_salt, hash_password, verify_password, Argon2Config},\n    sign::Keypair,\n    CryptoError,\n};\nuse anyhow::Result;\nuse chrono::{DateTime, Utc};\nuse secrecy::{SecretString, Zeroize};\nuse serde::{Deserialize, Deserializer, Serialize, Serializer};\nuse std::fs;\nuse std::path::{Path, PathBuf};\n\n/// Erreurs de stockage\n#[derive(Debug, thiserror::Error)]\npub enum StorageError {\n    /// Erreur d'entr√©e/sortie syst√®me\n    #[error(\"Erreur d'E/S: {0}\")]\n    Io(#[from] std::io::Error),\n\n    /// Erreur de s√©rialisation JSON\n    #[error(\"Erreur de s√©rialisation: {0}\")]\n    Serialization(#[from] serde_json::Error),\n\n    /// Erreur cryptographique\n    #[error(\"Erreur cryptographique: {0}\")]\n    Crypto(#[from] CryptoError),\n\n    /// Profil introuvable\n    #[error(\"Profil non trouv√©: {0}\")]\n    ProfileNotFound(String),\n\n    /// Tentative de cr√©ation d'un profil existant\n    #[error(\"Profil d√©j√† existant: {0}\")]\n    ProfileAlreadyExists(String),\n\n    /// Mot de passe incorrect\n    #[error(\"Mot de passe invalide\")]\n    InvalidPassword,\n\n    /// Donn√©es de profil corrompues\n    #[error(\"Donn√©es corrompues ou version incompatible\")]\n    CorruptedData,\n}\n\n/// Gestionnaire de stockage s√©curis√©\npub struct SecureStorage {\n    /// R√©pertoire racine de stockage\n    storage_root: PathBuf,\n}\n\nimpl SecureStorage {\n    /// Cr√©e une nouvelle instance de stockage\n    ///\n    /// # Errors\n    /// √âchec si les r√©pertoires ne peuvent pas √™tre cr√©√©s ou acc√©d√©s.\n    pub fn new\u003cP: AsRef\u003cPath\u003e\u003e(storage_root: P) -\u003e Result\u003cSelf\u003e {\n        let storage_root = storage_root.as_ref().to_path_buf();\n\n        // Cr√©er les r√©pertoires n√©cessaires\n        fs::create_dir_all(\u0026storage_root)?;\n        fs::create_dir_all(storage_root.join(\"profiles\"))?;\n        fs::create_dir_all(storage_root.join(\"keystore\"))?;\n\n        Ok(Self { storage_root })\n    }\n\n    /// Cr√©e un nouveau profil utilisateur\n    ///\n    /// # Errors\n    /// √âchec si le profil existe d√©j√† ou si les op√©rations cryptographiques √©chouent.\n    pub fn create_profile(\u0026self, name: \u0026str, password: \u0026SecretString) -\u003e Result\u003cProfileId\u003e {\n        let profile_id = ProfileId::new(name);\n        let profile_path = self.get_profile_path(\u0026profile_id);\n\n        // V√©rifier que le profil n'existe pas\n        if profile_path.exists() {\n            return Err(StorageError::ProfileAlreadyExists(name.to_string()).into());\n        }\n\n        // G√©n√©rer les cl√©s cryptographiques\n        let identity_keypair = Keypair::generate();\n        let mut rng = rand_core::OsRng;\n        let _storage_key = AeadKeyRef::generate(\u0026mut rng);\n\n        // Cr√©er le hash du mot de passe pour l'authentification\n        let config = Argon2Config::balanced();\n        let password_hash = hash_password(password, \u0026config)?;\n\n        // D√©river une cl√© de chiffrement depuis le mot de passe\n        let salt = generate_salt();\n        let encryption_key_bytes = derive_key_32(password, \u0026salt, \u0026config)?;\n        let encryption_key = AeadKeyRef::from_bytes(encryption_key_bytes);\n\n        // Chiffrer les donn√©es sensibles (cl√©s priv√©es)\n        let identity_private_bytes = identity_keypair.secret.to_bytes();\n        let encrypted_identity = encrypt_auto_nonce(\n            \u0026encryption_key,\n            b\"miaou_identity_v0.1.0\",\n            \u0026identity_private_bytes,\n            \u0026mut rng,\n        )?;\n\n        // Cr√©er la structure du profil\n        let profile = ProfileData {\n            metadata: ProfileMetadata {\n                id: profile_id.clone(),\n                name: name.to_string(),\n                version: \"0.1.0\".to_string(),\n                created: Utc::now(),\n                last_access: Utc::now(),\n            },\n            auth: AuthenticationData {\n                password_hash,\n                salt: salt.to_string(),\n                config_type: \"balanced\".to_string(),\n            },\n            keys: KeyData {\n                public_identity: identity_keypair.public.to_bytes(),\n                encrypted_private_identity: encrypted_identity,\n                key_fingerprint: blake3_32(\u0026identity_keypair.public.to_bytes()),\n            },\n            settings: ProfileSettings::default(),\n        };\n\n        // Sauvegarder le profil\n        let profile_json = serde_json::to_string_pretty(\u0026profile)?;\n        fs::write(\u0026profile_path, profile_json)?;\n\n        // Nettoyer les donn√©es sensibles\n        let mut identity_private_bytes = identity_private_bytes;\n        identity_private_bytes.zeroize();\n        let mut encryption_key_bytes = encryption_key_bytes;\n        encryption_key_bytes.zeroize();\n\n        Ok(profile_id)\n    }\n\n    /// Charge un profil utilisateur avec authentification\n    ///\n    /// # Errors\n    /// √âchec si le profil n'existe pas, si le mot de passe est incorrect, ou si les donn√©es sont corrompues.\n    pub fn load_profile(\n        \u0026self,\n        profile_id: \u0026ProfileId,\n        password: \u0026SecretString,\n    ) -\u003e Result\u003cProfileHandle\u003e {\n        let profile_path = self.get_profile_path(profile_id);\n\n        if !profile_path.exists() {\n            return Err(StorageError::ProfileNotFound(profile_id.name.clone()).into());\n        }\n\n        // Charger les donn√©es du profil\n        let profile_data = fs::read_to_string(\u0026profile_path)?;\n        let profile: ProfileData = serde_json::from_str(\u0026profile_data)?;\n\n        // V√©rifier le mot de passe\n        if !verify_password(password, \u0026profile.auth.password_hash)? {\n            return Err(StorageError::InvalidPassword.into());\n        }\n\n        // D√©river la cl√© de d√©chiffrement\n        let salt = argon2::password_hash::SaltString::from_b64(\u0026profile.auth.salt)\n            .map_err(|_| StorageError::CorruptedData)?;\n        let config = match profile.auth.config_type.as_str() {\n            \"balanced\" =\u003e Argon2Config::balanced(),\n            \"secure\" =\u003e Argon2Config::secure(),\n            \"fast_insecure\" =\u003e Argon2Config::fast_insecure(),\n            _ =\u003e return Err(StorageError::CorruptedData.into()),\n        };\n\n        let encryption_key_bytes = derive_key_32(password, \u0026salt, \u0026config)?;\n        let encryption_key = AeadKeyRef::from_bytes(encryption_key_bytes);\n\n        // D√©chiffrer la cl√© priv√©e d'identit√©\n        let identity_private_bytes = decrypt(\n            \u0026encryption_key,\n            b\"miaou_identity_v0.1.0\",\n            \u0026profile.keys.encrypted_private_identity,\n        )?;\n\n        // Reconstruire la paire de cl√©s\n        if identity_private_bytes.len() != 32 {\n            return Err(StorageError::CorruptedData.into());\n        }\n        let mut private_key_array = [0u8; 32];\n        private_key_array.copy_from_slice(\u0026identity_private_bytes);\n        let identity_keypair = Keypair::from_private_bytes(private_key_array)?;\n\n        // V√©rifier l'int√©grit√© de la cl√© publique\n        if identity_keypair.public.to_bytes() != profile.keys.public_identity {\n            return Err(StorageError::CorruptedData.into());\n        }\n\n        // Mettre √† jour l'horodatage d'acc√®s\n        self.update_last_access(profile_id)?;\n\n        Ok(ProfileHandle {\n            metadata: profile.metadata,\n            identity_keypair,\n            settings: profile.settings,\n        })\n    }\n\n    /// Liste tous les profils disponibles\n    ///\n    /// # Errors\n    /// √âchec si le r√©pertoire de profils ne peut pas √™tre lu.\n    pub fn list_profiles(\u0026self) -\u003e Result\u003cVec\u003cProfileInfo\u003e\u003e {\n        let profiles_dir = self.storage_root.join(\"profiles\");\n        let mut profiles = Vec::new();\n\n        if !profiles_dir.exists() {\n            return Ok(profiles);\n        }\n\n        for entry in fs::read_dir(\u0026profiles_dir)? {\n            let entry = entry?;\n            let path = entry.path();\n\n            if path.extension().and_then(|s| s.to_str()) == Some(\"json\") {\n                if let Ok(data) = fs::read_to_string(\u0026path) {\n                    if let Ok(profile) = serde_json::from_str::\u003cProfileData\u003e(\u0026data) {\n                        profiles.push(ProfileInfo {\n                            id: profile.metadata.id,\n                            name: profile.metadata.name,\n                            created: profile.metadata.created,\n                            last_access: profile.metadata.last_access,\n                            public_key_fingerprint: hex::encode(profile.keys.key_fingerprint),\n                        });\n                    }\n                }\n            }\n        }\n\n        // Trier par date de derni√®re utilisation\n        profiles.sort_by(|a, b| b.last_access.cmp(\u0026a.last_access));\n\n        Ok(profiles)\n    }\n\n    /// Supprime un profil\n    ///\n    /// # Errors\n    /// √âchec si le profil n'existe pas ou si la suppression √©choue.\n    pub fn delete_profile(\u0026self, profile_id: \u0026ProfileId) -\u003e Result\u003c()\u003e {\n        let profile_path = self.get_profile_path(profile_id);\n\n        if !profile_path.exists() {\n            return Err(StorageError::ProfileNotFound(profile_id.name.clone()).into());\n        }\n\n        fs::remove_file(\u0026profile_path)?;\n\n        // TODO: Supprimer aussi les donn√©es associ√©es (keystore, messages, etc.)\n\n        Ok(())\n    }\n\n    /// Met √† jour l'horodatage de derni√®re utilisation\n    fn update_last_access(\u0026self, profile_id: \u0026ProfileId) -\u003e Result\u003c()\u003e {\n        let profile_path = self.get_profile_path(profile_id);\n\n        if let Ok(data) = fs::read_to_string(\u0026profile_path) {\n            if let Ok(mut profile) = serde_json::from_str::\u003cProfileData\u003e(\u0026data) {\n                profile.metadata.last_access = Utc::now();\n                let updated_data = serde_json::to_string_pretty(\u0026profile)?;\n                fs::write(\u0026profile_path, updated_data)?;\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Retourne le chemin du fichier de profil\n    fn get_profile_path(\u0026self, profile_id: \u0026ProfileId) -\u003e PathBuf {\n        self.storage_root\n            .join(\"profiles\")\n            .join(format!(\"{}.json\", profile_id.safe_name()))\n    }\n}\n\n/// Identifiant unique d'un profil\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct ProfileId {\n    /// Nom du profil choisi par l'utilisateur\n    pub name: String,\n    /// Hash du nom pour √©viter les collisions et cr√©er un nom de fichier s√ªr\n    pub hash: String,\n}\n\nimpl ProfileId {\n    /// Cr√©e un nouvel identifiant de profil\n    #[must_use]\n    pub fn new(name: \u0026str) -\u003e Self {\n        let hash = hex::encode(blake3_32(name.as_bytes()));\n        Self {\n            name: name.to_string(),\n            hash,\n        }\n    }\n\n    /// Retourne un nom de fichier s√©curis√© pour ce profil\n    #[must_use]\n    pub fn safe_name(\u0026self) -\u003e String {\n        format!(\"{}_{}\", sanitize_filename(\u0026self.name), \u0026self.hash[..8])\n    }\n}\n\n/// Informations publiques sur un profil\n#[derive(Debug, Clone)]\npub struct ProfileInfo {\n    /// Identifiant unique du profil\n    pub id: ProfileId,\n    /// Nom du profil\n    pub name: String,\n    /// Date de cr√©ation\n    pub created: DateTime\u003cUtc\u003e,\n    /// Dernier acc√®s\n    pub last_access: DateTime\u003cUtc\u003e,\n    /// Empreinte de la cl√© publique (hex)\n    pub public_key_fingerprint: String,\n}\n\n/// Handle vers un profil charg√© en m√©moire\npub struct ProfileHandle {\n    /// M√©tadonn√©es du profil\n    pub metadata: ProfileMetadata,\n    /// Paire de cl√©s d'identit√© (d√©chiffr√©e)\n    pub identity_keypair: Keypair,\n    /// Param√®tres utilisateur\n    pub settings: ProfileSettings,\n}\n\n/// M√©tadonn√©es d'un profil\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ProfileMetadata {\n    /// Identifiant unique\n    pub id: ProfileId,\n    /// Nom du profil\n    pub name: String,\n    /// Version de Miaou utilis√©e pour cr√©er le profil\n    pub version: String,\n    /// Date de cr√©ation\n    pub created: DateTime\u003cUtc\u003e,\n    /// Dernier acc√®s\n    pub last_access: DateTime\u003cUtc\u003e,\n}\n\n/// Donn√©es d'authentification\n#[derive(Debug, Serialize, Deserialize)]\npub struct AuthenticationData {\n    /// Hash Argon2 du mot de passe\n    pub password_hash: String,\n    /// Sel utilis√© pour la d√©rivation de cl√©\n    pub salt: String,\n    /// Configuration Argon2 utilis√©e (balanced, secure, `fast_insecure`)\n    pub config_type: String,\n}\n\n/// Donn√©es cryptographiques\n#[derive(Debug)]\npub struct KeyData {\n    /// Cl√© publique d'identit√© Ed25519 (32 bytes)\n    pub public_identity: [u8; 32],\n    /// Cl√© priv√©e chiffr√©e avec le mot de passe utilisateur\n    pub encrypted_private_identity: crate::crypto::aead::SealedData,\n    /// Empreinte BLAKE3 de la cl√© publique\n    pub key_fingerprint: [u8; 32],\n}\n\n// S√©rialisation custom pour KeyData\nimpl Serialize for KeyData {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e std::result::Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        use serde::ser::SerializeStruct;\n        let mut state = serializer.serialize_struct(\"KeyData\", 3)?;\n        state.serialize_field(\"public_identity\", \u0026hex::encode(self.public_identity))?;\n        state.serialize_field(\n            \"encrypted_private_nonce\",\n            \u0026hex::encode(self.encrypted_private_identity.nonce),\n        )?;\n        state.serialize_field(\n            \"encrypted_private_ciphertext\",\n            \u0026hex::encode(\u0026self.encrypted_private_identity.ciphertext),\n        )?;\n        state.serialize_field(\"key_fingerprint\", \u0026hex::encode(self.key_fingerprint))?;\n        state.end()\n    }\n}\n\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for KeyData {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e std::result::Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        use serde::de::{self, MapAccess, Visitor};\n        use std::fmt;\n\n        #[derive(Deserialize)]\n        #[serde(field_identifier, rename_all = \"snake_case\")]\n        enum Field {\n            PublicIdentity,\n            EncryptedPrivateNonce,\n            EncryptedPrivateCiphertext,\n            KeyFingerprint,\n        }\n\n        struct KeyDataVisitor;\n\n        impl\u003c'de\u003e Visitor\u003c'de\u003e for KeyDataVisitor {\n            type Value = KeyData;\n\n            fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                formatter.write_str(\"struct KeyData\")\n            }\n\n            fn visit_map\u003cV\u003e(self, mut map: V) -\u003e std::result::Result\u003cKeyData, V::Error\u003e\n            where\n                V: MapAccess\u003c'de\u003e,\n            {\n                let mut public_identity: Option\u003cString\u003e = None;\n                let mut encrypted_private_nonce: Option\u003cString\u003e = None;\n                let mut encrypted_private_ciphertext: Option\u003cString\u003e = None;\n                let mut key_fingerprint: Option\u003cString\u003e = None;\n\n                while let Some(key) = map.next_key()? {\n                    match key {\n                        Field::PublicIdentity =\u003e {\n                            if public_identity.is_some() {\n                                return Err(de::Error::duplicate_field(\"public_identity\"));\n                            }\n                            public_identity = Some(map.next_value()?);\n                        }\n                        Field::EncryptedPrivateNonce =\u003e {\n                            if encrypted_private_nonce.is_some() {\n                                return Err(de::Error::duplicate_field(\"encrypted_private_nonce\"));\n                            }\n                            encrypted_private_nonce = Some(map.next_value()?);\n                        }\n                        Field::EncryptedPrivateCiphertext =\u003e {\n                            if encrypted_private_ciphertext.is_some() {\n                                return Err(de::Error::duplicate_field(\n                                    \"encrypted_private_ciphertext\",\n                                ));\n                            }\n                            encrypted_private_ciphertext = Some(map.next_value()?);\n                        }\n                        Field::KeyFingerprint =\u003e {\n                            if key_fingerprint.is_some() {\n                                return Err(de::Error::duplicate_field(\"key_fingerprint\"));\n                            }\n                            key_fingerprint = Some(map.next_value()?);\n                        }\n                    }\n                }\n\n                let public_identity =\n                    public_identity.ok_or_else(|| de::Error::missing_field(\"public_identity\"))?;\n                let encrypted_private_nonce = encrypted_private_nonce\n                    .ok_or_else(|| de::Error::missing_field(\"encrypted_private_nonce\"))?;\n                let encrypted_private_ciphertext = encrypted_private_ciphertext\n                    .ok_or_else(|| de::Error::missing_field(\"encrypted_private_ciphertext\"))?;\n                let key_fingerprint =\n                    key_fingerprint.ok_or_else(|| de::Error::missing_field(\"key_fingerprint\"))?;\n\n                // D√©coder hex\n                let public_bytes = hex::decode(\u0026public_identity).map_err(de::Error::custom)?;\n                let nonce_bytes =\n                    hex::decode(\u0026encrypted_private_nonce).map_err(de::Error::custom)?;\n                let ciphertext_bytes =\n                    hex::decode(\u0026encrypted_private_ciphertext).map_err(de::Error::custom)?;\n                let fingerprint_bytes = hex::decode(\u0026key_fingerprint).map_err(de::Error::custom)?;\n\n                if public_bytes.len() != 32 {\n                    return Err(de::Error::custom(\"Invalid public key length\"));\n                }\n                if nonce_bytes.len() != 12 {\n                    return Err(de::Error::custom(\"Invalid nonce length\"));\n                }\n                if fingerprint_bytes.len() != 32 {\n                    return Err(de::Error::custom(\"Invalid fingerprint length\"));\n                }\n\n                let mut public_identity = [0u8; 32];\n                public_identity.copy_from_slice(\u0026public_bytes);\n\n                let mut nonce = [0u8; 12];\n                nonce.copy_from_slice(\u0026nonce_bytes);\n\n                let mut key_fingerprint = [0u8; 32];\n                key_fingerprint.copy_from_slice(\u0026fingerprint_bytes);\n\n                Ok(KeyData {\n                    public_identity,\n                    encrypted_private_identity: crate::crypto::aead::SealedData::new(\n                        nonce,\n                        ciphertext_bytes,\n                    ),\n                    key_fingerprint,\n                })\n            }\n        }\n\n        const FIELDS: \u0026[\u0026str] = \u0026[\n            \"public_identity\",\n            \"encrypted_private_nonce\",\n            \"encrypted_private_ciphertext\",\n            \"key_fingerprint\",\n        ];\n        deserializer.deserialize_struct(\"KeyData\", FIELDS, KeyDataVisitor)\n    }\n}\n\n/// Param√®tres utilisateur\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ProfileSettings {\n    /// Accepter automatiquement les demandes d'ami\n    pub auto_accept_friends: bool,\n    /// Niveau de chiffrement (balanced, secure, fast)\n    pub encryption_level: String,\n    /// Sauvegarde automatique activ√©e\n    pub backup_enabled: bool,\n    /// Th√®me de l'interface (dark, light)\n    pub theme: String,\n}\n\nimpl Default for ProfileSettings {\n    fn default() -\u003e Self {\n        Self {\n            auto_accept_friends: false,\n            encryption_level: \"balanced\".to_string(),\n            backup_enabled: true,\n            theme: \"auto\".to_string(),\n        }\n    }\n}\n\n/// Structure compl√®te d'un profil stock√©\n#[derive(Debug, Serialize, Deserialize)]\nstruct ProfileData {\n    metadata: ProfileMetadata,\n    auth: AuthenticationData,\n    keys: KeyData,\n    settings: ProfileSettings,\n}\n\n/// Nettoie un nom de fichier pour qu'il soit safe sur tous les syst√®mes\nfn sanitize_filename(name: \u0026str) -\u003e String {\n    name.chars()\n        .map(|c| match c {\n            'a'..='z' | 'A'..='Z' | '0'..='9' | '-' | '_' =\u003e c,\n            _ =\u003e '_',\n        })\n        .collect::\u003cString\u003e()\n        .chars()\n        .take(32) // Limiter la longueur\n        .collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use tempfile::TempDir;\n\n    #[test]\n    fn test_profile_creation_and_loading() {\n        let temp_dir = TempDir::new().unwrap();\n        let storage = SecureStorage::new(temp_dir.path()).unwrap();\n\n        let password = SecretString::new(\"test_password_123\".to_string());\n\n        // Cr√©er un profil\n        let profile_id = storage.create_profile(\"alice\", \u0026password).unwrap();\n        assert_eq!(profile_id.name, \"alice\");\n\n        // Charger le profil\n        let profile = storage.load_profile(\u0026profile_id, \u0026password).unwrap();\n        assert_eq!(profile.metadata.name, \"alice\");\n\n        // Mauvais mot de passe\n        let wrong_password = SecretString::new(\"wrong_password\".to_string());\n        assert!(storage.load_profile(\u0026profile_id, \u0026wrong_password).is_err());\n    }\n\n    #[test]\n    fn test_profile_listing() {\n        let temp_dir = TempDir::new().unwrap();\n        let storage = SecureStorage::new(temp_dir.path()).unwrap();\n\n        let password = SecretString::new(\"test_password_123\".to_string());\n\n        // Cr√©er plusieurs profils\n        storage.create_profile(\"alice\", \u0026password).unwrap();\n        storage.create_profile(\"bob\", \u0026password).unwrap();\n\n        // Lister les profils\n        let profiles = storage.list_profiles().unwrap();\n        assert_eq!(profiles.len(), 2);\n\n        let names: Vec\u003c_\u003e = profiles.iter().map(|p| \u0026p.name).collect();\n        assert!(names.contains(\u0026\u0026\"alice\".to_string()));\n        assert!(names.contains(\u0026\u0026\"bob\".to_string()));\n    }\n\n    #[test]\n    fn test_profile_deletion() {\n        let temp_dir = TempDir::new().unwrap();\n        let storage = SecureStorage::new(temp_dir.path()).unwrap();\n\n        let password = SecretString::new(\"test_password_123\".to_string());\n\n        // Cr√©er un profil\n        let profile_id = storage.create_profile(\"test_user\", \u0026password).unwrap();\n\n        // V√©rifier qu'il existe\n        assert!(storage.load_profile(\u0026profile_id, \u0026password).is_ok());\n\n        // Le supprimer\n        storage.delete_profile(\u0026profile_id).unwrap();\n\n        // V√©rifier qu'il n'existe plus\n        assert!(storage.load_profile(\u0026profile_id, \u0026password).is_err());\n    }\n\n    #[test]\n    fn test_profile_id_generation() {\n        let id1 = ProfileId::new(\"alice\");\n        let id2 = ProfileId::new(\"alice\");\n        let id3 = ProfileId::new(\"bob\");\n\n        // Same name should produce same ID\n        assert_eq!(id1.name, id2.name);\n        assert_eq!(id1.hash, id2.hash);\n\n        // Different names should produce different IDs  \n        assert_ne!(id1.hash, id3.hash);\n        assert_eq!(id1.name, \"alice\");\n        assert_eq!(id3.name, \"bob\");\n    }\n\n    #[test]\n    fn test_profile_id_safe_name() {\n        let id1 = ProfileId::new(\"alice\");\n        let id2 = ProfileId::new(\"bob@domain.com\");\n        let id3 = ProfileId::new(\"user with spaces\");\n\n        let safe1 = id1.safe_name();\n        let safe2 = id2.safe_name();  \n        let safe3 = id3.safe_name();\n\n        // All safe names should be filesystem safe\n        assert!(safe1.chars().all(|c| c.is_ascii_alphanumeric() || c == '_'));\n        assert!(safe2.chars().all(|c| c.is_ascii_alphanumeric() || c == '_'));\n        assert!(safe3.chars().all(|c| c.is_ascii_alphanumeric() || c == '_'));\n\n        // Should contain hash suffix\n        assert!(safe1.contains(\u0026id1.hash[..8]));\n        assert!(safe2.contains(\u0026id2.hash[..8]));\n        assert!(safe3.contains(\u0026id3.hash[..8]));\n    }\n\n    #[test]\n    fn test_sanitize_filename() {\n        assert_eq!(sanitize_filename(\"normal\"), \"normal\");\n        assert_eq!(sanitize_filename(\"user@domain.com\"), \"user_domain_com\");\n        assert_eq!(sanitize_filename(\"user with spaces\"), \"user_with_spaces\");\n        assert_eq!(sanitize_filename(\"user/\\\\\u003c\u003e:|?*\"), \"user________\");\n        \n        // Should limit length\n        let long_name = \"a\".repeat(100);\n        let sanitized = sanitize_filename(\u0026long_name);\n        assert_eq!(sanitized.len(), 32);\n    }\n\n    #[test]\n    fn test_create_profile_already_exists() {\n        let temp_dir = TempDir::new().unwrap();\n        let storage = SecureStorage::new(temp_dir.path()).unwrap();\n        let password = SecretString::new(\"test_password\".to_string());\n\n        // Create first profile\n        storage.create_profile(\"alice\", \u0026password).unwrap();\n\n        // Try to create same profile again\n        let result = storage.create_profile(\"alice\", \u0026password);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_load_profile_not_found() {\n        let temp_dir = TempDir::new().unwrap();\n        let storage = SecureStorage::new(temp_dir.path()).unwrap();\n        let password = SecretString::new(\"test_password\".to_string());\n\n        let fake_id = ProfileId::new(\"nonexistent\");\n        let result = storage.load_profile(\u0026fake_id, \u0026password);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_delete_profile_not_found() {\n        let temp_dir = TempDir::new().unwrap();\n        let storage = SecureStorage::new(temp_dir.path()).unwrap();\n\n        let fake_id = ProfileId::new(\"nonexistent\");\n        let result = storage.delete_profile(\u0026fake_id);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_list_profiles_empty() {\n        let temp_dir = TempDir::new().unwrap();\n        let storage = SecureStorage::new(temp_dir.path()).unwrap();\n\n        let profiles = storage.list_profiles().unwrap();\n        assert_eq!(profiles.len(), 0);\n    }\n\n    #[test]\n    fn test_profile_settings_default() {\n        let settings = ProfileSettings::default();\n        assert!(!settings.auto_accept_friends);\n        assert_eq!(settings.encryption_level, \"balanced\");\n        assert!(settings.backup_enabled);\n        assert_eq!(settings.theme, \"auto\");\n    }\n\n    #[test]\n    fn test_profile_loading_with_different_configs() {\n        let temp_dir = TempDir::new().unwrap();\n        let storage = SecureStorage::new(temp_dir.path()).unwrap();\n\n        // Test loading profiles with different Argon2 configs\n        let passwords = [\n            SecretString::new(\"password1\".to_string()),\n            SecretString::new(\"password2\".to_string()),\n            SecretString::new(\"password3\".to_string()),\n        ];\n\n        let names = [\"user_fast\", \"user_balanced\", \"user_secure\"];\n\n        for (i, (name, password)) in names.iter().zip(passwords.iter()).enumerate() {\n            let profile_id = storage.create_profile(name, password).unwrap();\n            \n            // Should be able to load the profile\n            let loaded_profile = storage.load_profile(\u0026profile_id, password).unwrap();\n            assert_eq!(loaded_profile.metadata.name, *name);\n\n            // Wrong password should fail\n            let wrong_password = SecretString::new(format!(\"wrong_{i}\"));\n            assert!(storage.load_profile(\u0026profile_id, \u0026wrong_password).is_err());\n        }\n    }\n\n    #[test]\n    fn test_profile_key_integrity() {\n        let temp_dir = TempDir::new().unwrap();\n        let storage = SecureStorage::new(temp_dir.path()).unwrap();\n        let password = SecretString::new(\"test_password\".to_string());\n\n        let profile_id = storage.create_profile(\"alice\", \u0026password).unwrap();\n        let profile = storage.load_profile(\u0026profile_id, \u0026password).unwrap();\n\n        // Test that the keys work for crypto operations\n        let message = b\"test message for signing\";\n        let signature = profile.identity_keypair.sign(message);\n        \n        // Verify signature works\n        assert!(profile.identity_keypair.verify(message, \u0026signature).is_ok());\n        \n        // Wrong message should fail verification\n        assert!(profile.identity_keypair.verify(b\"wrong message\", \u0026signature).is_err());\n    }\n\n    #[test]\n    fn test_profile_metadata_consistency() {\n        let temp_dir = TempDir::new().unwrap();\n        let storage = SecureStorage::new(temp_dir.path()).unwrap();\n        let password = SecretString::new(\"test_password\".to_string());\n\n        let profile_id = storage.create_profile(\"test_user\", \u0026password).unwrap();\n        let profile = storage.load_profile(\u0026profile_id, \u0026password).unwrap();\n\n        // Metadata should be consistent\n        assert_eq!(profile.metadata.id.name, \"test_user\");\n        assert_eq!(profile.metadata.name, \"test_user\");\n        assert_eq!(profile.metadata.version, \"0.1.0\");\n        assert!(profile.metadata.created \u003c= chrono::Utc::now());\n        assert!(profile.metadata.last_access \u003c= chrono::Utc::now());\n        assert!(profile.metadata.last_access \u003e= profile.metadata.created);\n    }\n\n    #[test] \n    fn test_secure_storage_directory_creation() {\n        let temp_dir = TempDir::new().unwrap();\n        let storage_path = temp_dir.path().join(\"new_storage\");\n\n        // Directory doesn't exist yet\n        assert!(!storage_path.exists());\n\n        // Creating storage should create directories\n        let _storage = SecureStorage::new(\u0026storage_path).unwrap();\n        assert!(storage_path.exists());\n        assert!(storage_path.join(\"profiles\").exists());\n        assert!(storage_path.join(\"keystore\").exists());\n    }\n}\n","traces":[{"line":61,"address":[542736,543537,543552,542784,544384,543608],"length":1,"stats":{"Line":3}},{"line":62,"address":[543582,542758,542829,543653],"length":1,"stats":{"Line":6}},{"line":65,"address":[746962,747017,747653],"length":1,"stats":{"Line":6}},{"line":66,"address":[543844,543531,543008,544378],"length":1,"stats":{"Line":3}},{"line":67,"address":[544030,543513,544357,543191],"length":1,"stats":{"Line":3}},{"line":69,"address":[],"length":0,"stats":{"Line":3}},{"line":76,"address":[722761,722436,718736],"length":1,"stats":{"Line":1}},{"line":77,"address":[718821],"length":1,"stats":{"Line":1}},{"line":78,"address":[1934373],"length":1,"stats":{"Line":1}},{"line":81,"address":[1934429,1934497],"length":1,"stats":{"Line":2}},{"line":82,"address":[1934547,1938191],"length":1,"stats":{"Line":2}},{"line":86,"address":[1934518],"length":1,"stats":{"Line":1}},{"line":88,"address":[1934569],"length":1,"stats":{"Line":1}},{"line":91,"address":[1934647],"length":1,"stats":{"Line":1}},{"line":92,"address":[719236,722595],"length":1,"stats":{"Line":1}},{"line":95,"address":[1934918],"length":1,"stats":{"Line":1}},{"line":96,"address":[1938081,1934983],"length":1,"stats":{"Line":1}},{"line":97,"address":[719671],"length":1,"stats":{"Line":1}},{"line":100,"address":[1935222],"length":1,"stats":{"Line":1}},{"line":110,"address":[720386],"length":1,"stats":{"Line":1}},{"line":117,"address":[1936245],"length":1,"stats":{"Line":1}},{"line":122,"address":[721059],"length":1,"stats":{"Line":1}},{"line":127,"address":[1936683],"length":1,"stats":{"Line":1}},{"line":131,"address":[1937201,1937130,1937994],"length":1,"stats":{"Line":2}},{"line":132,"address":[721843,721957,722389],"length":1,"stats":{"Line":2}},{"line":135,"address":[722055],"length":1,"stats":{"Line":1}},{"line":136,"address":[722087],"length":1,"stats":{"Line":1}},{"line":137,"address":[722106],"length":1,"stats":{"Line":1}},{"line":138,"address":[1937682],"length":1,"stats":{"Line":1}},{"line":140,"address":[722162],"length":1,"stats":{"Line":1}},{"line":147,"address":[722800,726660,726933],"length":1,"stats":{"Line":1}},{"line":152,"address":[722886],"length":1,"stats":{"Line":1}},{"line":154,"address":[1938582,1938499],"length":1,"stats":{"Line":2}},{"line":155,"address":[1938617,1938673],"length":1,"stats":{"Line":2}},{"line":159,"address":[726928,723091,723224],"length":1,"stats":{"Line":2}},{"line":160,"address":[1938984,1939067,1942621],"length":1,"stats":{"Line":2}},{"line":163,"address":[723704,726806,723800],"length":1,"stats":{"Line":2}},{"line":164,"address":[723958,724047],"length":1,"stats":{"Line":2}},{"line":168,"address":[1942480,1939842,1939755,1939607,1939709],"length":1,"stats":{"Line":3}},{"line":169,"address":[724133,724191],"length":1,"stats":{"Line":1}},{"line":170,"address":[724404],"length":1,"stats":{"Line":1}},{"line":171,"address":[1940096,1940177,1940433],"length":1,"stats":{"Line":3}},{"line":172,"address":[724583,724804,724631,724528],"length":1,"stats":{"Line":0}},{"line":173,"address":[1940283,1940332,1940386,1940228],"length":1,"stats":{"Line":0}},{"line":174,"address":[724737,724666],"length":1,"stats":{"Line":0}},{"line":177,"address":[1940396,1942475,1940435],"length":1,"stats":{"Line":2}},{"line":178,"address":[1940583],"length":1,"stats":{"Line":1}},{"line":184,"address":[1940642],"length":1,"stats":{"Line":1}},{"line":188,"address":[725268,725341],"length":1,"stats":{"Line":2}},{"line":189,"address":[725395,726753],"length":1,"stats":{"Line":0}},{"line":191,"address":[725347],"length":1,"stats":{"Line":1}},{"line":192,"address":[1941005,1941090],"length":1,"stats":{"Line":2}},{"line":193,"address":[1942417,1941121],"length":1,"stats":{"Line":1}},{"line":196,"address":[1941433,1941370],"length":1,"stats":{"Line":2}},{"line":197,"address":[1941502,1942379],"length":1,"stats":{"Line":0}},{"line":201,"address":[1942345,1941553,1941490],"length":1,"stats":{"Line":2}},{"line":203,"address":[726257],"length":1,"stats":{"Line":1}},{"line":204,"address":[725991],"length":1,"stats":{"Line":1}},{"line":205,"address":[726169],"length":1,"stats":{"Line":1}},{"line":206,"address":[726185],"length":1,"stats":{"Line":1}},{"line":214,"address":[1942656,1945231,1945660],"length":1,"stats":{"Line":2}},{"line":215,"address":[1942706],"length":1,"stats":{"Line":2}},{"line":216,"address":[1942768],"length":1,"stats":{"Line":2}},{"line":218,"address":[1942831,1942915],"length":1,"stats":{"Line":4}},{"line":219,"address":[1942944],"length":1,"stats":{"Line":1}},{"line":222,"address":[727605,727387,727345,729773],"length":1,"stats":{"Line":3}},{"line":223,"address":[727683,727887],"length":1,"stats":{"Line":2}},{"line":224,"address":[728055],"length":1,"stats":{"Line":1}},{"line":226,"address":[728198,728130,729713],"length":1,"stats":{"Line":5}},{"line":227,"address":[728448,728350],"length":1,"stats":{"Line":2}},{"line":228,"address":[728671,728496,728573],"length":1,"stats":{"Line":3}},{"line":229,"address":[728952],"length":1,"stats":{"Line":1}},{"line":230,"address":[728709],"length":1,"stats":{"Line":1}},{"line":231,"address":[728757],"length":1,"stats":{"Line":1}},{"line":232,"address":[1944553],"length":1,"stats":{"Line":1}},{"line":233,"address":[728819],"length":1,"stats":{"Line":1}},{"line":234,"address":[728849],"length":1,"stats":{"Line":1}},{"line":242,"address":[1943444],"length":1,"stats":{"Line":3}},{"line":244,"address":[727758],"length":1,"stats":{"Line":1}},{"line":251,"address":[1946114,1946120,1945680],"length":1,"stats":{"Line":1}},{"line":252,"address":[729884],"length":1,"stats":{"Line":1}},{"line":254,"address":[1945802,1945734],"length":1,"stats":{"Line":2}},{"line":255,"address":[1945828,1945875],"length":1,"stats":{"Line":2}},{"line":258,"address":[730121,730252,730019],"length":1,"stats":{"Line":2}},{"line":262,"address":[1946067],"length":1,"stats":{"Line":1}},{"line":266,"address":[1946144,1947710,1947276],"length":1,"stats":{"Line":1}},{"line":267,"address":[730317],"length":1,"stats":{"Line":1}},{"line":269,"address":[730499,730366,730414],"length":1,"stats":{"Line":3}},{"line":270,"address":[1946573,1946395,1946463],"length":1,"stats":{"Line":3}},{"line":271,"address":[1946674,1946611],"length":1,"stats":{"Line":2}},{"line":272,"address":[731391,730852],"length":1,"stats":{"Line":1}},{"line":273,"address":[731029,731330,731140],"length":1,"stats":{"Line":2}},{"line":277,"address":[731745],"length":1,"stats":{"Line":1}},{"line":281,"address":[732225,731808,732231],"length":1,"stats":{"Line":1}},{"line":282,"address":[1947824,1947779],"length":1,"stats":{"Line":2}},{"line":284,"address":[1947906],"length":1,"stats":{"Line":1}},{"line":300,"address":[1948489,1948483,1948192],"length":1,"stats":{"Line":1}},{"line":301,"address":[1948251],"length":1,"stats":{"Line":1}},{"line":303,"address":[1948307],"length":1,"stats":{"Line":1}},{"line":310,"address":[732952,732576,732946],"length":1,"stats":{"Line":1}},{"line":311,"address":[732614],"length":1,"stats":{"Line":1}},{"line":379,"address":[545873,545979,544512],"length":1,"stats":{"Line":1}},{"line":384,"address":[2054940],"length":1,"stats":{"Line":1}},{"line":385,"address":[],"length":0,"stats":{"Line":2}},{"line":386,"address":[2055652,2055483,2056343,2055576],"length":1,"stats":{"Line":2}},{"line":388,"address":[],"length":0,"stats":{"Line":1}},{"line":390,"address":[545392,545468,545303,545884],"length":1,"stats":{"Line":2}},{"line":392,"address":[2055702],"length":1,"stats":{"Line":1}},{"line":394,"address":[2055940,2056277],"length":1,"stats":{"Line":1}},{"line":395,"address":[545776],"length":1,"stats":{"Line":1}},{"line":400,"address":[546000,546064],"length":1,"stats":{"Line":1}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[546144,551690,552130],"length":1,"stats":{"Line":1}},{"line":429,"address":[2056618],"length":1,"stats":{"Line":1}},{"line":430,"address":[2056684],"length":1,"stats":{"Line":1}},{"line":431,"address":[2056710],"length":1,"stats":{"Line":1}},{"line":432,"address":[546304],"length":1,"stats":{"Line":1}},{"line":434,"address":[2062494,2056762,2056830],"length":1,"stats":{"Line":2}},{"line":435,"address":[2057001],"length":1,"stats":{"Line":1}},{"line":436,"address":[547124],"length":1,"stats":{"Line":1}},{"line":437,"address":[2057202,2057082],"length":1,"stats":{"Line":2}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[546985,546817,546760,547129],"length":1,"stats":{"Line":2}},{"line":442,"address":[547575],"length":1,"stats":{"Line":1}},{"line":443,"address":[2057108,2057668],"length":1,"stats":{"Line":2}},{"line":444,"address":[547598,547221],"length":1,"stats":{"Line":0}},{"line":446,"address":[547214,547580,547436,547268],"length":1,"stats":{"Line":2}},{"line":448,"address":[2058510],"length":1,"stats":{"Line":1}},{"line":449,"address":[2057137,2058115],"length":1,"stats":{"Line":2}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[2058515,2058371,2058179,2058121],"length":1,"stats":{"Line":2}},{"line":456,"address":[548445],"length":1,"stats":{"Line":1}},{"line":457,"address":[2057166,2058562],"length":1,"stats":{"Line":2}},{"line":458,"address":[548468,548091],"length":1,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":2}},{"line":465,"address":[2062489,2057010,2059002,2062897,2062896],"length":1,"stats":{"Line":2}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":2}},{"line":468,"address":[2059215,2059358,2062929,2062928],"length":1,"stats":{"Line":1}},{"line":469,"address":[549050,551831,548927,549118],"length":1,"stats":{"Line":2}},{"line":470,"address":[],"length":0,"stats":{"Line":1}},{"line":471,"address":[],"length":0,"stats":{"Line":2}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[2060027,2062421,2060098],"length":1,"stats":{"Line":2}},{"line":476,"address":[],"length":0,"stats":{"Line":2}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":2}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":2}},{"line":482,"address":[2061189,2061116],"length":1,"stats":{"Line":2}},{"line":483,"address":[551652,550599],"length":1,"stats":{"Line":0}},{"line":485,"address":[550631,550575],"length":1,"stats":{"Line":2}},{"line":486,"address":[550661,551620],"length":1,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":2}},{"line":489,"address":[550747,551571],"length":1,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":1}},{"line":493,"address":[550718,550784],"length":1,"stats":{"Line":2}},{"line":495,"address":[550815],"length":1,"stats":{"Line":1}},{"line":496,"address":[2061470],"length":1,"stats":{"Line":1}},{"line":498,"address":[550908],"length":1,"stats":{"Line":1}},{"line":499,"address":[],"length":0,"stats":{"Line":1}},{"line":501,"address":[2061806],"length":1,"stats":{"Line":1}},{"line":502,"address":[2061629],"length":1,"stats":{"Line":1}},{"line":503,"address":[],"length":0,"stats":{"Line":1}},{"line":504,"address":[551029],"length":1,"stats":{"Line":1}},{"line":505,"address":[551059],"length":1,"stats":{"Line":1}},{"line":507,"address":[2061774],"length":1,"stats":{"Line":1}},{"line":518,"address":[546086,546017],"length":1,"stats":{"Line":1}},{"line":536,"address":[1948976,1949153,1949159],"length":1,"stats":{"Line":1}},{"line":539,"address":[1948989],"length":1,"stats":{"Line":1}},{"line":541,"address":[733089],"length":1,"stats":{"Line":1}},{"line":556,"address":[1949184,1949452,1949446],"length":1,"stats":{"Line":1}},{"line":557,"address":[733343,733304],"length":1,"stats":{"Line":2}},{"line":558,"address":[552384,552470],"length":1,"stats":{"Line":3}},{"line":559,"address":[552397,552434,552492],"length":1,"stats":{"Line":3}},{"line":560,"address":[552499],"length":1,"stats":{"Line":1}}],"covered":159,"coverable":179},{"path":["/","home","seb","Dev","miaou","miaou-crypto","src","aead.rs"],"content":"//! # AEAD ChaCha20-Poly1305 (v0.1)\n//!\n//! Chiffrement authentifi√© avec nonce 96 bits (12 octets) et AAD obligatoire.\n//! Utilise ChaCha20-Poly1305 standard avec gestion stricte des nonces.\n\nuse crate::CryptoError;\nuse chacha20poly1305::{\n    aead::{Aead, KeyInit, Payload},\n    ChaCha20Poly1305, Key, Nonce,\n};\nuse rand_core::RngCore;\nuse zeroize::{Zeroize, ZeroizeOnDrop};\n\n/// Cl√© AEAD opaque (32 octets) avec Zeroize automatique\n#[derive(ZeroizeOnDrop)]\npub struct AeadKeyRef {\n    key: Key,\n}\n\nimpl AeadKeyRef {\n    /// Construit une cl√© AEAD depuis 32 octets.\n    #[must_use]\n    pub fn from_bytes(k: [u8; 32]) -\u003e Self {\n        Self {\n            key: Key::from_slice(\u0026k).to_owned(),\n        }\n    }\n\n    /// G√©n√®re une nouvelle cl√© AEAD al√©atoire.\n    #[must_use]\n    pub fn generate(rng: \u0026mut dyn RngCore) -\u003e Self {\n        let mut key_bytes = [0u8; 32];\n        rng.fill_bytes(\u0026mut key_bytes);\n        let result = Self::from_bytes(key_bytes);\n        key_bytes.zeroize();\n        result\n    }\n\n    /// Retourne une r√©f√©rence vers la cl√© interne (usage interne).\n    #[must_use]\n    pub(crate) const fn as_key(\u0026self) -\u003e \u0026Key {\n        \u0026self.key\n    }\n}\n\n// Pas de Debug pour √©viter les fuites\nimpl std::fmt::Debug for AeadKeyRef {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"AeadKeyRef([REDACTED])\")\n    }\n}\n\n/// Donn√©es scell√©es avec nonce int√©gr√©\n#[derive(Clone, Debug)]\npub struct SealedData {\n    /// Nonce `ChaCha20` (96-bit)\n    pub nonce: [u8; 12],\n    /// Donn√©es chiffr√©es avec tag `Poly1305` inclus\n    pub ciphertext: Vec\u003cu8\u003e,\n}\n\nimpl SealedData {\n    /// Cr√©e un nouveau `SealedData`\n    #[must_use]\n    pub const fn new(nonce: [u8; 12], ciphertext: Vec\u003cu8\u003e) -\u003e Self {\n        Self { nonce, ciphertext }\n    }\n\n    /// Retourne la taille totale (nonce + ciphertext)\n    #[must_use]\n    pub const fn total_size(\u0026self) -\u003e usize {\n        12 + self.ciphertext.len()\n    }\n}\n\n/// G√©n√®re un nonce al√©atoire 12 octets pour `ChaCha20`.\n#[must_use]\npub fn random_nonce(rng: \u0026mut dyn RngCore) -\u003e [u8; 12] {\n    let mut nonce = [0u8; 12];\n    rng.fill_bytes(\u0026mut nonce);\n    nonce\n}\n\n/// Chiffre avec `ChaCha20-Poly1305` (nonce externe).\n///\n/// # Errors\n/// Retourne une erreur si l'AEAD √©choue (cl√© invalide, AAD non concordante, ou impl. sous-jacente en √©chec).\npub fn encrypt(\n    key: \u0026AeadKeyRef,\n    nonce: [u8; 12],\n    aad: \u0026[u8],\n    plaintext: \u0026[u8],\n) -\u003e Result\u003cSealedData, CryptoError\u003e {\n    // AAD ne doit jamais √™tre vide\n    if aad.is_empty() {\n        return Err(CryptoError::EmptyAad);\n    }\n\n    let cipher = ChaCha20Poly1305::new(key.as_key());\n    let nonce_ref = Nonce::from_slice(\u0026nonce);\n\n    let payload = Payload {\n        msg: plaintext,\n        aad,\n    };\n\n    let ciphertext = cipher\n        .encrypt(nonce_ref, payload)\n        .map_err(|_| CryptoError::EncryptionFailed)?;\n\n    Ok(SealedData::new(nonce, ciphertext))\n}\n\n/// D√©chiffre avec `ChaCha20-Poly1305`.\n///\n/// # Errors\n/// Retourne une erreur si l'authentification √©choue (tag invalide), si le nonce est incorrect ou sur erreur interne.\npub fn decrypt(key: \u0026AeadKeyRef, aad: \u0026[u8], sealed: \u0026SealedData) -\u003e Result\u003cVec\u003cu8\u003e, CryptoError\u003e {\n    // AAD ne doit jamais √™tre vide\n    if aad.is_empty() {\n        return Err(CryptoError::EmptyAad);\n    }\n\n    let cipher = ChaCha20Poly1305::new(key.as_key());\n    let nonce_ref = Nonce::from_slice(\u0026sealed.nonce);\n\n    let payload = Payload {\n        msg: \u0026sealed.ciphertext,\n        aad,\n    };\n\n    cipher\n        .decrypt(nonce_ref, payload)\n        .map_err(|_| CryptoError::DecryptionFailed)\n}\n\n/// Chiffre avec g√©n√©ration automatique de nonce.\n///\n/// # Errors\n/// Retourne une erreur si le chiffrement √©choue.\npub fn encrypt_auto_nonce(\n    key: \u0026AeadKeyRef,\n    aad: \u0026[u8],\n    plaintext: \u0026[u8],\n    rng: \u0026mut dyn RngCore,\n) -\u003e Result\u003cSealedData, CryptoError\u003e {\n    let nonce = random_nonce(rng);\n    encrypt(key, nonce, aad, plaintext)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_core::OsRng;\n\n    #[test]\n    fn test_aead_roundtrip() {\n        let key = AeadKeyRef::from_bytes([42u8; 32]);\n        let nonce = [1u8; 12];\n        let aad = b\"miaou_v1\";\n\n        let sealed = encrypt(\u0026key, nonce, aad, b\"hello world\").unwrap();\n        let decrypted = decrypt(\u0026key, aad, \u0026sealed).unwrap();\n\n        assert_eq!(decrypted, b\"hello world\");\n        assert_eq!(sealed.nonce, nonce);\n    }\n\n    #[test]\n    fn test_aad_enforcement() {\n        let key = AeadKeyRef::from_bytes([42u8; 32]);\n        let nonce = [1u8; 12];\n\n        // AAD vide doit √©chouer\n        let result = encrypt(\u0026key, nonce, b\"\", b\"plaintext\");\n        assert!(matches!(result, Err(CryptoError::EmptyAad)));\n\n        // AAD non-vide doit fonctionner\n        let result = encrypt(\u0026key, nonce, b\"version:1\", b\"plaintext\");\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_aad_mismatch() {\n        let key = AeadKeyRef::from_bytes([42u8; 32]);\n        let nonce = [1u8; 12];\n\n        let sealed = encrypt(\u0026key, nonce, b\"aad1\", b\"message\").unwrap();\n\n        // AAD diff√©rent doit √©chouer\n        let result = decrypt(\u0026key, b\"aad2\", \u0026sealed);\n        assert!(matches!(result, Err(CryptoError::DecryptionFailed)));\n\n        // AAD correct doit fonctionner\n        let result = decrypt(\u0026key, b\"aad1\", \u0026sealed);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_nonce_uniqueness() {\n        let mut rng = OsRng;\n        let mut nonces = std::collections::HashSet::new();\n\n        // G√©n√©rer 1000 nonces et v√©rifier unicit√©\n        for _ in 0..1000 {\n            let nonce = random_nonce(\u0026mut rng);\n            assert!(nonces.insert(nonce)); // Doit √™tre unique\n        }\n    }\n\n    #[test]\n    fn test_auto_nonce_encryption() {\n        let key = AeadKeyRef::generate(\u0026mut OsRng);\n        let mut rng = OsRng;\n\n        let sealed = encrypt_auto_nonce(\u0026key, b\"aad\", b\"message\", \u0026mut rng).unwrap();\n        let decrypted = decrypt(\u0026key, b\"aad\", \u0026sealed).unwrap();\n\n        assert_eq!(decrypted, b\"message\");\n    }\n\n    #[test]\n    fn test_decrypt_with_empty_aad() {\n        let key = AeadKeyRef::from_bytes([42u8; 32]);\n        let nonce = [1u8; 12];\n        \n        // First encrypt with valid AAD\n        let sealed = encrypt(\u0026key, nonce, b\"valid_aad\", b\"message\").unwrap();\n        \n        // Try to decrypt with empty AAD should fail\n        let result = decrypt(\u0026key, b\"\", \u0026sealed);\n        assert!(matches!(result, Err(CryptoError::EmptyAad)));\n    }\n\n    #[test]\n    fn test_encrypt_auto_nonce_success() {\n        let key = AeadKeyRef::from_bytes([42u8; 32]);\n        let aad = b\"test_aad\";\n        let plaintext = b\"test message\";\n        let mut rng = OsRng;\n        \n        let sealed = encrypt_auto_nonce(\u0026key, aad, plaintext, \u0026mut rng).unwrap();\n        let decrypted = decrypt(\u0026key, aad, \u0026sealed).unwrap();\n        \n        assert_eq!(decrypted, plaintext);\n        assert_eq!(sealed.nonce.len(), 12);\n    }\n\n    #[test]\n    fn test_sealed_data_total_size() {\n        let key = AeadKeyRef::from_bytes([42u8; 32]);\n        let nonce = [1u8; 12];\n        let aad = b\"test_aad\";\n        let plaintext = b\"hello world\"; // 11 bytes\n        \n        let sealed = encrypt(\u0026key, nonce, aad, plaintext).unwrap();\n        \n        // Total size should be nonce + ciphertext + tag\n        // ChaCha20-Poly1305 adds 16 bytes for authentication tag\n        let expected_size = 12 + 11 + 16; // nonce + plaintext + tag\n        assert_eq!(sealed.total_size(), expected_size);\n    }\n\n    #[test]\n    fn test_aead_key_ref_generate() {\n        let mut rng = OsRng;\n        let key1 = AeadKeyRef::generate(\u0026mut rng);\n        let key2 = AeadKeyRef::generate(\u0026mut rng);\n        \n        // Generated keys should be different\n        assert_ne!(key1.as_key().as_slice(), key2.as_key().as_slice());\n    }\n\n    #[test]\n    fn test_aead_key_ref_debug() {\n        let key = AeadKeyRef::from_bytes([42u8; 32]);\n        let debug_str = format!(\"{:?}\", key);\n        \n        // Should not expose key material\n        assert!(debug_str.contains(\"AeadKeyRef([REDACTED])\"));\n    }\n\n    #[test]\n    fn test_key_zeroization() {\n        // Test que AeadKeyRef impl√©mente ZeroizeOnDrop\n        fn assert_zeroize_on_drop\u003cT: ZeroizeOnDrop\u003e() {}\n        assert_zeroize_on_drop::\u003cAeadKeyRef\u003e();\n    }\n}\n","traces":[{"line":23,"address":[1445152],"length":1,"stats":{"Line":5}},{"line":25,"address":[1445177],"length":1,"stats":{"Line":5}},{"line":31,"address":[493118,493112,492896],"length":1,"stats":{"Line":2}},{"line":32,"address":[3540524],"length":1,"stats":{"Line":2}},{"line":33,"address":[3540537],"length":1,"stats":{"Line":2}},{"line":34,"address":[1445342],"length":1,"stats":{"Line":2}},{"line":35,"address":[3231450],"length":1,"stats":{"Line":2}},{"line":36,"address":[493069],"length":1,"stats":{"Line":2}},{"line":41,"address":[3540736],"length":1,"stats":{"Line":5}},{"line":48,"address":[1419568],"length":1,"stats":{"Line":1}},{"line":49,"address":[3540770],"length":1,"stats":{"Line":1}},{"line":65,"address":[3540816],"length":1,"stats":{"Line":5}},{"line":71,"address":[1419680],"length":1,"stats":{"Line":1}},{"line":72,"address":[1419689,1419719],"length":1,"stats":{"Line":1}},{"line":78,"address":[3540928],"length":1,"stats":{"Line":5}},{"line":79,"address":[3540962],"length":1,"stats":{"Line":5}},{"line":80,"address":[3231837],"length":1,"stats":{"Line":5}},{"line":81,"address":[3231860],"length":1,"stats":{"Line":5}},{"line":88,"address":[1419856,1420654,1420681],"length":1,"stats":{"Line":5}},{"line":95,"address":[1419967],"length":1,"stats":{"Line":5}},{"line":96,"address":[493618],"length":1,"stats":{"Line":1}},{"line":99,"address":[1445958],"length":1,"stats":{"Line":5}},{"line":100,"address":[3541345,3541201],"length":1,"stats":{"Line":10}},{"line":107,"address":[3232370,3232292],"length":1,"stats":{"Line":5}},{"line":108,"address":[1420201],"length":1,"stats":{"Line":5}},{"line":109,"address":[1446201,1446274],"length":1,"stats":{"Line":5}},{"line":111,"address":[3541766,3541628],"length":1,"stats":{"Line":10}},{"line":118,"address":[3233164,3232736,3233158],"length":1,"stats":{"Line":5}},{"line":120,"address":[1420789],"length":1,"stats":{"Line":5}},{"line":121,"address":[3232893],"length":1,"stats":{"Line":1}},{"line":124,"address":[3541988],"length":1,"stats":{"Line":5}},{"line":125,"address":[3542144,3542015],"length":1,"stats":{"Line":10}},{"line":128,"address":[3233000],"length":1,"stats":{"Line":5}},{"line":133,"address":[1421046],"length":1,"stats":{"Line":5}},{"line":134,"address":[494627],"length":1,"stats":{"Line":7}},{"line":141,"address":[1421152],"length":1,"stats":{"Line":5}},{"line":147,"address":[3233291],"length":1,"stats":{"Line":5}},{"line":148,"address":[3233332],"length":1,"stats":{"Line":5}}],"covered":38,"coverable":38},{"path":["/","home","seb","Dev","miaou","miaou-crypto","src","encryption.rs"],"content":"//! Chiffrement authentifi√© avec ChaCha20-Poly1305\n//! \n//! Impl√©mentation s√©curis√©e du chiffrement AEAD (Authenticated Encryption with Associated Data)\n//! utilisant ChaCha20-Poly1305 selon RFC 8439.\n\nuse crate::crypto::{CryptoError, CryptoResult, NONCE_SIZE, KEY_SIZE};\nuse chacha20poly1305::{\n    aead::{Aead, NewAead},\n    ChaCha20Poly1305, Nonce, Key\n};\nuse rand::RngCore;\nuse zeroize::{Zeroize, ZeroizeOnDrop};\nuse serde::{Deserialize, Serialize};\n\n/// Trait pour les moteurs de chiffrement\npub trait EncryptionEngine {\n    /// G√©n√®re une nouvelle cl√© de chiffrement\n    fn generate_key() -\u003e CryptoResult\u003cSelf\u003e where Self: Sized;\n    \n    /// Chiffre des donn√©es avec un nonce donn√©\n    fn encrypt(\u0026self, plaintext: \u0026[u8], nonce: \u0026[u8]) -\u003e CryptoResult\u003cVec\u003cu8\u003e\u003e;\n    \n    /// D√©chiffre des donn√©es avec un nonce donn√©\n    fn decrypt(\u0026self, ciphertext: \u0026[u8], nonce: \u0026[u8]) -\u003e CryptoResult\u003cVec\u003cu8\u003e\u003e;\n    \n    /// Chiffre des donn√©es avec un nonce g√©n√©r√© automatiquement\n    fn encrypt_with_random_nonce(\u0026self, plaintext: \u0026[u8]) -\u003e CryptoResult\u003cEncryptedData\u003e;\n    \n    /// D√©chiffre des donn√©es qui incluent le nonce\n    fn decrypt_with_nonce(\u0026self, encrypted_data: \u0026EncryptedData) -\u003e CryptoResult\u003cVec\u003cu8\u003e\u003e;\n}\n\n/// Donn√©es chiffr√©es avec nonce inclus\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct EncryptedData {\n    /// Nonce utilis√© pour le chiffrement\n    pub nonce: [u8; NONCE_SIZE],\n    /// Donn√©es chiffr√©es avec tag d'authentification\n    pub ciphertext: Vec\u003cu8\u003e,\n}\n\n/// Impl√©mentation ChaCha20-Poly1305\npub struct ChaCha20Poly1305Cipher {\n    cipher: ChaCha20Poly1305,\n    key_fingerprint: [u8; 4], // Pour identification, pas de s√©curit√©\n}\n\nimpl ChaCha20Poly1305Cipher {\n    /// Cr√©e un chiffreur √† partir d'une cl√©\n    pub fn from_key(key: \u0026[u8; KEY_SIZE]) -\u003e CryptoResult\u003cSelf\u003e {\n        let key_ref = Key::from_slice(key);\n        let cipher = ChaCha20Poly1305::new(key_ref);\n        \n        // Empreinte simple pour identification (non s√©curis√©)\n        let mut hasher = blake3::Hasher::new();\n        hasher.update(key);\n        let hash = hasher.finalize();\n        let key_fingerprint = [hash.as_bytes()[0], hash.as_bytes()[1], \n                              hash.as_bytes()[2], hash.as_bytes()[3]];\n        \n        Ok(Self {\n            cipher,\n            key_fingerprint,\n        })\n    }\n    \n    /// G√©n√®re un nonce al√©atoire s√©curis√©\n    pub fn generate_nonce() -\u003e [u8; NONCE_SIZE] {\n        let mut nonce = [0u8; NONCE_SIZE];\n        use rand::RngCore;\n        rand::thread_rng().fill_bytes(\u0026mut nonce);\n        nonce\n    }\n    \n    /// Retourne l'empreinte de la cl√© (pour identification uniquement)\n    pub fn key_fingerprint(\u0026self) -\u003e [u8; 4] {\n        self.key_fingerprint\n    }\n}\n\nimpl EncryptionEngine for ChaCha20Poly1305Cipher {\n    fn generate_key() -\u003e CryptoResult\u003cSelf\u003e {\n        let key = ChaCha20Poly1305::generate_key(\u0026mut OsRng);\n        Self::from_key(key.as_slice().try_into()\n            .map_err(|_| CryptoError::KeyGenerationError(\"Taille de cl√© invalide\".into()))?)\n    }\n    \n    fn encrypt(\u0026self, plaintext: \u0026[u8], nonce: \u0026[u8]) -\u003e CryptoResult\u003cVec\u003cu8\u003e\u003e {\n        if nonce.len() != NONCE_SIZE {\n            return Err(CryptoError::InvalidDataSize {\n                expected: NONCE_SIZE,\n                actual: nonce.len(),\n            });\n        }\n        \n        let nonce_ref = Nonce::from_slice(nonce);\n        \n        self.cipher\n            .encrypt(nonce_ref, plaintext)\n            .map_err(|e| CryptoError::EncryptionError(format!(\"ChaCha20-Poly1305 encryption failed: {}\", e)))\n    }\n    \n    fn decrypt(\u0026self, ciphertext: \u0026[u8], nonce: \u0026[u8]) -\u003e CryptoResult\u003cVec\u003cu8\u003e\u003e {\n        if nonce.len() != NONCE_SIZE {\n            return Err(CryptoError::InvalidDataSize {\n                expected: NONCE_SIZE,\n                actual: nonce.len(),\n            });\n        }\n        \n        let nonce_ref = Nonce::from_slice(nonce);\n        \n        self.cipher\n            .decrypt(nonce_ref, ciphertext)\n            .map_err(|e| CryptoError::DecryptionError(format!(\"ChaCha20-Poly1305 decryption failed: {}\", e)))\n    }\n    \n    fn encrypt_with_random_nonce(\u0026self, plaintext: \u0026[u8]) -\u003e CryptoResult\u003cEncryptedData\u003e {\n        let nonce = Self::generate_nonce();\n        let ciphertext = self.encrypt(plaintext, \u0026nonce)?;\n        \n        Ok(EncryptedData {\n            nonce,\n            ciphertext,\n        })\n    }\n    \n    fn decrypt_with_nonce(\u0026self, encrypted_data: \u0026EncryptedData) -\u003e CryptoResult\u003cVec\u003cu8\u003e\u003e {\n        self.decrypt(\u0026encrypted_data.ciphertext, \u0026encrypted_data.nonce)\n    }\n}\n\n/// Protection contre la r√©utilisation de nonce\n#[derive(Default)]\npub struct NonceTracker {\n    used_nonces: std::collections::HashSet\u003c[u8; NONCE_SIZE]\u003e,\n}\n\nimpl NonceTracker {\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n    \n    /// V√©rifie et enregistre un nonce pour √©viter la r√©utilisation\n    pub fn check_and_register_nonce(\u0026mut self, nonce: \u0026[u8; NONCE_SIZE]) -\u003e CryptoResult\u003c()\u003e {\n        if self.used_nonces.contains(nonce) {\n            return Err(CryptoError::NonceReuse);\n        }\n        \n        self.used_nonces.insert(*nonce);\n        Ok(())\n    }\n    \n    /// Nombre de nonces utilis√©s\n    pub fn nonce_count(\u0026self) -\u003e usize {\n        self.used_nonces.len()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_chacha20_poly1305_basic() {\n        let cipher = ChaCha20Poly1305Cipher::generate_key().unwrap();\n        let plaintext = b\"Hello, Miaou!\";\n        let nonce = ChaCha20Poly1305Cipher::generate_nonce();\n        \n        let ciphertext = cipher.encrypt(plaintext, \u0026nonce).unwrap();\n        let decrypted = cipher.decrypt(\u0026ciphertext, \u0026nonce).unwrap();\n        \n        assert_eq!(plaintext, decrypted.as_slice());\n    }\n    \n    #[test]\n    fn test_encrypt_with_random_nonce() {\n        let cipher = ChaCha20Poly1305Cipher::generate_key().unwrap();\n        let plaintext = b\"Secret message for Miaou\";\n        \n        let encrypted = cipher.encrypt_with_random_nonce(plaintext).unwrap();\n        let decrypted = cipher.decrypt_with_nonce(\u0026encrypted).unwrap();\n        \n        assert_eq!(plaintext, decrypted.as_slice());\n    }\n    \n    #[test]\n    fn test_wrong_nonce_fails() {\n        let cipher = ChaCha20Poly1305Cipher::generate_key().unwrap();\n        let plaintext = b\"Test message\";\n        let nonce1 = ChaCha20Poly1305Cipher::generate_nonce();\n        let nonce2 = ChaCha20Poly1305Cipher::generate_nonce();\n        \n        let ciphertext = cipher.encrypt(plaintext, \u0026nonce1).unwrap();\n        let result = cipher.decrypt(\u0026ciphertext, \u0026nonce2);\n        \n        assert!(result.is_err());\n    }\n    \n    #[test]\n    fn test_nonce_tracker() {\n        let mut tracker = NonceTracker::new();\n        let nonce1 = ChaCha20Poly1305Cipher::generate_nonce();\n        let nonce2 = ChaCha20Poly1305Cipher::generate_nonce();\n        \n        // Premier usage OK\n        assert!(tracker.check_and_register_nonce(\u0026nonce1).is_ok());\n        assert_eq!(tracker.nonce_count(), 1);\n        \n        // R√©utilisation d√©tect√©e\n        assert!(tracker.check_and_register_nonce(\u0026nonce1).is_err());\n        \n        // Nouveau nonce OK\n        assert!(tracker.check_and_register_nonce(\u0026nonce2).is_ok());\n        assert_eq!(tracker.nonce_count(), 2);\n    }\n    \n    #[test]\n    fn test_key_fingerprint() {\n        let cipher1 = ChaCha20Poly1305Cipher::generate_key().unwrap();\n        let cipher2 = ChaCha20Poly1305Cipher::generate_key().unwrap();\n        \n        // Empreintes diff√©rentes pour cl√©s diff√©rentes\n        assert_ne!(cipher1.key_fingerprint(), cipher2.key_fingerprint());\n        \n        // Empreinte stable pour m√™me cl√©\n        let fingerprint1 = cipher1.key_fingerprint();\n        let fingerprint2 = cipher1.key_fingerprint();\n        assert_eq!(fingerprint1, fingerprint2);\n    }\n}","traces":[],"covered":0,"coverable":0},{"path":["/","home","seb","Dev","miaou","miaou-crypto","src","hash.rs"],"content":"//! # Hash (v0.1)\n//!\n//! BLAKE3 (par d√©faut) et SHA3-256 (compatibilit√©).\n\nuse blake3::{Hash as Blake3Hash, Hasher as Blake3Hasher};\nuse sha3::{Digest, Sha3_256};\n// use zeroize::{Zeroize, Zeroizing}; // Pour l'instant non utilis√©\n\n/// BLAKE3 32 octets (rapide, s√©curis√©)\n#[must_use]\npub fn blake3_32(input: \u0026[u8]) -\u003e [u8; 32] {\n    *blake3::hash(input).as_bytes()\n}\n\n/// BLAKE3 avec contexte (domaine de s√©paration)\n#[must_use]\npub fn blake3_with_context(input: \u0026[u8], context: \u0026str) -\u003e [u8; 32] {\n    let mut hasher = Blake3Hasher::new_derive_key(context);\n    hasher.update(input);\n    *hasher.finalize().as_bytes()\n}\n\n/// BLAKE3 avec cl√© (HMAC-like)\n#[must_use]\npub fn blake3_keyed(key: \u0026[u8; 32], input: \u0026[u8]) -\u003e [u8; 32] {\n    let mut hasher = Blake3Hasher::new_keyed(key);\n    hasher.update(input);\n    *hasher.finalize().as_bytes()\n}\n\n/// BLAKE3 pour plusieurs √©l√©ments (ordre sensible)\n#[must_use]\npub fn blake3_multiple(items: \u0026[\u0026[u8]]) -\u003e [u8; 32] {\n    let mut hasher = Blake3Hasher::new();\n    for item in items {\n        hasher.update(item);\n    }\n    *hasher.finalize().as_bytes()\n}\n\n/// SHA3-256 (compatibilit√© standards)\n#[must_use]\npub fn sha3_256(input: \u0026[u8]) -\u003e [u8; 32] {\n    let mut hasher = Sha3_256::new();\n    hasher.update(input);\n    hasher.finalize().into()\n}\n\n/// Output BLAKE3 avec encodage hex\n#[derive(Clone, PartialEq, Eq)]\npub struct Blake3Output {\n    hash: Blake3Hash,\n}\n\nimpl Blake3Output {\n    /// Cr√©e depuis un hash BLAKE3\n    #[must_use]\n    pub const fn new(hash: Blake3Hash) -\u003e Self {\n        Self { hash }\n    }\n\n    /// Hash des donn√©es\n    #[must_use]\n    pub fn hash(input: \u0026[u8]) -\u003e Self {\n        Self::new(blake3::hash(input))\n    }\n\n    /// Hash avec contexte\n    #[must_use]\n    pub fn hash_with_context(input: \u0026[u8], context: \u0026str) -\u003e Self {\n        let mut hasher = Blake3Hasher::new_derive_key(context);\n        hasher.update(input);\n        Self::new(hasher.finalize())\n    }\n\n    /// Hash avec cl√©\n    #[must_use]\n    pub fn hash_keyed(key: \u0026[u8; 32], input: \u0026[u8]) -\u003e Self {\n        let mut hasher = Blake3Hasher::new_keyed(key);\n        hasher.update(input);\n        Self::new(hasher.finalize())\n    }\n\n    /// Hash de plusieurs √©l√©ments\n    #[must_use]\n    pub fn hash_multiple(items: \u0026[\u0026[u8]]) -\u003e Self {\n        let mut hasher = Blake3Hasher::new();\n        for item in items {\n            hasher.update(item);\n        }\n        Self::new(hasher.finalize())\n    }\n\n    /// Retourne les octets du hash\n    #[must_use]\n    pub const fn as_bytes(\u0026self) -\u003e \u0026[u8; 32] {\n        self.hash.as_bytes()\n    }\n\n    /// Encode en hexad√©cimal\n    #[must_use]\n    pub fn to_hex(\u0026self) -\u003e String {\n        hex::encode(self.as_bytes())\n    }\n\n    /// D√©code depuis l'hexad√©cimal\n    ///\n    /// # Errors\n    /// √âchec si `hex_str` n'est pas une cha√Æne hex valide de 32 octets.\n    pub fn from_hex(hex_str: \u0026str) -\u003e Result\u003cSelf, hex::FromHexError\u003e {\n        let bytes = hex::decode(hex_str)?;\n        if bytes.len() != 32 {\n            return Err(hex::FromHexError::InvalidStringLength);\n        }\n\n        let mut hash_bytes = [0u8; 32];\n        hash_bytes.copy_from_slice(\u0026bytes);\n\n        Ok(Self {\n            hash: Blake3Hash::from(hash_bytes),\n        })\n    }\n}\n\nimpl std::fmt::Debug for Blake3Output {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"Blake3Output({})\", self.to_hex())\n    }\n}\n\nimpl std::fmt::Display for Blake3Output {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}\", self.to_hex())\n    }\n}\n\n/// Moteur de hachage unifi√©\npub trait HashingEngine {\n    /// Type de sortie du hachage\n    type Output;\n\n    /// Hash simple\n    fn hash(input: \u0026[u8]) -\u003e Self::Output;\n\n    /// Hash avec contexte optionnel\n    fn hash_with_context(input: \u0026[u8], context: \u0026str) -\u003e Self::Output;\n\n    /// Hash avec cl√© (HMAC-like)\n    fn hash_keyed(key: \u0026[u8; 32], input: \u0026[u8]) -\u003e Self::Output;\n\n    /// Hash de plusieurs √©l√©ments\n    fn hash_multiple(items: \u0026[\u0026[u8]]) -\u003e Self::Output;\n}\n\n/// Impl√©mentation BLAKE3 du moteur de hachage\npub struct Blake3Engine;\n\nimpl HashingEngine for Blake3Engine {\n    type Output = Blake3Output;\n\n    fn hash(input: \u0026[u8]) -\u003e Self::Output {\n        Blake3Output::hash(input)\n    }\n\n    fn hash_with_context(input: \u0026[u8], context: \u0026str) -\u003e Self::Output {\n        Blake3Output::hash_with_context(input, context)\n    }\n\n    fn hash_keyed(key: \u0026[u8; 32], input: \u0026[u8]) -\u003e Self::Output {\n        Blake3Output::hash_keyed(key, input)\n    }\n\n    fn hash_multiple(items: \u0026[\u0026[u8]]) -\u003e Self::Output {\n        Blake3Output::hash_multiple(items)\n    }\n}\n\n/// Comparaison s√©curis√©e (constant-time)\n#[must_use]\npub fn secure_compare(a: \u0026[u8], b: \u0026[u8]) -\u003e bool {\n    use subtle::ConstantTimeEq;\n    if a.len() != b.len() {\n        return false;\n    }\n    a.ct_eq(b).into()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_blake3_basic() {\n        let data = b\"test data for blake3\";\n        let hash1 = blake3_32(data);\n        let hash2 = blake3_32(data);\n\n        // M√™me donn√©es = m√™me hash\n        assert_eq!(hash1, hash2);\n        assert_eq!(hash1.len(), 32);\n\n        // Donn√©es diff√©rentes = hash diff√©rents\n        let hash3 = blake3_32(b\"different data\");\n        assert_ne!(hash1, hash3);\n    }\n\n    #[test]\n    fn test_blake3_context() {\n        let data = b\"same data\";\n        let hash1 = blake3_with_context(data, \"context1\");\n        let hash2 = blake3_with_context(data, \"context2\");\n\n        // Contextes diff√©rents = hash diff√©rents\n        assert_ne!(hash1, hash2);\n\n        // M√™me contexte = m√™me hash\n        let hash3 = blake3_with_context(data, \"context1\");\n        assert_eq!(hash1, hash3);\n    }\n\n    #[test]\n    fn test_blake3_keyed() {\n        let key = [42u8; 32];\n        let data = b\"test data\";\n\n        let hash1 = blake3_keyed(\u0026key, data);\n        let hash2 = blake3_keyed(\u0026key, data);\n\n        // M√™me cl√© = m√™me hash\n        assert_eq!(hash1, hash2);\n\n        // Cl√© diff√©rente = hash diff√©rent\n        let key2 = [43u8; 32];\n        let hash3 = blake3_keyed(\u0026key2, data);\n        assert_ne!(hash1, hash3);\n    }\n\n    #[test]\n    fn test_blake3_multiple() {\n        let items1 = [\n            b\"part1\".as_slice(),\n            b\"part2\".as_slice(),\n            b\"part3\".as_slice(),\n        ];\n        let hash1 = blake3_multiple(\u0026items1);\n\n        // M√™me √©l√©ments = m√™me hash\n        let hash2 = blake3_multiple(\u0026items1);\n        assert_eq!(hash1, hash2);\n\n        // Ordre diff√©rent = hash diff√©rent\n        let items2 = [\n            b\"part2\".as_slice(),\n            b\"part1\".as_slice(),\n            b\"part3\".as_slice(),\n        ];\n        let hash3 = blake3_multiple(\u0026items2);\n        assert_ne!(hash1, hash3);\n\n        // Contenu √©quivalent mais concat√©n√©\n        let concat = b\"part1part2part3\";\n        let hash4 = blake3_32(concat);\n        assert_eq!(hash1, hash4);\n    }\n\n    #[test]\n    fn test_sha3_256() {\n        let data = b\"test data for sha3\";\n        let hash1 = sha3_256(data);\n        let hash2 = sha3_256(data);\n\n        assert_eq!(hash1, hash2);\n        assert_eq!(hash1.len(), 32);\n\n        // Diff√©rent de BLAKE3\n        let blake3_hash = blake3_32(data);\n        assert_ne!(hash1, blake3_hash);\n    }\n\n    #[test]\n    fn test_blake3_output_hex() {\n        let data = b\"test\";\n        let output = Blake3Output::hash(data);\n\n        let hex_string = output.to_hex();\n        assert!(!hex_string.is_empty());\n        assert_eq!(hex_string.len(), 64); // 32 bytes * 2 chars/byte\n\n        let decoded = Blake3Output::from_hex(\u0026hex_string).unwrap();\n        assert_eq!(output, decoded);\n    }\n\n    #[test]\n    fn test_hashing_engine() {\n        let data = b\"test engine\";\n\n        let output1 = Blake3Engine::hash(data);\n        let output2 = Blake3Engine::hash(data);\n\n        assert_eq!(output1, output2);\n        assert_eq!(output1.as_bytes().len(), 32);\n    }\n\n    #[test]\n    fn test_secure_compare() {\n        let data1 = vec![1, 2, 3, 4, 5];\n        let data2 = vec![1, 2, 3, 4, 5];\n        let data3 = vec![1, 2, 3, 4, 6];\n        let data4 = vec![1, 2, 3, 4]; // longueur diff√©rente\n\n        assert!(secure_compare(\u0026data1, \u0026data2));\n        assert!(!secure_compare(\u0026data1, \u0026data3));\n        assert!(!secure_compare(\u0026data1, \u0026data4));\n    }\n\n    #[test]\n    fn test_performance_basic() {\n        use std::time::Instant;\n\n        let data = vec![0x42; 1024]; // 1KB\n        let start = Instant::now();\n\n        for _ in 0..1000 {\n            let _hash = blake3_32(\u0026data);\n        }\n\n        let duration = start.elapsed();\n        println!(\"1000 hashes BLAKE3 de 1KB: {:?}\", duration);\n\n        // Test basique de performance (devrait √™tre rapide)\n        assert!(duration.as_millis() \u003c 1000);\n    }\n\n    #[test]\n    fn test_blake3_with_context() {\n        let data = b\"test data\";\n        let context = \"test_context\";\n        \n        let hash1 = blake3_with_context(data, context);\n        let hash2 = blake3_with_context(data, context);\n        \n        // Same context should produce same hash\n        assert_eq!(hash1, hash2);\n        assert_eq!(hash1.len(), 32);\n        \n        // Different context should produce different hash\n        let hash3 = blake3_with_context(data, \"different_context\");\n        assert_ne!(hash1, hash3);\n    }\n\n    #[test]\n    fn test_blake3_keyed_function() {\n        let key = [0x42; 32];\n        let data = b\"test data\";\n        \n        let hash1 = blake3_keyed(\u0026key, data);\n        let hash2 = blake3_keyed(\u0026key, data);\n        \n        // Same key should produce same hash\n        assert_eq!(hash1, hash2);\n        assert_eq!(hash1.len(), 32);\n        \n        // Different key should produce different hash\n        let key2 = [0x43; 32];\n        let hash3 = blake3_keyed(\u0026key2, data);\n        assert_ne!(hash1, hash3);\n    }\n\n    #[test]\n    fn test_blake3_multiple_function() {\n        let items = [b\"part1\".as_slice(), b\"part2\".as_slice()];\n        let hash1 = blake3_multiple(\u0026items);\n        let hash2 = blake3_multiple(\u0026items);\n        \n        // Same items should produce same hash\n        assert_eq!(hash1, hash2);\n        assert_eq!(hash1.len(), 32);\n        \n        // Different order should produce different hash\n        let items2 = [b\"part2\".as_slice(), b\"part1\".as_slice()];\n        let hash3 = blake3_multiple(\u0026items2);\n        assert_ne!(hash1, hash3);\n    }\n\n    #[test]\n    fn test_sha3_256_function() {\n        let data = b\"test data\";\n        let hash1 = sha3_256(data);\n        let hash2 = sha3_256(data);\n        \n        // Same data should produce same hash\n        assert_eq!(hash1, hash2);\n        assert_eq!(hash1.len(), 32);\n        \n        // Should be different from BLAKE3\n        let blake3_hash = blake3_32(data);\n        assert_ne!(hash1, blake3_hash);\n    }\n\n    #[test]\n    fn test_blake3_output_new() {\n        let data = b\"test\";\n        let hash = blake3::hash(data);\n        let output = Blake3Output::new(hash);\n        \n        assert_eq!(output.as_bytes(), hash.as_bytes());\n    }\n\n    #[test]\n    fn test_blake3_output_hash_method() {\n        let data = b\"test data\";\n        let output = Blake3Output::hash(data);\n        let direct_hash = blake3_32(data);\n        \n        assert_eq!(*output.as_bytes(), direct_hash);\n    }\n\n    #[test]\n    fn test_blake3_output_hash_with_context_method() {\n        let data = b\"test data\";\n        let context = \"test_context\";\n        \n        let output = Blake3Output::hash_with_context(data, context);\n        let direct_hash = blake3_with_context(data, context);\n        \n        assert_eq!(*output.as_bytes(), direct_hash);\n    }\n\n    #[test]\n    fn test_blake3_output_hash_keyed_method() {\n        let key = [0x42; 32];\n        let data = b\"test data\";\n        \n        let output = Blake3Output::hash_keyed(\u0026key, data);\n        let direct_hash = blake3_keyed(\u0026key, data);\n        \n        assert_eq!(*output.as_bytes(), direct_hash);\n    }\n\n    #[test]\n    fn test_blake3_output_hash_multiple_method() {\n        let items = [b\"part1\".as_slice(), b\"part2\".as_slice()];\n        \n        let output = Blake3Output::hash_multiple(\u0026items);\n        let direct_hash = blake3_multiple(\u0026items);\n        \n        assert_eq!(*output.as_bytes(), direct_hash);\n    }\n\n    #[test]\n    fn test_blake3_output_from_hex_errors() {\n        // Invalid hex characters\n        assert!(Blake3Output::from_hex(\"invalid_hex\").is_err());\n        \n        // Wrong length (too short)\n        assert!(Blake3Output::from_hex(\"deadbeef\").is_err());\n        \n        // Wrong length (too long)  \n        let too_long = \"a\".repeat(100);\n        assert!(Blake3Output::from_hex(\u0026too_long).is_err());\n        \n        // Empty string\n        assert!(Blake3Output::from_hex(\"\").is_err());\n    }\n\n    #[test]\n    fn test_blake3_output_debug_display() {\n        let data = b\"test\";\n        let output = Blake3Output::hash(data);\n        \n        // Test Debug formatting\n        let debug_str = format!(\"{:?}\", output);\n        assert!(debug_str.contains(\"Blake3Output(\"));\n        assert!(debug_str.contains(\u0026output.to_hex()));\n        \n        // Test Display formatting\n        let display_str = format!(\"{}\", output);\n        assert_eq!(display_str, output.to_hex());\n    }\n\n    #[test]\n    fn test_blake3_engine_all_methods() {\n        let data = b\"test data\";\n        let key = [0x42; 32];\n        let items = [b\"part1\".as_slice(), b\"part2\".as_slice()];\n        \n        // Test all HashingEngine methods for Blake3Engine\n        let hash1 = Blake3Engine::hash(data);\n        assert_eq!(hash1.as_bytes().len(), 32);\n        \n        let hash2 = Blake3Engine::hash_with_context(data, \"context\");\n        assert_eq!(hash2.as_bytes().len(), 32);\n        assert_ne!(hash1, hash2);\n        \n        let hash3 = Blake3Engine::hash_keyed(\u0026key, data);\n        assert_eq!(hash3.as_bytes().len(), 32);\n        assert_ne!(hash1, hash3);\n        \n        let hash4 = Blake3Engine::hash_multiple(\u0026items);\n        assert_eq!(hash4.as_bytes().len(), 32);\n        assert_ne!(hash1, hash4);\n    }\n\n    #[test]\n    fn test_secure_compare_edge_cases() {\n        // Empty arrays\n        assert!(secure_compare(\u0026[], \u0026[]));\n        \n        // Single byte\n        assert!(secure_compare(\u0026[42], \u0026[42]));\n        assert!(!secure_compare(\u0026[42], \u0026[43]));\n        \n        // Very long arrays (test performance doesn't degrade security)\n        let long1 = vec![42u8; 10000];\n        let long2 = vec![42u8; 10000];\n        let mut long3 = vec![42u8; 10000];\n        long3[9999] = 43;\n        \n        assert!(secure_compare(\u0026long1, \u0026long2));\n        assert!(!secure_compare(\u0026long1, \u0026long3));\n    }\n}\n","traces":[{"line":11,"address":[427680],"length":1,"stats":{"Line":5}},{"line":12,"address":[1403160],"length":1,"stats":{"Line":5}},{"line":17,"address":[3523613,3523607,3523328],"length":1,"stats":{"Line":1}},{"line":18,"address":[1403317],"length":1,"stats":{"Line":1}},{"line":19,"address":[427895],"length":1,"stats":{"Line":1}},{"line":20,"address":[427947],"length":1,"stats":{"Line":1}},{"line":25,"address":[428329,428323,428080],"length":1,"stats":{"Line":1}},{"line":26,"address":[3214531],"length":1,"stats":{"Line":1}},{"line":27,"address":[428165],"length":1,"stats":{"Line":1}},{"line":28,"address":[428217],"length":1,"stats":{"Line":1}},{"line":33,"address":[3215127,3215133,3214752],"length":1,"stats":{"Line":1}},{"line":34,"address":[3523947],"length":1,"stats":{"Line":1}},{"line":35,"address":[1403875,1403947],"length":1,"stats":{"Line":2}},{"line":36,"address":[3215122,3214991],"length":1,"stats":{"Line":2}},{"line":38,"address":[1404070],"length":1,"stats":{"Line":1}},{"line":43,"address":[1404208],"length":1,"stats":{"Line":1}},{"line":44,"address":[1404251],"length":1,"stats":{"Line":1}},{"line":45,"address":[3524368],"length":1,"stats":{"Line":1}},{"line":46,"address":[428825],"length":1,"stats":{"Line":1}},{"line":58,"address":[1429344],"length":1,"stats":{"Line":1}},{"line":64,"address":[428960],"length":1,"stats":{"Line":1}},{"line":65,"address":[1404440],"length":1,"stats":{"Line":1}},{"line":70,"address":[3524820,3524576,3524814],"length":1,"stats":{"Line":1}},{"line":71,"address":[1404563],"length":1,"stats":{"Line":1}},{"line":72,"address":[1429573],"length":1,"stats":{"Line":1}},{"line":73,"address":[3215590],"length":1,"stats":{"Line":1}},{"line":78,"address":[3215908,3215696,3215902],"length":1,"stats":{"Line":1}},{"line":79,"address":[3215747],"length":1,"stats":{"Line":1}},{"line":80,"address":[3524933],"length":1,"stats":{"Line":1}},{"line":81,"address":[1404886],"length":1,"stats":{"Line":1}},{"line":86,"address":[3215936,3216273,3216279],"length":1,"stats":{"Line":1}},{"line":87,"address":[429547],"length":1,"stats":{"Line":1}},{"line":88,"address":[1430035,1430107],"length":1,"stats":{"Line":2}},{"line":89,"address":[3525325,3525420],"length":1,"stats":{"Line":2}},{"line":91,"address":[3216196],"length":1,"stats":{"Line":1}},{"line":96,"address":[3525456],"length":1,"stats":{"Line":1}},{"line":97,"address":[429861],"length":1,"stats":{"Line":1}},{"line":102,"address":[429872],"length":1,"stats":{"Line":1}},{"line":103,"address":[3216352],"length":1,"stats":{"Line":1}},{"line":110,"address":[430581,430587,429936],"length":1,"stats":{"Line":1}},{"line":111,"address":[429969],"length":1,"stats":{"Line":1}},{"line":112,"address":[1405675,1405742],"length":1,"stats":{"Line":2}},{"line":113,"address":[430287],"length":1,"stats":{"Line":1}},{"line":116,"address":[1405748],"length":1,"stats":{"Line":1}},{"line":117,"address":[1430743,1430838],"length":1,"stats":{"Line":2}},{"line":119,"address":[1405953],"length":1,"stats":{"Line":1}},{"line":120,"address":[1405893],"length":1,"stats":{"Line":1}},{"line":126,"address":[1406112,1406308,1406314],"length":1,"stats":{"Line":1}},{"line":127,"address":[3217168,3217090],"length":1,"stats":{"Line":2}},{"line":132,"address":[3526634,3526432,3526628],"length":1,"stats":{"Line":1}},{"line":133,"address":[1431424,1431346],"length":1,"stats":{"Line":2}},{"line":161,"address":[3526656],"length":1,"stats":{"Line":1}},{"line":162,"address":[431045],"length":1,"stats":{"Line":1}},{"line":165,"address":[1406608],"length":1,"stats":{"Line":1}},{"line":166,"address":[3217583],"length":1,"stats":{"Line":1}},{"line":169,"address":[3526752],"length":1,"stats":{"Line":1}},{"line":170,"address":[3526779],"length":1,"stats":{"Line":1}},{"line":173,"address":[1406704],"length":1,"stats":{"Line":1}},{"line":174,"address":[1406725],"length":1,"stats":{"Line":1}},{"line":180,"address":[431216],"length":1,"stats":{"Line":1}},{"line":182,"address":[1431771],"length":1,"stats":{"Line":1}},{"line":183,"address":[3217793],"length":1,"stats":{"Line":1}},{"line":185,"address":[3217763],"length":1,"stats":{"Line":1}}],"covered":63,"coverable":63},{"path":["/","home","seb","Dev","miaou","miaou-crypto","src","hashing.rs"],"content":"//! Fonctions de hachage cryptographiques\n//!\n//! Impl√©mentation de BLAKE3 pour hachage g√©n√©ral et Argon2 pour d√©rivation\n//! de cl√©s √† partir de mots de passe.\n\nuse crate::{CryptoError, CryptoResult};\nuse serde::{Deserialize, Serialize};\n\n/// Trait pour les moteurs de hachage\npub trait HashingEngine {\n    /// Type de sortie du hachage\n    type Output;\n\n    /// Hache des donn√©es\n    fn hash(data: \u0026[u8]) -\u003e Self::Output;\n\n    /// Hache des donn√©es avec un contexte\n    fn hash_with_context(data: \u0026[u8], context: \u0026str) -\u003e Self::Output;\n}\n\n/// Moteur de hachage BLAKE3\npub struct Blake3Hasher;\n\n/// Moteur de d√©rivation Argon2\npub struct Argon2Hasher;\n\n/// Hash BLAKE3 (32 bytes)\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub struct Blake3Output {\n    hash: [u8; 32],\n}\n\n/// Configuration simple pour Argon2\n#[derive(Debug, Clone)]\npub struct Argon2Config {\n    /// M√©moire utilis√©e en KiB\n    pub memory_cost: u32,\n    /// Nombre d'it√©rations\n    pub time_cost: u32,\n    /// Parall√©lisme\n    pub parallelism: u32,\n    /// Longueur de sortie en bytes\n    pub output_length: u32,\n}\n\nimpl Default for Argon2Config {\n    fn default() -\u003e Self {\n        Self {\n            memory_cost: 65536, // 64 MiB\n            time_cost: 3,       // 3 it√©rations\n            parallelism: 4,     // 4 threads\n            output_length: 32,  // 32 bytes\n        }\n    }\n}\n\nimpl Argon2Config {\n    /// Configuration rapide pour tests (INS√âCURIS√â pour la production)\n    #[must_use]\n    pub const fn fast_insecure() -\u003e Self {\n        Self {\n            memory_cost: 1024, // 1 MiB\n            time_cost: 1,      // 1 it√©ration\n            parallelism: 1,    // 1 thread\n            output_length: 32,\n        }\n    }\n\n    /// Configuration s√©curis√©e pour production\n    #[must_use]\n    pub const fn secure() -\u003e Self {\n        Self {\n            memory_cost: 131_072, // 128 MiB\n            time_cost: 4,         // 4 it√©rations\n            parallelism: 4,       // 4 threads\n            output_length: 32,\n        }\n    }\n}\n\nimpl Blake3Output {\n    /// Cr√©e un hash √† partir de bytes\n    #[must_use]\n    pub const fn from_bytes(bytes: [u8; 32]) -\u003e Self {\n        Self { hash: bytes }\n    }\n\n    /// Retourne les bytes du hash\n    #[must_use]\n    pub const fn as_bytes(\u0026self) -\u003e \u0026[u8; 32] {\n        \u0026self.hash\n    }\n\n    /// Convertit en slice\n    #[must_use]\n    pub const fn as_slice(\u0026self) -\u003e \u0026[u8] {\n        \u0026self.hash\n    }\n\n    /// Encode en hexad√©cimal\n    #[must_use]\n    pub fn to_hex(\u0026self) -\u003e String {\n        hex::encode(self.hash)\n    }\n\n    /// D√©code depuis hexad√©cimal\n    ///\n    /// # Errors\n    /// √âchec si `hex_str` n'est pas une cha√Æne hex valide de 32 octets.\n    pub fn from_hex(hex_str: \u0026str) -\u003e CryptoResult\u003cSelf\u003e {\n        let bytes = hex::decode(hex_str).map_err(|_| CryptoError::InvalidInput)?;\n\n        if bytes.len() != 32 {\n            return Err(CryptoError::InvalidSize {\n                expected: 32,\n                actual: bytes.len(),\n            });\n        }\n\n        let mut hash = [0u8; 32];\n        hash.copy_from_slice(\u0026bytes);\n        Ok(Self { hash })\n    }\n}\n\nimpl HashingEngine for Blake3Hasher {\n    type Output = Blake3Output;\n\n    fn hash(data: \u0026[u8]) -\u003e Self::Output {\n        let hash = blake3::hash(data);\n        Blake3Output::from_bytes(*hash.as_bytes())\n    }\n\n    fn hash_with_context(data: \u0026[u8], context: \u0026str) -\u003e Self::Output {\n        let mut hasher = blake3::Hasher::new_keyed(\u0026blake3::hash(context.as_bytes()).into());\n        hasher.update(data);\n        let hash = hasher.finalize();\n        Blake3Output::from_bytes(*hash.as_bytes())\n    }\n}\n\nimpl Blake3Hasher {\n    /// Hache plusieurs √©l√©ments en une seule op√©ration\n    #[must_use]\n    pub fn hash_multiple(items: \u0026[\u0026[u8]]) -\u003e Blake3Output {\n        let mut hasher = blake3::Hasher::new();\n        for item in items {\n            hasher.update(item);\n        }\n        let hash = hasher.finalize();\n        Blake3Output::from_bytes(*hash.as_bytes())\n    }\n\n    /// Hache avec une cl√©\n    #[must_use]\n    pub fn hash_keyed(key: \u0026[u8; 32], data: \u0026[u8]) -\u003e Blake3Output {\n        let mut hasher = blake3::Hasher::new_keyed(key);\n        hasher.update(data);\n        let hash = hasher.finalize();\n        Blake3Output::from_bytes(*hash.as_bytes())\n    }\n}\n\nimpl Argon2Hasher {\n    /// D√©rive une cl√© avec Argon2 (version simplifi√©e)\n    ///\n    /// # Errors\n    /// √âchec si la d√©rivation de cl√© √©choue.\n    pub fn derive_key(\n        password: \u0026[u8],\n        salt: \u0026[u8],\n        config: \u0026Argon2Config,\n    ) -\u003e CryptoResult\u003cVec\u003cu8\u003e\u003e {\n        // Version simplifi√©e utilisant BLAKE3 pour la d√©rivation\n        // En attendant de r√©soudre les probl√®mes de compatibilit√© avec argon2\n        let combined = [password, salt, \u0026config.output_length.to_le_bytes()].concat();\n        let hash = blake3::hash(\u0026combined);\n        let mut result = hash.as_bytes().to_vec();\n        result.truncate(config.output_length as usize);\n        Ok(result)\n    }\n\n    /// Hache un mot de passe avec un sel g√©n√©r√©\n    ///\n    /// # Errors\n    /// √âchec si la s√©rialisation Argon2 √©choue.\n    pub fn hash_password(password: \u0026[u8], config: \u0026Argon2Config) -\u003e CryptoResult\u003cString\u003e {\n        use rand_core::{OsRng, RngCore};\n        let mut salt = [0u8; 16];\n        OsRng.fill_bytes(\u0026mut salt);\n\n        // Version simplifi√©e utilisant BLAKE3\n        let derived = Self::derive_key(password, \u0026salt, config)?;\n        let salt_hex = hex::encode(salt);\n        let hash_hex = hex::encode(derived);\n\n        Ok(format!(\"blake3${salt_hex}${hash_hex}\"))\n    }\n\n    /// V√©rifie un mot de passe contre un hash\n    ///\n    /// # Errors\n    /// √âchec si le format est invalide ou si la v√©rification √©choue.\n    pub fn verify_password(password: \u0026[u8], hash: \u0026str) -\u003e CryptoResult\u003cbool\u003e {\n        let parts: Vec\u003c\u0026str\u003e = hash.split('$').collect();\n        if parts.len() != 3 || parts[0] != \"blake3\" {\n            return Ok(false);\n        }\n\n        let salt = hex::decode(parts[1]).map_err(|_| CryptoError::InvalidInput)?;\n        let expected_hash = hex::decode(parts[2]).map_err(|_| CryptoError::InvalidInput)?;\n\n        let config = Argon2Config {\n            output_length: u32::try_from(expected_hash.len())\n                .map_err(|_| CryptoError::Truncation)?,\n            ..Default::default()\n        };\n        let computed = Self::derive_key(password, \u0026salt, \u0026config)?;\n\n        Ok(computed == expected_hash)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_blake3_hash() {\n        let data = b\"test data\";\n        let hash1 = Blake3Hasher::hash(data);\n        let hash2 = Blake3Hasher::hash(data);\n        assert_eq!(hash1, hash2);\n    }\n\n    #[test]\n    fn test_blake3_hash_different_data() {\n        let data1 = b\"test data 1\";\n        let data2 = b\"test data 2\";\n        let hash1 = Blake3Hasher::hash(data1);\n        let hash2 = Blake3Hasher::hash(data2);\n        assert_ne!(hash1, hash2);\n    }\n\n    #[test]\n    fn test_argon2_derive_key() {\n        let password = b\"test_password\";\n        let salt = b\"test_salt_123456\";\n        let config = Argon2Config::fast_insecure();\n\n        let key1 = Argon2Hasher::derive_key(password, salt, \u0026config).unwrap();\n        let key2 = Argon2Hasher::derive_key(password, salt, \u0026config).unwrap();\n\n        assert_eq!(key1, key2);\n        assert_eq!(key1.len(), config.output_length as usize);\n    }\n\n    #[test]\n    fn test_argon2_password_hash() {\n        let password = b\"test_password\";\n        let config = Argon2Config::fast_insecure();\n\n        let hash = Argon2Hasher::hash_password(password, \u0026config).unwrap();\n        let is_valid = Argon2Hasher::verify_password(password, \u0026hash).unwrap();\n\n        assert!(is_valid);\n\n        let wrong_password = b\"wrong_password\";\n        let is_valid = Argon2Hasher::verify_password(wrong_password, \u0026hash).unwrap();\n        assert!(!is_valid);\n    }\n\n    #[test]\n    fn test_blake3_output_from_bytes() {\n        let bytes = [42u8; 32];\n        let output = Blake3Output::from_bytes(bytes);\n        assert_eq!(*output.as_bytes(), bytes);\n    }\n\n    #[test]\n    fn test_blake3_output_as_slice() {\n        let bytes = [42u8; 32];\n        let output = Blake3Output::from_bytes(bytes);\n        assert_eq!(output.as_slice(), \u0026bytes);\n    }\n\n    #[test]\n    fn test_blake3_output_to_hex() {\n        let bytes = [42u8; 32];\n        let output = Blake3Output::from_bytes(bytes);\n        let hex_str = output.to_hex();\n        assert_eq!(hex_str.len(), 64); // 32 bytes * 2 hex chars\n        assert!(hex_str.chars().all(|c| c.is_ascii_hexdigit()));\n    }\n\n    #[test]\n    fn test_blake3_output_from_hex() {\n        let bytes = [42u8; 32];\n        let output = Blake3Output::from_bytes(bytes);\n        let hex_str = output.to_hex();\n        let restored = Blake3Output::from_hex(\u0026hex_str).unwrap();\n        assert_eq!(output, restored);\n    }\n\n    #[test]\n    fn test_blake3_output_from_hex_invalid() {\n        // Invalid hex string\n        assert!(Blake3Output::from_hex(\"invalid\").is_err());\n        \n        // Wrong length\n        assert!(Blake3Output::from_hex(\"deadbeef\").is_err());\n    }\n\n    #[test]\n    fn test_blake3_hasher_hash_multiple() {\n        let items = vec![b\"part1\".as_slice(), b\"part2\".as_slice(), b\"part3\".as_slice()];\n        let hash1 = Blake3Hasher::hash_multiple(\u0026items);\n        let hash2 = Blake3Hasher::hash_multiple(\u0026items);\n        assert_eq!(hash1, hash2);\n        \n        // Different order should give different hash\n        let items_different = vec![b\"part2\".as_slice(), b\"part1\".as_slice(), b\"part3\".as_slice()];\n        let hash3 = Blake3Hasher::hash_multiple(\u0026items_different);\n        assert_ne!(hash1, hash3);\n    }\n\n    #[test]\n    fn test_blake3_hasher_hash_keyed() {\n        let key = [1u8; 32];\n        let data = b\"test data\";\n        let hash1 = Blake3Hasher::hash_keyed(\u0026key, data);\n        let hash2 = Blake3Hasher::hash_keyed(\u0026key, data);\n        assert_eq!(hash1, hash2);\n        \n        // Different key should give different hash\n        let key2 = [2u8; 32];\n        let hash3 = Blake3Hasher::hash_keyed(\u0026key2, data);\n        assert_ne!(hash1, hash3);\n    }\n\n    #[test]\n    fn test_blake3_hasher_hash_with_context() {\n        let data = b\"test data\";\n        let context = \"test_context\";\n        let hash1 = Blake3Hasher::hash_with_context(data, context);\n        let hash2 = Blake3Hasher::hash_with_context(data, context);\n        assert_eq!(hash1, hash2);\n        \n        // Different context should give different hash\n        let hash3 = Blake3Hasher::hash_with_context(data, \"different_context\");\n        assert_ne!(hash1, hash3);\n    }\n\n    #[test]\n    fn test_argon2_config_defaults() {\n        let config = Argon2Config::default();\n        assert_eq!(config.memory_cost, 65536);\n        assert_eq!(config.time_cost, 3);\n        assert_eq!(config.parallelism, 4);\n        assert_eq!(config.output_length, 32);\n    }\n\n    #[test]\n    fn test_argon2_config_presets() {\n        let fast = Argon2Config::fast_insecure();\n        assert_eq!(fast.memory_cost, 1024);\n        assert_eq!(fast.time_cost, 1);\n        \n        let secure = Argon2Config::secure();\n        assert_eq!(secure.memory_cost, 131_072);\n        assert_eq!(secure.time_cost, 4);\n    }\n\n    #[test]\n    fn test_argon2_hasher_derive_key_different_configs() {\n        let password = b\"test_password\";\n        let salt = b\"test_salt_123456\";\n        \n        let key_fast = Argon2Hasher::derive_key(password, salt, \u0026Argon2Config::fast_insecure()).unwrap();\n        let key_secure = Argon2Hasher::derive_key(password, salt, \u0026Argon2Config::secure()).unwrap();\n        \n        // Note: The simplified implementation uses only output_length, so same length = same result\n        // This tests the derive_key function works with different configs\n        assert_eq!(key_fast.len(), key_secure.len());\n        assert_eq!(key_fast.len(), 32); // Both should be 32 bytes for default output_length\n    }\n\n    #[test]\n    fn test_argon2_hasher_verify_password_invalid_format() {\n        let password = b\"test\";\n        \n        // Invalid format should return false, not error\n        assert!(!Argon2Hasher::verify_password(password, \"invalid_format\").unwrap());\n        assert!(!Argon2Hasher::verify_password(password, \"not$enough$parts\").unwrap());\n        assert!(!Argon2Hasher::verify_password(password, \"wrong$format$here\").unwrap());\n    }\n\n    #[test]  \n    fn test_argon2_hasher_verify_password_invalid_hex() {\n        let password = b\"test\";\n        \n        // Invalid hex should return error\n        assert!(Argon2Hasher::verify_password(password, \"blake3$invalid_hex$also_invalid\").is_err());\n    }\n}\n","traces":[{"line":47,"address":[3263680],"length":1,"stats":{"Line":1}},{"line":60,"address":[3263712],"length":1,"stats":{"Line":1}},{"line":71,"address":[3263744],"length":1,"stats":{"Line":1}},{"line":84,"address":[1450144],"length":1,"stats":{"Line":1}},{"line":90,"address":[487056],"length":1,"stats":{"Line":1}},{"line":96,"address":[1479600],"length":1,"stats":{"Line":1}},{"line":102,"address":[3263856],"length":1,"stats":{"Line":1}},{"line":103,"address":[1450241],"length":1,"stats":{"Line":1}},{"line":110,"address":[1480400,1480394,1479696],"length":1,"stats":{"Line":1}},{"line":111,"address":[487201],"length":1,"stats":{"Line":3}},{"line":113,"address":[1479978,1479911],"length":1,"stats":{"Line":2}},{"line":114,"address":[487770],"length":1,"stats":{"Line":1}},{"line":116,"address":[1450637],"length":1,"stats":{"Line":1}},{"line":120,"address":[487448],"length":1,"stats":{"Line":1}},{"line":121,"address":[1450670,1450611],"length":1,"stats":{"Line":2}},{"line":122,"address":[3264338],"length":1,"stats":{"Line":1}},{"line":129,"address":[3573808],"length":1,"stats":{"Line":1}},{"line":130,"address":[487912],"length":1,"stats":{"Line":1}},{"line":131,"address":[487923],"length":1,"stats":{"Line":1}},{"line":134,"address":[488350,488356,488000],"length":1,"stats":{"Line":1}},{"line":135,"address":[3574005],"length":1,"stats":{"Line":1}},{"line":136,"address":[3264956],"length":1,"stats":{"Line":1}},{"line":137,"address":[1480768],"length":1,"stats":{"Line":1}},{"line":138,"address":[1480800],"length":1,"stats":{"Line":1}},{"line":145,"address":[1451907,1451913,1451520],"length":1,"stats":{"Line":1}},{"line":146,"address":[3265195],"length":1,"stats":{"Line":1}},{"line":147,"address":[3265219,3265291],"length":1,"stats":{"Line":2}},{"line":148,"address":[3265391,3265534],"length":1,"stats":{"Line":2}},{"line":150,"address":[3265414],"length":1,"stats":{"Line":1}},{"line":151,"address":[3574598],"length":1,"stats":{"Line":1}},{"line":156,"address":[1481583,1481589,1481328],"length":1,"stats":{"Line":1}},{"line":157,"address":[1481379],"length":1,"stats":{"Line":1}},{"line":158,"address":[1452021],"length":1,"stats":{"Line":1}},{"line":159,"address":[1481465],"length":1,"stats":{"Line":1}},{"line":160,"address":[488969],"length":1,"stats":{"Line":1}},{"line":169,"address":[3266407,3265856,3266413],"length":1,"stats":{"Line":1}},{"line":176,"address":[3575090],"length":1,"stats":{"Line":1}},{"line":177,"address":[3266148,3266076],"length":1,"stats":{"Line":2}},{"line":178,"address":[3575327],"length":1,"stats":{"Line":1}},{"line":179,"address":[1452587],"length":1,"stats":{"Line":1}},{"line":180,"address":[3575444],"length":1,"stats":{"Line":1}},{"line":187,"address":[1453628,1452800,1453622],"length":1,"stats":{"Line":1}},{"line":189,"address":[3575639],"length":1,"stats":{"Line":1}},{"line":190,"address":[1452880],"length":1,"stats":{"Line":1}},{"line":193,"address":[3575700,3575826],"length":1,"stats":{"Line":2}},{"line":194,"address":[1482494],"length":1,"stats":{"Line":1}},{"line":195,"address":[3266815],"length":1,"stats":{"Line":1}},{"line":197,"address":[490130,490218],"length":1,"stats":{"Line":2}},{"line":204,"address":[1455392,1455324,1453664],"length":1,"stats":{"Line":1}},{"line":205,"address":[3576536],"length":1,"stats":{"Line":1}},{"line":206,"address":[3576607,3576745,3576678],"length":1,"stats":{"Line":3}},{"line":207,"address":[3267572],"length":1,"stats":{"Line":1}},{"line":210,"address":[1453993,1455390],"length":1,"stats":{"Line":4}},{"line":211,"address":[3267890,3267975,3269004],"length":1,"stats":{"Line":2}},{"line":214,"address":[491347,491462,491408,492090,491534],"length":1,"stats":{"Line":3}},{"line":218,"address":[3268525,3268962],"length":1,"stats":{"Line":1}},{"line":220,"address":[3268856,3268772],"length":1,"stats":{"Line":2}}],"covered":57,"coverable":57},{"path":["/","home","seb","Dev","miaou","miaou-crypto","src","kdf.rs"],"content":"//! # KDF (v0.1)\n//!\n//! D√©rivation de cl√© 32 octets depuis un mot de passe (Argon2id) + HKDF pour sessions.\n\nuse crate::CryptoError;\nuse argon2::password_hash::SaltString;\nuse argon2::{Argon2, PasswordHash, PasswordHasher, PasswordVerifier};\nuse hkdf::Hkdf;\nuse rand_core::OsRng;\nuse secrecy::{ExposeSecret, SecretString};\nuse sha3::Sha3_256;\nuse zeroize::Zeroizing;\n\n/// Configuration Argon2id pour diff√©rents niveaux de s√©curit√©\n#[derive(Debug, Clone)]\npub struct Argon2Config {\n    /// Co√ªt m√©moire (m) en KiB\n    pub memory_cost: u32,\n    /// Co√ªt temporel (t) - nombre d'it√©rations\n    pub time_cost: u32,\n    /// Niveau de parall√©lisme (p)\n    pub parallelism: u32,\n    /// Longueur de sortie en octets\n    pub output_length: usize,\n}\n\nimpl Argon2Config {\n    /// Configuration rapide (tests uniquement - non s√©curis√©e)\n    #[must_use]\n    pub const fn fast_insecure() -\u003e Self {\n        Self {\n            memory_cost: 1024, // 1 MiB\n            time_cost: 1,\n            parallelism: 1,\n            output_length: 32,\n        }\n    }\n\n    /// Configuration par d√©faut (√©quilibr√©e)\n    #[must_use]\n    pub const fn balanced() -\u003e Self {\n        Self {\n            memory_cost: 65536, // 64 MiB\n            time_cost: 2,\n            parallelism: 1,\n            output_length: 32,\n        }\n    }\n\n    /// Configuration s√©curis√©e (haute s√©curit√©)\n    #[must_use]\n    pub const fn secure() -\u003e Self {\n        Self {\n            memory_cost: 131_072, // 128 MiB\n            time_cost: 3,\n            parallelism: 2,\n            output_length: 32,\n        }\n    }\n}\n\nimpl Default for Argon2Config {\n    fn default() -\u003e Self {\n        Self::balanced()\n    }\n}\n\n/// D√©rive une cl√© 32 octets √† partir d'un mot de passe + sel.\n///\n/// # Errors\n/// √âchec si Argon2 √©choue ou si les entr√©es sont invalides.\npub fn derive_key_32(\n    password: \u0026SecretString,\n    salt: \u0026SaltString,\n    config: \u0026Argon2Config,\n) -\u003e Result\u003c[u8; 32], CryptoError\u003e {\n    let mut output = Zeroizing::new([0u8; 32]);\n\n    // Configuration Argon2id\n    let argon2 = Argon2::new(\n        argon2::Algorithm::Argon2id,\n        argon2::Version::V0x13,\n        argon2::Params::new(\n            config.memory_cost,\n            config.time_cost,\n            config.parallelism,\n            Some(config.output_length),\n        )\n        .map_err(|_| CryptoError::InvalidInput)?,\n    );\n\n    argon2\n        .hash_password_into(\n            password.expose_secret().as_bytes(),\n            salt.as_str().as_bytes(),\n            \u0026mut *output,\n        )\n        .map_err(|_| CryptoError::InvalidInput)?;\n\n    Ok(*output)\n}\n\n/// D√©rive une cl√© avec configuration par d√©faut.\n///\n/// # Errors\n/// √âchec si Argon2 √©choue ou si les entr√©es sont invalides.\npub fn derive_key_default(\n    password: \u0026SecretString,\n    salt: \u0026SaltString,\n) -\u003e Result\u003c[u8; 32], CryptoError\u003e {\n    derive_key_32(password, salt, \u0026Argon2Config::balanced())\n}\n\n/// Hash un mot de passe avec Argon2id (pour v√©rification).\n///\n/// # Errors\n/// √âchec si la s√©rialisation Argon2 √©choue.\npub fn hash_password(\n    password: \u0026SecretString,\n    config: \u0026Argon2Config,\n) -\u003e Result\u003cString, CryptoError\u003e {\n    let salt = SaltString::generate(\u0026mut OsRng);\n\n    let argon2 = Argon2::new(\n        argon2::Algorithm::Argon2id,\n        argon2::Version::V0x13,\n        argon2::Params::new(\n            config.memory_cost,\n            config.time_cost,\n            config.parallelism,\n            Some(config.output_length),\n        )\n        .map_err(|_| CryptoError::InvalidInput)?,\n    );\n\n    argon2\n        .hash_password(password.expose_secret().as_bytes(), \u0026salt)\n        .map_err(|_| CryptoError::InvalidInput)\n        .map(|hash| hash.to_string())\n}\n\n/// V√©rifie un hash argon2 s√©rialis√©.\n///\n/// # Errors\n/// √âchec si le format est invalide ou si la v√©rification √©choue.\npub fn verify_password(\n    password: \u0026SecretString,\n    serialized_hash: \u0026str,\n) -\u003e Result\u003cbool, CryptoError\u003e {\n    let parsed_hash = PasswordHash::new(serialized_hash).map_err(|_| CryptoError::InvalidInput)?;\n\n    Ok(Argon2::default()\n        .verify_password(password.expose_secret().as_bytes(), \u0026parsed_hash)\n        .is_ok())\n}\n\n/// D√©rive une sous-cl√© avec HKDF-SHA3-256.\n///\n/// # Errors\n/// √âchec si la longueur demand√©e n'est pas support√©e.\npub fn derive_subkey_hkdf(\n    master_key: \u0026[u8],\n    info: \u0026[u8],\n    length: usize,\n) -\u003e Result\u003cVec\u003cu8\u003e, CryptoError\u003e {\n    if length == 0 || length \u003e 255 * 32 {\n        return Err(CryptoError::InvalidInput);\n    }\n\n    let hkdf = Hkdf::\u003cSha3_256\u003e::new(None, master_key);\n    let mut output = vec![0u8; length];\n\n    hkdf.expand(info, \u0026mut output)\n        .map_err(|_| CryptoError::InvalidInput)?;\n\n    Ok(output)\n}\n\n/// D√©rive une sous-cl√© 32 octets avec HKDF.\n///\n/// # Errors\n/// √âchec si l'expansion HKDF √©choue.\npub fn derive_subkey_32(master_key: \u0026[u8], info: \u0026[u8]) -\u003e Result\u003c[u8; 32], CryptoError\u003e {\n    let derived = derive_subkey_hkdf(master_key, info, 32)?;\n    let mut output = [0u8; 32];\n    output.copy_from_slice(\u0026derived);\n    Ok(output)\n}\n\n/// G√©n√®re un sel al√©atoire pour Argon2.\npub fn generate_salt() -\u003e SaltString {\n    SaltString::generate(\u0026mut OsRng)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use secrecy::SecretString;\n\n    #[test]\n    fn test_argon2_derive_key() {\n        let password = SecretString::new(\"test_password\".to_string());\n        let salt = generate_salt();\n        let config = Argon2Config::fast_insecure();\n\n        let key1 = derive_key_32(\u0026password, \u0026salt, \u0026config).unwrap();\n        let key2 = derive_key_32(\u0026password, \u0026salt, \u0026config).unwrap();\n\n        // M√™me param√®tres = m√™me cl√©\n        assert_eq!(key1, key2);\n        assert_eq!(key1.len(), 32);\n    }\n\n    #[test]\n    fn test_argon2_different_salts() {\n        let password = SecretString::new(\"test_password\".to_string());\n        let salt1 = generate_salt();\n        let salt2 = generate_salt();\n        let config = Argon2Config::fast_insecure();\n\n        let key1 = derive_key_32(\u0026password, \u0026salt1, \u0026config).unwrap();\n        let key2 = derive_key_32(\u0026password, \u0026salt2, \u0026config).unwrap();\n\n        // Sels diff√©rents = cl√©s diff√©rentes\n        assert_ne!(key1, key2);\n    }\n\n    #[test]\n    fn test_password_hash_verification() {\n        let password = SecretString::new(\"secret_password\".to_string());\n        let config = Argon2Config::fast_insecure();\n\n        let hash = hash_password(\u0026password, \u0026config).unwrap();\n\n        // Bon mot de passe\n        assert!(verify_password(\u0026password, \u0026hash).unwrap());\n\n        // Mauvais mot de passe\n        let wrong_password = SecretString::new(\"wrong_password\".to_string());\n        assert!(!verify_password(\u0026wrong_password, \u0026hash).unwrap());\n    }\n\n    #[test]\n    fn test_hkdf_derive_subkey() {\n        let master_key = [0x42u8; 32];\n        let info = b\"test_context\";\n\n        let subkey1 = derive_subkey_32(\u0026master_key, info).unwrap();\n        let subkey2 = derive_subkey_32(\u0026master_key, info).unwrap();\n\n        // M√™me param√®tres = m√™me sous-cl√©\n        assert_eq!(subkey1, subkey2);\n        assert_eq!(subkey1.len(), 32);\n    }\n\n    #[test]\n    fn test_hkdf_different_info() {\n        let master_key = [0x42u8; 32];\n        let info1 = b\"context1\";\n        let info2 = b\"context2\";\n\n        let subkey1 = derive_subkey_32(\u0026master_key, info1).unwrap();\n        let subkey2 = derive_subkey_32(\u0026master_key, info2).unwrap();\n\n        // Info diff√©rent = sous-cl√©s diff√©rentes\n        assert_ne!(subkey1, subkey2);\n    }\n\n    #[test]\n    fn test_hkdf_variable_length() {\n        let master_key = [0x42u8; 32];\n        let info = b\"test\";\n\n        // Tailles diff√©rentes\n        let subkey16 = derive_subkey_hkdf(\u0026master_key, info, 16).unwrap();\n        let subkey64 = derive_subkey_hkdf(\u0026master_key, info, 64).unwrap();\n\n        assert_eq!(subkey16.len(), 16);\n        assert_eq!(subkey64.len(), 64);\n\n        // Les 16 premiers octets doivent √™tre identiques\n        assert_eq!(\u0026subkey64[..16], \u0026subkey16);\n    }\n\n    #[test]\n    fn test_configs() {\n        let configs = [\n            Argon2Config::fast_insecure(),\n            Argon2Config::balanced(),\n            Argon2Config::secure(),\n        ];\n\n        for config in \u0026configs {\n            assert!(config.memory_cost \u003e 0);\n            assert!(config.time_cost \u003e 0);\n            assert!(config.parallelism \u003e 0);\n            assert_eq!(config.output_length, 32);\n        }\n    }\n\n    #[test]\n    fn test_default_config() {\n        let default_config = Argon2Config::default();\n        let balanced_config = Argon2Config::balanced();\n        assert_eq!(default_config.memory_cost, balanced_config.memory_cost);\n        assert_eq!(default_config.time_cost, balanced_config.time_cost);\n        assert_eq!(default_config.parallelism, balanced_config.parallelism);\n        assert_eq!(default_config.output_length, balanced_config.output_length);\n    }\n\n    #[test]\n    fn test_derive_key_default() {\n        let password = SecretString::new(\"test_password\".to_string());\n        let salt = generate_salt();\n\n        let key1 = derive_key_default(\u0026password, \u0026salt).unwrap();\n        let key2 = derive_key_32(\u0026password, \u0026salt, \u0026Argon2Config::balanced()).unwrap();\n        \n        // Should be equivalent to balanced config\n        assert_eq!(key1, key2);\n    }\n\n    #[test]\n    fn test_generate_salt() {\n        let salt1 = generate_salt();\n        let salt2 = generate_salt();\n        \n        // Salts should be different\n        assert_ne!(salt1.to_string(), salt2.to_string());\n        \n        // Should be valid base64\n        assert!(!salt1.to_string().is_empty());\n        assert!(!salt2.to_string().is_empty());\n    }\n\n    #[test]\n    fn test_hash_password_different_configs() {\n        let password = SecretString::new(\"test_password\".to_string());\n        \n        let hash_fast = hash_password(\u0026password, \u0026Argon2Config::fast_insecure()).unwrap();\n        let hash_balanced = hash_password(\u0026password, \u0026Argon2Config::balanced()).unwrap();\n        let hash_secure = hash_password(\u0026password, \u0026Argon2Config::secure()).unwrap();\n        \n        // Different configs should produce different hashes\n        assert_ne!(hash_fast, hash_balanced);\n        assert_ne!(hash_balanced, hash_secure);\n        assert_ne!(hash_fast, hash_secure);\n        \n        // All should start with $argon2id$\n        assert!(hash_fast.starts_with(\"$argon2id$\"));\n        assert!(hash_balanced.starts_with(\"$argon2id$\"));\n        assert!(hash_secure.starts_with(\"$argon2id$\"));\n    }\n\n    #[test]\n    fn test_verify_password_wrong_password() {\n        let password = SecretString::new(\"correct_password\".to_string());\n        let wrong_password = SecretString::new(\"wrong_password\".to_string());\n        let config = Argon2Config::fast_insecure();\n\n        let hash = hash_password(\u0026password, \u0026config).unwrap();\n        \n        // Correct password should verify\n        assert!(verify_password(\u0026password, \u0026hash).unwrap());\n        \n        // Wrong password should not verify\n        assert!(!verify_password(\u0026wrong_password, \u0026hash).unwrap());\n    }\n\n    #[test]\n    fn test_verify_password_invalid_hash() {\n        let password = SecretString::new(\"test_password\".to_string());\n        \n        // Invalid hash format should return error\n        assert!(verify_password(\u0026password, \"invalid_hash\").is_err());\n        assert!(verify_password(\u0026password, \"\").is_err());\n        assert!(verify_password(\u0026password, \"$invalid$format$\").is_err());\n    }\n\n    #[test]\n    fn test_derive_subkey_hkdf_edge_cases() {\n        let master_key = [42u8; 32];\n        let info = b\"test_info\";\n        \n        // Test zero length (should error)\n        assert!(derive_subkey_hkdf(\u0026master_key, info, 0).is_err());\n        \n        // Test maximum length + 1 (should error)\n        assert!(derive_subkey_hkdf(\u0026master_key, info, 255 * 32 + 1).is_err());\n        \n        // Test valid maximum length\n        assert!(derive_subkey_hkdf(\u0026master_key, info, 255 * 32).is_ok());\n        \n        // Test length 1\n        let subkey = derive_subkey_hkdf(\u0026master_key, info, 1).unwrap();\n        assert_eq!(subkey.len(), 1);\n    }\n\n    #[test]\n    fn test_derive_subkey_32_different_info() {\n        let master_key = [42u8; 32];\n        let info1 = b\"info1\";\n        let info2 = b\"info2\";\n        \n        let subkey1 = derive_subkey_32(\u0026master_key, info1).unwrap();\n        let subkey2 = derive_subkey_32(\u0026master_key, info2).unwrap();\n        \n        // Different info should produce different subkeys\n        assert_ne!(subkey1, subkey2);\n    }\n\n    #[test]\n    fn test_derive_subkey_32_different_master_keys() {\n        let master_key1 = [1u8; 32];\n        let master_key2 = [2u8; 32];\n        let info = b\"same_info\";\n        \n        let subkey1 = derive_subkey_32(\u0026master_key1, info).unwrap();\n        let subkey2 = derive_subkey_32(\u0026master_key2, info).unwrap();\n        \n        // Different master keys should produce different subkeys\n        assert_ne!(subkey1, subkey2);\n    }\n\n    #[test]\n    fn test_argon2_params_edge_cases() {\n        let password = SecretString::new(\"test\".to_string());\n        let salt = generate_salt();\n        \n        // Test with minimal valid parameters (Argon2 has higher minimums than expected)\n        let config = Argon2Config {\n            memory_cost: 8, // Minimum for Argon2\n            time_cost: 1,   // Minimum 1 iteration\n            parallelism: 1, // Minimum 1 thread\n            output_length: 32, // Standard length\n        };\n        \n        // Should succeed with minimal valid params\n        let result = derive_key_32(\u0026password, \u0026salt, \u0026config);\n        assert!(result.is_ok());\n        let key = result.unwrap();\n        assert_eq!(key.len(), 32); // Always 32 bytes output\n    }\n}\n","traces":[{"line":30,"address":[388800],"length":1,"stats":{"Line":3}},{"line":41,"address":[388832],"length":1,"stats":{"Line":3}},{"line":52,"address":[3501056],"length":1,"stats":{"Line":2}},{"line":63,"address":[1430816],"length":1,"stats":{"Line":1}},{"line":64,"address":[3501096],"length":1,"stats":{"Line":1}},{"line":72,"address":[3501120,3502221,3502215],"length":1,"stats":{"Line":2}},{"line":77,"address":[3501188],"length":1,"stats":{"Line":2}},{"line":81,"address":[1430968],"length":1,"stats":{"Line":2}},{"line":82,"address":[3192096],"length":1,"stats":{"Line":2}},{"line":83,"address":[1431220,1431125,1431941,1431019],"length":1,"stats":{"Line":4}},{"line":84,"address":[3501259],"length":1,"stats":{"Line":2}},{"line":85,"address":[1430990],"length":1,"stats":{"Line":2}},{"line":86,"address":[389069],"length":1,"stats":{"Line":2}},{"line":87,"address":[389072],"length":1,"stats":{"Line":2}},{"line":89,"address":[3237120,3237130],"length":1,"stats":{"Line":2}},{"line":92,"address":[3193043,3192754,3192849],"length":1,"stats":{"Line":2}},{"line":94,"address":[3501667],"length":1,"stats":{"Line":2}},{"line":95,"address":[3192578],"length":1,"stats":{"Line":2}},{"line":96,"address":[3501798],"length":1,"stats":{"Line":2}},{"line":98,"address":[3237152,3237162],"length":1,"stats":{"Line":2}},{"line":100,"address":[1431758],"length":1,"stats":{"Line":2}},{"line":107,"address":[3502240],"length":1,"stats":{"Line":1}},{"line":111,"address":[1408977],"length":1,"stats":{"Line":1}},{"line":118,"address":[3193168],"length":1,"stats":{"Line":4}},{"line":122,"address":[3502363],"length":1,"stats":{"Line":4}},{"line":125,"address":[3193232],"length":1,"stats":{"Line":4}},{"line":126,"address":[1432120],"length":1,"stats":{"Line":4}},{"line":127,"address":[3193335,3193438,3193283],"length":1,"stats":{"Line":8}},{"line":128,"address":[1432131],"length":1,"stats":{"Line":4}},{"line":129,"address":[3502406],"length":1,"stats":{"Line":4}},{"line":130,"address":[3193257],"length":1,"stats":{"Line":4}},{"line":131,"address":[390171],"length":1,"stats":{"Line":4}},{"line":133,"address":[3502465,3502542],"length":1,"stats":{"Line":4}},{"line":137,"address":[3502683],"length":1,"stats":{"Line":4}},{"line":138,"address":[1422259,1422256],"length":1,"stats":{"Line":4}},{"line":139,"address":[3546396,3546384],"length":1,"stats":{"Line":12}},{"line":146,"address":[1432528],"length":1,"stats":{"Line":3}},{"line":150,"address":[3546416,3546419],"length":1,"stats":{"Line":5}},{"line":152,"address":[3503179,3503085],"length":1,"stats":{"Line":6}},{"line":153,"address":[1409808],"length":1,"stats":{"Line":3}},{"line":154,"address":[390897],"length":1,"stats":{"Line":3}},{"line":161,"address":[1432944,1433608,1433614],"length":1,"stats":{"Line":1}},{"line":166,"address":[3194205,3194146],"length":1,"stats":{"Line":2}},{"line":167,"address":[1433037],"length":1,"stats":{"Line":1}},{"line":170,"address":[391148],"length":1,"stats":{"Line":1}},{"line":171,"address":[3194315],"length":1,"stats":{"Line":1}},{"line":173,"address":[3503637,3503729,3503588,3503503],"length":1,"stats":{"Line":3}},{"line":174,"address":[3237283,3237280],"length":1,"stats":{"Line":1}},{"line":176,"address":[3503760],"length":1,"stats":{"Line":1}},{"line":183,"address":[3504382,3504388,3503904],"length":1,"stats":{"Line":1}},{"line":184,"address":[1433681],"length":1,"stats":{"Line":1}},{"line":185,"address":[391822],"length":1,"stats":{"Line":1}},{"line":186,"address":[1433860,1433935],"length":1,"stats":{"Line":2}},{"line":187,"address":[1410947],"length":1,"stats":{"Line":1}},{"line":191,"address":[3195264],"length":1,"stats":{"Line":2}},{"line":192,"address":[3195276],"length":1,"stats":{"Line":2}}],"covered":56,"coverable":56},{"path":["/","home","seb","Dev","miaou","miaou-crypto","src","keyring.rs"],"content":"//! Gestion s√©curis√©e des cl√©s cryptographiques\n//! \n//! Syst√®me de trousseau de cl√©s avec stockage s√©curis√©, d√©rivation de cl√©s\n//! et protection contre les acc√®s non autoris√©s.\n\nuse crate::crypto::{\n    CryptoError, CryptoResult,\n    encryption::{ChaCha20Poly1305Cipher, EncryptionEngine, EncryptedData},\n    signing::{Ed25519KeyPair},\n    hashing::{Argon2Hasher, Argon2Config, Blake3Hasher, HashingEngine},\n    primitives::{random_array, derive_subkey, secure_compare},\n};\nuse serde::{Deserialize, Serialize};\nuse zeroize::{Zeroize, ZeroizeOnDrop};\nuse std::collections::HashMap;\nuse std::time::{SystemTime, UNIX_EPOCH};\n\n/// Identifiant unique d'une cl√©\npub type KeyId = [u8; 16];\n\n/// Types de cl√©s support√©s\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\npub enum KeyType {\n    /// Cl√© de chiffrement ChaCha20-Poly1305\n    Encryption,\n    /// Cl√© de signature Ed25519\n    Signing,\n    /// Cl√© d√©riv√©e personnalis√©e\n    Derived { context: String },\n}\n\n/// M√©tadonn√©es d'une cl√©\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct KeyMetadata {\n    /// Identifiant unique de la cl√©\n    pub key_id: KeyId,\n    /// Type de cl√©\n    pub key_type: KeyType,\n    /// Nom descriptif de la cl√©\n    pub name: String,\n    /// Date de cr√©ation (timestamp Unix)\n    pub created_at: u64,\n    /// Date d'expiration optionnelle\n    pub expires_at: Option\u003cu64\u003e,\n    /// Indique si la cl√© est active\n    pub is_active: bool,\n    /// Tags pour organisation\n    pub tags: Vec\u003cString\u003e,\n}\n\n/// Cl√© secr√®te avec protection\n#[derive(ZeroizeOnDrop)]\npub struct SecretKey {\n    /// Donn√©es de la cl√©\n    key_data: Vec\u003cu8\u003e,\n    /// M√©tadonn√©es\n    #[zeroize(skip)]\n    metadata: KeyMetadata,\n}\n\n/// Cl√© publique\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PublicKey {\n    /// Donn√©es de la cl√© publique\n    pub key_data: Vec\u003cu8\u003e,\n    /// M√©tadonn√©es\n    pub metadata: KeyMetadata,\n}\n\n/// Paire de cl√©s compl√®te\n#[derive(ZeroizeOnDrop)]\npub struct KeyPair {\n    /// Cl√© priv√©e\n    private_key: SecretKey,\n    /// Cl√© publique correspondante\n    #[zeroize(skip)]\n    public_key: PublicKey,\n}\n\n/// Trousseau de cl√©s s√©curis√©\npub struct KeyStore {\n    /// Cl√© ma√Ætre pour chiffrer le trousseau\n    master_key: [u8; 32],\n    /// Cl√©s stock√©es (chiffr√©es)\n    encrypted_keys: HashMap\u003cKeyId, EncryptedKeyEntry\u003e,\n    /// Cache des cl√©s d√©chiffr√©es (temporaire)\n    key_cache: HashMap\u003cKeyId, SecretKey\u003e,\n    /// Configuration Argon2 pour d√©rivation de cl√©s\n    argon2_config: Argon2Config,\n}\n\n/// Entr√©e de cl√© chiffr√©e dans le stockage\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct EncryptedKeyEntry {\n    /// M√©tadonn√©es (non chiffr√©es pour recherche)\n    metadata: KeyMetadata,\n    /// Donn√©es de cl√© chiffr√©es\n    encrypted_data: EncryptedData,\n    /// Hash d'int√©grit√©\n    integrity_hash: [u8; 32],\n}\n\n/// Configuration du trousseau\n#[derive(Debug, Clone)]\npub struct KeyStoreConfig {\n    /// Utiliser un cache en m√©moire pour les cl√©s\n    pub enable_cache: bool,\n    /// Dur√©e de vie du cache en secondes\n    pub cache_lifetime: u64,\n    /// Configuration Argon2 pour d√©rivation\n    pub argon2_config: Argon2Config,\n    /// Taille maximale du trousseau (nombre de cl√©s)\n    pub max_keys: usize,\n}\n\nimpl Default for KeyStoreConfig {\n    fn default() -\u003e Self {\n        Self {\n            enable_cache: true,\n            cache_lifetime: 300, // 5 minutes\n            argon2_config: Argon2Config::secure(),\n            max_keys: 1000,\n        }\n    }\n}\n\nimpl SecretKey {\n    /// Cr√©e une nouvelle cl√© secr√®te\n    pub fn new(key_data: Vec\u003cu8\u003e, metadata: KeyMetadata) -\u003e Self {\n        Self { key_data, metadata }\n    }\n    \n    /// Acc√®s aux donn√©es de la cl√© (lecture seule)\n    pub fn key_data(\u0026self) -\u003e \u0026[u8] {\n        \u0026self.key_data\n    }\n    \n    /// Acc√®s aux m√©tadonn√©es\n    pub fn metadata(\u0026self) -\u003e \u0026KeyMetadata {\n        \u0026self.metadata\n    }\n    \n    /// V√©rifie si la cl√© est expir√©e\n    pub fn is_expired(\u0026self) -\u003e bool {\n        if let Some(expires_at) = self.metadata.expires_at {\n            let now = SystemTime::now()\n                .duration_since(UNIX_EPOCH)\n                .unwrap()\n                .as_secs();\n            now \u003e expires_at\n        } else {\n            false\n        }\n    }\n    \n    /// G√©n√®re une cl√© de chiffrement\n    pub fn generate_encryption_key(name: String, tags: Vec\u003cString\u003e) -\u003e CryptoResult\u003cSelf\u003e {\n        let key_data = random_array::\u003c32\u003e()?;\n        let metadata = KeyMetadata {\n            key_id: random_array::\u003c16\u003e()?,\n            key_type: KeyType::Encryption,\n            name,\n            created_at: SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs(),\n            expires_at: None,\n            is_active: true,\n            tags,\n        };\n        \n        Ok(Self::new(key_data.to_vec(), metadata))\n    }\n    \n    /// G√©n√®re une cl√© d√©riv√©e\n    pub fn derive_key(\n        master_key: \u0026[u8], \n        context: String, \n        index: u32,\n        name: String,\n        tags: Vec\u003cString\u003e\n    ) -\u003e CryptoResult\u003cSelf\u003e {\n        let derived_key = derive_subkey(master_key, \u0026context, index);\n        let metadata = KeyMetadata {\n            key_id: random_array::\u003c16\u003e()?,\n            key_type: KeyType::Derived { context },\n            name,\n            created_at: SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs(),\n            expires_at: None,\n            is_active: true,\n            tags,\n        };\n        \n        Ok(Self::new(derived_key.to_vec(), metadata))\n    }\n}\n\nimpl PublicKey {\n    /// Cr√©e une nouvelle cl√© publique\n    pub fn new(key_data: Vec\u003cu8\u003e, metadata: KeyMetadata) -\u003e Self {\n        Self { key_data, metadata }\n    }\n    \n    /// Calcule l'empreinte de la cl√© publique\n    pub fn fingerprint(\u0026self) -\u003e [u8; 8] {\n        let hash = Blake3Hasher::hash(\u0026self.key_data);\n        let mut fingerprint = [0u8; 8];\n        fingerprint.copy_from_slice(\u0026hash.as_bytes()[0..8]);\n        fingerprint\n    }\n}\n\nimpl KeyPair {\n    /// G√©n√®re une nouvelle paire de cl√©s Ed25519\n    pub fn generate_ed25519(name: String, tags: Vec\u003cString\u003e) -\u003e CryptoResult\u003cSelf\u003e {\n        let ed25519_keypair = Ed25519KeyPair::generate()?;\n        let key_id = random_array::\u003c16\u003e()?;\n        \n        let private_metadata = KeyMetadata {\n            key_id,\n            key_type: KeyType::Signing,\n            name: name.clone(),\n            created_at: SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs(),\n            expires_at: None,\n            is_active: true,\n            tags: tags.clone(),\n        };\n        \n        let public_metadata = private_metadata.clone();\n        \n        let private_key = SecretKey::new(\n            ed25519_keypair.private_key().to_bytes().to_vec(),\n            private_metadata,\n        );\n        \n        let public_key = PublicKey::new(\n            ed25519_keypair.public_key().to_bytes().to_vec(),\n            public_metadata,\n        );\n        \n        Ok(Self { private_key, public_key })\n    }\n    \n    /// Acc√®s √† la cl√© priv√©e\n    pub fn private_key(\u0026self) -\u003e \u0026SecretKey {\n        \u0026self.private_key\n    }\n    \n    /// Acc√®s √† la cl√© publique\n    pub fn public_key(\u0026self) -\u003e \u0026PublicKey {\n        \u0026self.public_key\n    }\n}\n\nimpl KeyStore {\n    /// Cr√©e un nouveau trousseau avec mot de passe\n    pub fn new_with_password(password: \u0026[u8], config: KeyStoreConfig) -\u003e CryptoResult\u003cSelf\u003e {\n        let salt = random_array::\u003c16\u003e()?;\n        let master_key = Argon2Hasher::derive_key(password, \u0026salt, \u0026config.argon2_config)?;\n        \n        if master_key.len() != 32 {\n            return Err(CryptoError::KeyGenerationError(\"Taille de cl√© ma√Ætre invalide\".into()));\n        }\n        \n        let mut key_array = [0u8; 32];\n        key_array.copy_from_slice(\u0026master_key[0..32]);\n        \n        Ok(Self {\n            master_key: key_array,\n            encrypted_keys: HashMap::new(),\n            key_cache: HashMap::new(),\n            argon2_config: config.argon2_config,\n        })\n    }\n    \n    /// Ajoute une cl√© secr√®te au trousseau\n    pub fn add_secret_key(\u0026mut self, key: SecretKey) -\u003e CryptoResult\u003c()\u003e {\n        let key_id = key.metadata().key_id;\n        \n        // Chiffrer la cl√© avec la cl√© ma√Ætre\n        let cipher = ChaCha20Poly1305Cipher::from_key(\u0026self.master_key)?;\n        let encrypted_data = cipher.encrypt_with_random_nonce(key.key_data())?;\n        \n        // Calculer hash d'int√©grit√©\n        let integrity_data = [key.key_data(), \u0026key_id].concat();\n        let integrity_hash = Blake3Hasher::hash(\u0026integrity_data);\n        \n        let entry = EncryptedKeyEntry {\n            metadata: key.metadata().clone(),\n            encrypted_data,\n            integrity_hash: *integrity_hash.as_bytes(),\n        };\n        \n        self.encrypted_keys.insert(key_id, entry);\n        self.key_cache.insert(key_id, key);\n        \n        Ok(())\n    }\n    \n    /// R√©cup√®re une cl√© par son ID\n    pub fn get_secret_key(\u0026mut self, key_id: \u0026KeyId) -\u003e CryptoResult\u003cOption\u003c\u0026SecretKey\u003e\u003e {\n        // V√©rifier le cache d'abord\n        if let Some(key) = self.key_cache.get(key_id) {\n            if !key.is_expired() {\n                return Ok(Some(key));\n            } else {\n                // Supprimer la cl√© expir√©e du cache\n                self.key_cache.remove(key_id);\n                return Err(CryptoError::VerificationError(\"Cl√© expir√©e\".into()));\n            }\n        }\n        \n        // D√©chiffrer depuis le stockage\n        if let Some(entry) = self.encrypted_keys.get(key_id) {\n            let cipher = ChaCha20Poly1305Cipher::from_key(\u0026self.master_key)?;\n            let key_data = cipher.decrypt_with_nonce(\u0026entry.encrypted_data)?;\n            \n            // V√©rifier l'int√©grit√©\n            let integrity_data = [\u0026key_data, key_id.as_slice()].concat();\n            let computed_hash = Blake3Hasher::hash(\u0026integrity_data);\n            \n            if !secure_compare(computed_hash.as_bytes(), \u0026entry.integrity_hash) {\n                return Err(CryptoError::VerificationError(\"Int√©grit√© de cl√© corrompue\".into()));\n            }\n            \n            let key = SecretKey::new(key_data, entry.metadata.clone());\n            \n            if key.is_expired() {\n                return Err(CryptoError::VerificationError(\"Cl√© expir√©e\".into()));\n            }\n            \n            self.key_cache.insert(*key_id, key);\n            Ok(self.key_cache.get(key_id))\n        } else {\n            Ok(None)\n        }\n    }\n    \n    /// Liste toutes les cl√©s (m√©tadonn√©es uniquement)\n    pub fn list_keys(\u0026self) -\u003e Vec\u003c\u0026KeyMetadata\u003e {\n        self.encrypted_keys.values().map(|entry| \u0026entry.metadata).collect()\n    }\n    \n    /// Supprime une cl√©\n    pub fn remove_key(\u0026mut self, key_id: \u0026KeyId) -\u003e CryptoResult\u003cbool\u003e {\n        let removed_encrypted = self.encrypted_keys.remove(key_id).is_some();\n        let removed_cached = self.key_cache.remove(key_id).is_some();\n        \n        Ok(removed_encrypted || removed_cached)\n    }\n    \n    /// Nettoie le cache des cl√©s\n    pub fn clear_cache(\u0026mut self) {\n        self.key_cache.clear();\n    }\n    \n    /// Exporte le trousseau chiffr√©\n    pub fn export_encrypted(\u0026self) -\u003e CryptoResult\u003cVec\u003cu8\u003e\u003e {\n        let data = bincode::serialize(\u0026self.encrypted_keys)\n            .map_err(|e| CryptoError::EncryptionError(format!(\"Serialization failed: {}\", e)))?;\n        \n        let cipher = ChaCha20Poly1305Cipher::from_key(\u0026self.master_key)?;\n        cipher.encrypt_with_random_nonce(\u0026data)\n            .map(|encrypted| bincode::serialize(\u0026encrypted).unwrap())\n    }\n    \n    /// Importe un trousseau chiffr√©\n    pub fn import_encrypted(\u0026mut self, data: \u0026[u8]) -\u003e CryptoResult\u003c()\u003e {\n        let encrypted_data: EncryptedData = bincode::deserialize(data)\n            .map_err(|e| CryptoError::DecryptionError(format!(\"Deserialization failed: {}\", e)))?;\n        \n        let cipher = ChaCha20Poly1305Cipher::from_key(\u0026self.master_key)?;\n        let decrypted_data = cipher.decrypt_with_nonce(\u0026encrypted_data)?;\n        \n        let imported_keys: HashMap\u003cKeyId, EncryptedKeyEntry\u003e = bincode::deserialize(\u0026decrypted_data)\n            .map_err(|e| CryptoError::DecryptionError(format!(\"Key data deserialization failed: {}\", e)))?;\n        \n        // Fusionner avec les cl√©s existantes\n        self.encrypted_keys.extend(imported_keys);\n        \n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_secret_key_generation() {\n        let key = SecretKey::generate_encryption_key(\n            \"test_key\".to_string(),\n            vec![\"test\".to_string()],\n        ).unwrap();\n        \n        assert_eq!(key.key_data().len(), 32);\n        assert_eq!(key.metadata().name, \"test_key\");\n        assert_eq!(key.metadata().key_type, KeyType::Encryption);\n        assert!(!key.is_expired());\n    }\n    \n    #[test]\n    fn test_key_derivation() {\n        let master = \u0026[1u8; 32];\n        let key1 = SecretKey::derive_key(\n            master, \n            \"encryption\".to_string(),\n            0,\n            \"derived_key\".to_string(),\n            vec![]\n        ).unwrap();\n        \n        let key2 = SecretKey::derive_key(\n            master,\n            \"encryption\".to_string(),\n            1,\n            \"derived_key2\".to_string(),\n            vec![]\n        ).unwrap();\n        \n        assert_ne!(key1.key_data(), key2.key_data());\n        assert_eq!(key1.key_data().len(), 32);\n    }\n    \n    #[test]\n    fn test_ed25519_keypair() {\n        let keypair = KeyPair::generate_ed25519(\n            \"signing_key\".to_string(),\n            vec![\"ed25519\".to_string()],\n        ).unwrap();\n        \n        assert_eq!(keypair.private_key().key_data().len(), 32);\n        assert_eq!(keypair.public_key().key_data.len(), 32);\n        assert_eq!(keypair.private_key().metadata().key_id, \n                   keypair.public_key().metadata.key_id);\n    }\n    \n    #[test]\n    fn test_keystore_basic_operations() {\n        let config = KeyStoreConfig::default();\n        let mut keystore = KeyStore::new_with_password(b\"test_password\", config).unwrap();\n        \n        let key = SecretKey::generate_encryption_key(\n            \"test_key\".to_string(),\n            vec![],\n        ).unwrap();\n        let key_id = key.metadata().key_id;\n        \n        // Ajouter la cl√©\n        keystore.add_secret_key(key).unwrap();\n        \n        // R√©cup√©rer la cl√©\n        let retrieved_key = keystore.get_secret_key(\u0026key_id).unwrap();\n        assert!(retrieved_key.is_some());\n        \n        // Lister les cl√©s\n        let keys = keystore.list_keys();\n        assert_eq!(keys.len(), 1);\n        \n        // Supprimer la cl√©\n        assert!(keystore.remove_key(\u0026key_id).unwrap());\n        assert!(keystore.get_secret_key(\u0026key_id).unwrap().is_none());\n    }\n    \n    #[test]\n    fn test_keystore_export_import() {\n        let config = KeyStoreConfig::default();\n        let mut keystore1 = KeyStore::new_with_password(b\"test_password\", config.clone()).unwrap();\n        \n        let key = SecretKey::generate_encryption_key(\"test_key\".to_string(), vec![]).unwrap();\n        let key_id = key.metadata().key_id;\n        keystore1.add_secret_key(key).unwrap();\n        \n        // Exporter\n        let exported_data = keystore1.export_encrypted().unwrap();\n        \n        // Importer dans nouveau trousseau\n        let mut keystore2 = KeyStore::new_with_password(b\"test_password\", config).unwrap();\n        keystore2.import_encrypted(\u0026exported_data).unwrap();\n        \n        // V√©rifier que la cl√© est pr√©sente\n        let retrieved_key = keystore2.get_secret_key(\u0026key_id).unwrap();\n        assert!(retrieved_key.is_some());\n    }\n    \n    #[test]\n    fn test_public_key_fingerprint() {\n        let keypair = KeyPair::generate_ed25519(\"test\".to_string(), vec![]).unwrap();\n        let fingerprint = keypair.public_key().fingerprint();\n        \n        assert_eq!(fingerprint.len(), 8);\n        \n        // M√™me cl√© = m√™me empreinte\n        let fingerprint2 = keypair.public_key().fingerprint();\n        assert_eq!(fingerprint, fingerprint2);\n    }\n    \n    #[test]\n    fn test_key_integrity_check() {\n        let config = KeyStoreConfig::default();\n        let mut keystore = KeyStore::new_with_password(b\"password\", config).unwrap();\n        \n        let key = SecretKey::generate_encryption_key(\"test\".to_string(), vec![]).unwrap();\n        let key_id = key.metadata().key_id;\n        \n        keystore.add_secret_key(key).unwrap();\n        \n        // Corrompre l'entr√©e chiffr√©e\n        if let Some(entry) = keystore.encrypted_keys.get_mut(\u0026key_id) {\n            entry.integrity_hash[0] ^= 1; // Corruption d'un bit\n        }\n        \n        // Clear cache pour forcer la lecture du stockage\n        keystore.clear_cache();\n        \n        // La r√©cup√©ration doit √©chouer\n        let result = keystore.get_secret_key(\u0026key_id);\n        assert!(result.is_err());\n    }\n}","traces":[],"covered":0,"coverable":0},{"path":["/","home","seb","Dev","miaou","miaou-crypto","src","lib.rs"],"content":"//! # Miaou Crypto v0.1.0\n//!\n//! Primitives cryptographiques s√©curis√©es pour la plateforme Miaou.\n//!\n//! Ce crate fournit une interface coh√©rente et s√©curis√©e pour toutes les\n//! op√©rations cryptographiques de Miaou, bas√©e sur des biblioth√®ques audit√©es.\n\n#![warn(missing_docs)]\n#![warn(rustdoc::broken_intra_doc_links)]\n\n// Modules cryptographiques\npub mod aead;\npub mod hash;\npub mod hashing;\npub mod kdf;\npub mod sign;\n\n// Re-exports pour API simplifi√©e\npub use aead::{decrypt, encrypt_auto_nonce, AeadKeyRef, SealedData};\npub use hash::{blake3_32, Blake3Engine, HashingEngine};\npub use kdf::{hash_password, verify_password, Argon2Config};\npub use sign::{Keypair, Signature, SigningKeyRef, VerifyingKeyRef};\n\nuse thiserror::Error;\n\n/// Erreurs cryptographiques principales\n#[derive(Error, Debug, Clone, PartialEq, Eq)]\npub enum CryptoError {\n    /// Op√©ration de chiffrement √©chou√©e\n    #[error(\"Encryption operation failed\")]\n    EncryptionFailed,\n\n    /// Op√©ration de d√©chiffrement √©chou√©e\n    #[error(\"Decryption operation failed\")]\n    DecryptionFailed,\n\n    /// V√©rification de signature √©chou√©e\n    #[error(\"Signature verification failed\")]\n    SignatureVerificationFailed,\n\n    /// Cl√© cryptographique invalide\n    #[error(\"Invalid cryptographic key\")]\n    InvalidKey,\n\n    /// Donn√©es d'entr√©e invalides\n    #[error(\"Invalid input data\")]\n    InvalidInput,\n\n    /// Taille de donn√©es incorrecte\n    #[error(\"Invalid data size: expected {expected}, got {actual}\")]\n    InvalidSize {\n        /// Taille attendue\n        expected: usize,\n        /// Taille actuelle\n        actual: usize,\n    },\n\n    /// AAD vide (interdit dans Miaou)\n    #[error(\"Empty AAD (Associated Authenticated Data) is not allowed\")]\n    EmptyAad,\n\n    /// Erreur de d√©rivation de cl√©\n    #[error(\"Key derivation failed\")]\n    KeyDerivationFailed,\n\n    /// Erreur de hachage\n    #[error(\"Hashing operation failed\")]\n    HashingFailed,\n\n    /// Erreur de troncature (cast impossible)\n    #[error(\"Truncation error during cast\")]\n    Truncation,\n}\n\n/// Type de r√©sultat cryptographique\npub type CryptoResult\u003cT\u003e = Result\u003cT, CryptoError\u003e;\n\n/// Constantes cryptographiques\npub mod constants {\n    /// Taille d'une cl√© AEAD (ChaCha20-Poly1305)\n    pub const AEAD_KEY_SIZE: usize = 32;\n\n    /// Taille d'un nonce ChaCha20-Poly1305\n    pub const CHACHA20_NONCE_SIZE: usize = 12;\n\n    /// Taille d'un tag d'authentification Poly1305\n    pub const POLY1305_TAG_SIZE: usize = 16;\n\n    /// Taille d'une cl√© publique Ed25519\n    pub const ED25519_PUBLIC_KEY_SIZE: usize = 32;\n\n    /// Taille d'une cl√© priv√©e Ed25519\n    pub const ED25519_PRIVATE_KEY_SIZE: usize = 32;\n\n    /// Taille d'une signature Ed25519\n    pub const ED25519_SIGNATURE_SIZE: usize = 64;\n\n    /// Taille d'un hash BLAKE3 par d√©faut\n    pub const BLAKE3_HASH_SIZE: usize = 32;\n}\n\n/// Interface commune pour les fournisseurs cryptographiques\npub trait CryptoProvider: Send + Sync {\n    /// Chiffre des donn√©es avec AAD obligatoire\n    ///\n    /// # Errors\n    /// √âchec si l'AEAD √©choue ou si les param√®tres sont invalides.\n    fn seal(\n        \u0026self,\n        key: \u0026AeadKeyRef,\n        aad: \u0026[u8],\n        plaintext: \u0026[u8],\n        rng: \u0026mut dyn rand_core::RngCore,\n    ) -\u003e CryptoResult\u003cSealedData\u003e;\n\n    /// D√©chiffre des donn√©es avec AAD\n    ///\n    /// # Errors\n    /// √âchec si l'authentification √©choue (tag invalide) ou en cas d'erreur interne.\n    fn open(\u0026self, key: \u0026AeadKeyRef, aad: \u0026[u8], sealed_data: \u0026SealedData)\n        -\u003e CryptoResult\u003cVec\u003cu8\u003e\u003e;\n\n    /// Signe un message\n    ///\n    /// # Errors\n    /// √âchec si la signature ne peut pas √™tre produite.\n    fn sign(\u0026self, signing_key: \u0026SigningKeyRef, message: \u0026[u8]) -\u003e CryptoResult\u003cSignature\u003e;\n\n    /// V√©rifie une signature\n    ///\n    /// # Errors\n    /// √âchec si la signature est invalide.\n    fn verify(\n        \u0026self,\n        verifying_key: \u0026VerifyingKeyRef,\n        message: \u0026[u8],\n        signature: \u0026Signature,\n    ) -\u003e CryptoResult\u003c()\u003e;\n\n    /// Calcule un hash cryptographique\n    ///\n    /// # Errors\n    /// √âchec si le calcul de hachage √©choue.\n    fn hash(\u0026self, data: \u0026[u8]) -\u003e CryptoResult\u003c[u8; 32]\u003e;\n}\n\n/// Impl√©mentation par d√©faut du fournisseur cryptographique\npub struct DefaultCryptoProvider;\n\nimpl CryptoProvider for DefaultCryptoProvider {\n    fn seal(\n        \u0026self,\n        key: \u0026AeadKeyRef,\n        aad: \u0026[u8],\n        plaintext: \u0026[u8],\n        rng: \u0026mut dyn rand_core::RngCore,\n    ) -\u003e CryptoResult\u003cSealedData\u003e {\n        encrypt_auto_nonce(key, aad, plaintext, rng)\n    }\n\n    fn open(\n        \u0026self,\n        key: \u0026AeadKeyRef,\n        aad: \u0026[u8],\n        sealed_data: \u0026SealedData,\n    ) -\u003e CryptoResult\u003cVec\u003cu8\u003e\u003e {\n        decrypt(key, aad, sealed_data)\n    }\n\n    fn sign(\u0026self, signing_key: \u0026SigningKeyRef, message: \u0026[u8]) -\u003e CryptoResult\u003cSignature\u003e {\n        Ok(signing_key.sign(message))\n    }\n\n    fn verify(\n        \u0026self,\n        verifying_key: \u0026VerifyingKeyRef,\n        message: \u0026[u8],\n        signature: \u0026Signature,\n    ) -\u003e CryptoResult\u003c()\u003e {\n        verifying_key.verify(message, signature)\n    }\n\n    fn hash(\u0026self, data: \u0026[u8]) -\u003e CryptoResult\u003c[u8; 32]\u003e {\n        Ok(blake3_32(data))\n    }\n}\n\n/// Test de disponibilit√© des primitives cryptographiques\n///\n/// # Errors\n/// Retourne une erreur si un des autotests crypto √©choue.\npub fn test_crypto_availability() -\u003e Result\u003c(), String\u003e {\n    use rand_core::OsRng;\n\n    // Test AEAD\n    let key = AeadKeyRef::from_bytes([42u8; 32]);\n    let plaintext = b\"test\";\n    let aad = b\"miaou_test\";\n    let mut rng = OsRng;\n\n    let encrypted = encrypt_auto_nonce(\u0026key, aad, plaintext, \u0026mut rng)\n        .map_err(|e| format!(\"AEAD test failed: {e}\"))?;\n\n    let decrypted =\n        decrypt(\u0026key, aad, \u0026encrypted).map_err(|e| format!(\"AEAD decrypt test failed: {e}\"))?;\n\n    if decrypted != plaintext {\n        return Err(\"AEAD roundtrip test failed\".to_string());\n    }\n\n    // Test signatures\n    let keypair = Keypair::generate();\n    let message = b\"test message\";\n\n    let signature = keypair.sign(message);\n    keypair\n        .verify(message, \u0026signature)\n        .map_err(|e| format!(\"Signature test failed: {e}\"))?;\n\n    // Test hachage\n    let _hash = blake3_32(b\"test data\");\n\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_crypto_availability_works() {\n        assert!(test_crypto_availability().is_ok());\n    }\n\n    #[test]\n    fn test_default_provider() {\n        let provider = DefaultCryptoProvider;\n        let key = AeadKeyRef::from_bytes([42u8; 32]);\n        let plaintext = b\"test message\";\n        let aad = b\"test_aad\";\n        let mut rng = rand_core::OsRng;\n\n        let sealed = provider.seal(\u0026key, aad, plaintext, \u0026mut rng).unwrap();\n        let opened = provider.open(\u0026key, aad, \u0026sealed).unwrap();\n        assert_eq!(\u0026opened, plaintext);\n    }\n}\n","traces":[{"line":151,"address":[3532400],"length":1,"stats":{"Line":1}},{"line":158,"address":[3223376],"length":1,"stats":{"Line":1}},{"line":161,"address":[1411680],"length":1,"stats":{"Line":1}},{"line":167,"address":[3532649],"length":1,"stats":{"Line":1}},{"line":170,"address":[1437456],"length":1,"stats":{"Line":0}},{"line":171,"address":[1437533],"length":1,"stats":{"Line":0}},{"line":174,"address":[3223664],"length":1,"stats":{"Line":0}},{"line":180,"address":[1412025],"length":1,"stats":{"Line":0}},{"line":183,"address":[1437712],"length":1,"stats":{"Line":0}},{"line":184,"address":[1412101],"length":1,"stats":{"Line":0}},{"line":192,"address":[3533056,3534381,3534468],"length":1,"stats":{"Line":4}},{"line":196,"address":[365937],"length":1,"stats":{"Line":4}},{"line":197,"address":[3223967],"length":1,"stats":{"Line":4}},{"line":198,"address":[3533131],"length":1,"stats":{"Line":4}},{"line":201,"address":[366216,366135,366006,367226],"length":1,"stats":{"Line":8}},{"line":202,"address":[366112,366184],"length":1,"stats":{"Line":4}},{"line":204,"address":[1402897,1402880],"length":1,"stats":{"Line":8}},{"line":207,"address":[3533783,3533859],"length":1,"stats":{"Line":8}},{"line":208,"address":[3534392,3533884],"length":1,"stats":{"Line":0}},{"line":212,"address":[366689],"length":1,"stats":{"Line":4}},{"line":213,"address":[1413038],"length":1,"stats":{"Line":4}},{"line":215,"address":[366766],"length":1,"stats":{"Line":4}},{"line":216,"address":[1413304,1413203],"length":1,"stats":{"Line":4}},{"line":217,"address":[3224857],"length":1,"stats":{"Line":4}},{"line":218,"address":[495728,495745],"length":1,"stats":{"Line":4}},{"line":221,"address":[3225061],"length":1,"stats":{"Line":4}},{"line":223,"address":[3225107],"length":1,"stats":{"Line":4}}],"covered":20,"coverable":27},{"path":["/","home","seb","Dev","miaou","miaou-crypto","src","mod.rs"],"content":"//! # Module Cryptographique Miaou v0.1.0 \"Premi√®re Griffe\"\n//! \n//! Ce module fournit des wrappers s√©curis√©s autour de biblioth√®ques cryptographiques\n//! audit√©es selon l'Option A coh√©rente (RustCrypto + Dalek).\n//! \n//! ## Primitives support√©es\n//! \n//! - **Chiffrement authentifi√©** : XChaCha20-Poly1305 (nonces 192-bit)\n//! - **Signatures num√©riques** : Ed25519 (via `ed25519-dalek`)  \n//! - **√âchange de cl√©s** : X25519 (via `x25519-dalek`)\n//! - **Hachage** : BLAKE3, SHA-3\n//! - **KDF** : Argon2id (mots de passe) + HKDF (sessions)\n//! \n//! ## Garanties de s√©curit√©\n//! \n//! - Stack cryptographique coh√©rente (pas de m√©lange ring + dalek)\n//! - AAD obligatoire pour tous les AEAD\n//! - Zeroization automatique des secrets\n//! - Traits object-safe avec \u0026self\n//! - Tests KAT avec vecteurs IETF officiels\n//! - Protection contre les attaques par canaux auxiliaires\n\npub mod aead;\npub mod sign;\npub mod kdf;\npub mod hash;\n\n// Re-exports publics\npub use aead::{AeadKeyRef, SealedData, random_nonce};\npub use sign::{Keypair, SigningKeyRef, VerifyingKeyRef, Signature};\npub use kdf::{derive_key_32, Argon2Config};\npub use hash::{blake3_32, sha3_256, Blake3Output, HashingEngine, Blake3Engine};\n\n/// Erreurs cryptographiques coh√©rentes\n#[derive(thiserror::Error, Debug)]\npub enum CryptoError {\n    /// √âchec chiffrement/d√©chiffrement AEAD.\n    #[error(\"encryption/decryption failure\")]\n    AeadFailure,\n    /// Cl√© invalide / longueur incorrecte.\n    #[error(\"invalid key or key length\")]\n    InvalidKey,\n    /// Entr√©e invalide (format/longueur).\n    #[error(\"invalid input\")]\n    InvalidInput,\n    /// AAD vide (interdit).\n    #[error(\"empty AAD not allowed\")]\n    EmptyAad,\n    /// Signature invalide.\n    #[error(\"signature verification failed\")]\n    SignatureVerificationFailed,\n    /// Erreur de g√©n√©ration al√©atoire.\n    #[error(\"random generation failed\")]\n    RandomGenerationFailed,\n}\n\n/// Type de r√©sultat standard pour les op√©rations cryptographiques\npub type CryptoResult\u003cT\u003e = Result\u003cT, CryptoError\u003e;\n\n/// Fournit des primitives cryptographiques de haut niveau (AEAD, signatures)\n/// Impl√©mentations bas√©es EXCLUSIVEMENT sur des biblioth√®ques audit√©es\npub trait CryptoProvider: Send + Sync {\n    /// Chiffre avec XChaCha20-Poly1305 et AAD obligatoires\n    /// - `aad`: donn√©es associ√©es (version protocole, type message, flags)\n    /// - G√©n√®re automatiquement un nonce 192-bit al√©atoire\n    fn seal(\n        \u0026self,\n        key: \u0026AeadKeyRef,\n        aad: \u0026[u8],  // OBLIGATOIRE - jamais vide\n        plaintext: \u0026[u8],\n        rng: \u0026mut dyn rand_core::RngCore,\n    ) -\u003e Result\u003cSealedData, CryptoError\u003e;\n\n    /// D√©chiffre et authentifie ; √©choue si tag/nonce/AAD invalide\n    fn open(\n        \u0026self,\n        key: \u0026AeadKeyRef,\n        aad: \u0026[u8],  // DOIT correspondre exactement au seal\n        sealed: \u0026SealedData,\n    ) -\u003e Result\u003cVec\u003cu8\u003e, CryptoError\u003e;\n\n    /// Signe avec Ed25519 (signature 64 bytes)\n    fn sign(\u0026self, sk: \u0026SigningKeyRef, msg: \u0026[u8]) -\u003e Result\u003cSignature, CryptoError\u003e;\n\n    /// V√©rifie signature Ed25519 - RETOURNE ERREUR (pas bool)\n    fn verify(\u0026self, pk: \u0026VerifyingKeyRef, msg: \u0026[u8], sig: \u0026Signature) -\u003e Result\u003c(), CryptoError\u003e;\n}\n\n/// G√©n√®re et g√®re le mat√©riel cryptographique (object-safe)\npub trait KeyMaterial: Send + Sync {\n    /// G√©n√®re une nouvelle identit√© (paire de cl√©s Ed25519)\n    fn generate_identity(\u0026self, rng: \u0026mut dyn rand_core::RngCore) -\u003e Result\u003cKeypair, CryptoError\u003e;\n    \n    /// Fait la rotation d'une cl√© de session (nouvelle cl√© AEAD)\n    fn rotate_session_key(\u0026self, rng: \u0026mut dyn rand_core::RngCore) -\u003e Result\u003cAeadKeyRef, CryptoError\u003e;\n}\n\n/// Taille standard des nonces pour ChaCha20-Poly1305 (12 bytes)\npub const NONCE_SIZE: usize = 12;\n\n/// Taille standard des cl√©s pour ChaCha20-Poly1305 (32 bytes) \npub const KEY_SIZE: usize = 32;\n\n/// Taille des signatures Ed25519 (64 bytes)\npub const SIGNATURE_SIZE: usize = 64;\n\n/// Taille des cl√©s publiques Ed25519 (32 bytes)\npub const PUBLIC_KEY_SIZE: usize = 32;\n\n/// Teste la disponibilit√© des fonctions cryptographiques\npub fn test_crypto_availability() -\u003e Result\u003c(), String\u003e {\n    use rand_core::OsRng;\n    \n    // Test BLAKE3\n    let hash1 = blake3_32(b\"test\");\n    let hash2 = blake3_32(b\"test\");\n    if hash1 != hash2 {\n        return Err(\"Test de hachage √©chou√©\".into());\n    }\n    \n    // Test g√©n√©ration al√©atoire\n    let mut rng = OsRng;\n    let random1 = random_nonce(\u0026mut rng);\n    let random2 = random_nonce(\u0026mut rng);\n    \n    if random1 == random2 {\n        return Err(\"G√©n√©rateur al√©atoire d√©faillant\".into());\n    }\n    \n    // Test AEAD roundtrip basique\n    let key = AeadKeyRef::from_bytes([42u8; 32]);\n    let nonce = random_nonce(\u0026mut rng);\n    \n    match aead::encrypt(\u0026key, nonce, b\"test_aad\", b\"test_message\") {\n        Ok(sealed) =\u003e {\n            match aead::decrypt(\u0026key, b\"test_aad\", \u0026sealed) {\n                Ok(decrypted) =\u003e {\n                    if decrypted != b\"test_message\" {\n                        return Err(\"Test AEAD roundtrip √©chou√©\".into());\n                    }\n                }\n                Err(_) =\u003e return Err(\"Test AEAD decrypt √©chou√©\".into()),\n            }\n        }\n        Err(_) =\u003e return Err(\"Test AEAD encrypt √©chou√©\".into()),\n    }\n    \n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_core::OsRng;\n\n    #[test]\n    fn test_constants() {\n        assert_eq!(NONCE_SIZE, 12);  // ChaCha20 nonce\n        assert_eq!(KEY_SIZE, 32);\n        assert_eq!(SIGNATURE_SIZE, 64);\n        assert_eq!(PUBLIC_KEY_SIZE, 32);\n    }\n\n    #[test]\n    fn test_crypto_availability() {\n        // La fonction retourne Result\u003c(), String\u003e\n        let result = crate::crypto::test_crypto_availability();\n        assert!(result.is_ok(), \"Test crypto availability failed: {:?}\", result);\n    }\n    \n    #[test]\n    fn test_aead_aad_enforcement() {\n        let key = AeadKeyRef::from_bytes([42u8; 32]);\n        let mut rng = OsRng;\n        let nonce = random_nonce(\u0026mut rng);\n        \n        // AAD vide doit √™tre rejet√©e\n        let result = aead::encrypt(\u0026key, nonce, b\"\", b\"plaintext\");\n        assert!(result.is_err());\n        \n        // AAD non-vide doit fonctionner\n        let result = aead::encrypt(\u0026key, nonce, b\"version:1\", b\"plaintext\");\n        assert!(result.is_ok());\n    }\n}","traces":[],"covered":0,"coverable":0},{"path":["/","home","seb","Dev","miaou","miaou-crypto","src","primitives.rs"],"content":"//! Primitives cryptographiques de base\n//! \n//! Fonctions utilitaires s√©curis√©es pour op√©rations cryptographiques communes.\n\nuse crate::{CryptoError, CryptoResult};\nuse crate::crypto::hashing::{Blake3Hasher, HashingEngine};\nuse ring::rand::{SecureRandom, SystemRandom};\nuse subtle::ConstantTimeEq;\nuse zeroize::Zeroize;\n\n/// G√©n√©rateur de nombres al√©atoires cryptographiquement s√ªr\nstatic SECURE_RNG: std::sync::LazyLock\u003cSystemRandom\u003e = std::sync::LazyLock::new(|| SystemRandom::new());\n\n/// G√©n√®re des bytes al√©atoires cryptographiquement s√ªrs\n/// \n/// # Arguments\n/// * `length` - Nombre de bytes √† g√©n√©rer\n/// \n/// # Returns\n/// * `Vec\u003cu8\u003e` - Bytes al√©atoires g√©n√©r√©s\n/// \n/// # Examples\n/// ```\n/// use miaou::crypto::primitives::random_bytes;\n/// \n/// let random_data = random_bytes(32).unwrap();\n/// assert_eq!(random_data.len(), 32);\n/// ```\npub fn random_bytes(length: usize) -\u003e CryptoResult\u003cVec\u003cu8\u003e\u003e {\n    let mut bytes = vec![0u8; length];\n    (\u0026*SECURE_RNG)\n        .fill(\u0026mut bytes)\n        .map_err(|e| CryptoError::KeyGenerationError(format!(\"RNG failed: {:?}\", e)))?;\n    Ok(bytes)\n}\n\n/// G√©n√®re un tableau de bytes al√©atoires de taille fixe\n/// \n/// # Examples\n/// ```\n/// use miaou::crypto::primitives::random_array;\n/// \n/// let random_key: [u8; 32] = random_array().unwrap();\n/// assert_eq!(random_key.len(), 32);\n/// ```\npub fn random_array\u003cconst N: usize\u003e() -\u003e CryptoResult\u003c[u8; N]\u003e {\n    let mut array = [0u8; N];\n    (\u0026*SECURE_RNG)\n        .fill(\u0026mut array)\n        .map_err(|e| CryptoError::KeyGenerationError(format!(\"RNG failed: {:?}\", e)))?;\n    Ok(array)\n}\n\n/// Comparaison en temps constant pour √©viter les attaques par canaux auxiliaires\n/// \n/// # Arguments\n/// * `a` - Premier slice √† comparer\n/// * `b` - Second slice √† comparer\n/// \n/// # Returns\n/// * `bool` - true si les slices sont identiques, false sinon\n/// \n/// # Security\n/// Cette fonction utilise une comparaison en temps constant pour √©viter\n/// les attaques par analyse temporelle.\n/// \n/// # Examples\n/// ```\n/// use miaou::crypto::primitives::secure_compare;\n/// \n/// let data1 = b\"secret\";\n/// let data2 = b\"secret\";\n/// let data3 = b\"public\";\n/// \n/// assert!(secure_compare(data1, data2));\n/// assert!(!secure_compare(data1, data3));\n/// ```\npub fn secure_compare(a: \u0026[u8], b: \u0026[u8]) -\u003e bool {\n    // V√©rification des longueurs d'abord\n    if a.len() != b.len() {\n        return false;\n    }\n    \n    // Comparaison en temps constant\n    a.ct_eq(b).into()\n}\n\n/// XOR de deux slices de m√™me taille\n/// \n/// # Arguments\n/// * `a` - Premier slice\n/// * `b` - Second slice (doit avoir la m√™me taille que `a`)\n/// \n/// # Returns\n/// * `Result\u003cVec\u003cu8\u003e, CryptoError\u003e` - XOR des deux slices\n/// \n/// # Examples\n/// ```\n/// use miaou::crypto::primitives::xor_bytes;\n/// \n/// let a = \u0026[0xFF, 0x00, 0xAA];\n/// let b = \u0026[0x0F, 0xFF, 0x55];\n/// let result = xor_bytes(a, b).unwrap();\n/// assert_eq!(result, vec![0xF0, 0xFF, 0xFF]);\n/// ```\npub fn xor_bytes(a: \u0026[u8], b: \u0026[u8]) -\u003e CryptoResult\u003cVec\u003cu8\u003e\u003e {\n    if a.len() != b.len() {\n        return Err(CryptoError::InvalidDataSize {\n            expected: a.len(),\n            actual: b.len(),\n        });\n    }\n    \n    let result: Vec\u003cu8\u003e = a.iter().zip(b.iter()).map(|(x, y)| x ^ y).collect();\n    Ok(result)\n}\n\n/// Combine deux cl√©s de mani√®re s√©curis√©e (XOR apr√®s hachage)\n/// \n/// # Arguments\n/// * `key1` - Premi√®re cl√©\n/// * `key2` - Seconde cl√©  \n/// \n/// # Returns\n/// * `[u8; 32]` - Cl√© combin√©e de 32 bytes\n/// \n/// # Security\n/// Les cl√©s sont d'abord hach√©es avec BLAKE3 avant XOR pour √©viter\n/// les faiblesses cryptographiques du XOR direct.\npub fn combine_keys(key1: \u0026[u8], key2: \u0026[u8]) -\u003e [u8; 32] {\n    use crate::crypto::hashing::Blake3Hasher;\n    \n    let hash1 = Blake3Hasher::hash(key1);\n    let hash2 = Blake3Hasher::hash(key2);\n    \n    let mut combined = [0u8; 32];\n    for i in 0..32 {\n        combined[i] = hash1.as_bytes()[i] ^ hash2.as_bytes()[i];\n    }\n    \n    combined\n}\n\n/// D√©rive une sous-cl√© √† partir d'une cl√© ma√Ætre et d'un contexte\n/// \n/// # Arguments\n/// * `master_key` - Cl√© ma√Ætre\n/// * `context` - Contexte de d√©rivation (ex: \"encryption\", \"signature\")\n/// * `index` - Index de la sous-cl√© (pour g√©n√©rer plusieurs cl√©s)\n/// \n/// # Returns\n/// * `[u8; 32]` - Sous-cl√© d√©riv√©e\n/// \n/// # Examples\n/// ```\n/// use miaou::crypto::primitives::derive_subkey;\n/// \n/// let master = \u0026[0u8; 32];\n/// let encryption_key = derive_subkey(master, \"encryption\", 0);\n/// let signing_key = derive_subkey(master, \"signing\", 0);\n/// \n/// assert_ne!(encryption_key, signing_key);\n/// ```\npub fn derive_subkey(master_key: \u0026[u8], context: \u0026str, index: u32) -\u003e [u8; 32] {\n    let context_with_index = format!(\"miaou.{}.{}\", context, index);\n    let combined = [master_key, context_with_index.as_bytes()].concat();\n    let hash = blake3::hash(\u0026combined);\n    *hash.as_bytes()\n}\n\n/// M√©lange s√©curis√© de donn√©es (shuffle cryptographique)\n/// \n/// # Arguments\n/// * `data` - Donn√©es √† m√©langer\n/// * `seed` - Graine pour le m√©lange (doit √™tre al√©atoire)\n/// \n/// # Returns\n/// * `Vec\u003cu8\u003e` - Donn√©es m√©lang√©es\n/// \n/// # Security\n/// Utilise Fisher-Yates avec un PRNG seed√© pour un m√©lange d√©terministe\n/// mais cryptographiquement s√ªr.\npub fn secure_shuffle(data: \u0026[u8], seed: \u0026[u8; 32]) -\u003e Vec\u003cu8\u003e {\n    use rand::{Rng, SeedableRng};\n    use rand_chacha::ChaCha20Rng;\n    \n    let mut rng = ChaCha20Rng::from_seed(*seed);\n    let mut result = data.to_vec();\n    \n    // Fisher-Yates shuffle\n    for i in (1..result.len()).rev() {\n        let j = rng.gen_range(0..=i);\n        result.swap(i, j);\n    }\n    \n    result\n}\n\n/// G√©n√®re un sel al√©atoire pour Argon2 ou autres KDF\n/// \n/// # Returns\n/// * `[u8; 16]` - Sel al√©atoire de 16 bytes\npub fn generate_salt() -\u003e CryptoResult\u003c[u8; 16]\u003e {\n    random_array::\u003c16\u003e()\n}\n\n/// G√©n√®re un nonce al√©atoire pour ChaCha20-Poly1305\n/// \n/// # Returns\n/// * `[u8; 12]` - Nonce al√©atoire de 12 bytes\npub fn generate_nonce() -\u003e CryptoResult\u003c[u8; 12]\u003e {\n    random_array::\u003c12\u003e()\n}\n\n/// Efface de mani√®re s√©curis√©e un buffer en m√©moire\n/// \n/// # Arguments\n/// * `buffer` - Buffer mutable √† effacer\n/// \n/// # Security\n/// Utilise zeroize pour garantir que les donn√©es sensibles\n/// sont bien effac√©es de la m√©moire.\npub fn secure_erase(buffer: \u0026mut [u8]) {\n    buffer.zeroize();\n}\n\n/// G√©n√©rateur d'identifiants uniques cryptographiquement s√ªrs\npub struct SecureIdGenerator {\n    counter: std::sync::atomic::AtomicU64,\n    node_id: [u8; 8],\n}\n\nimpl SecureIdGenerator {\n    /// Cr√©e un nouveau g√©n√©rateur avec un ID de n≈ìud al√©atoire\n    pub fn new() -\u003e CryptoResult\u003cSelf\u003e {\n        let node_id = random_array::\u003c8\u003e()?;\n        Ok(Self {\n            counter: std::sync::atomic::AtomicU64::new(0),\n            node_id,\n        })\n    }\n    \n    /// G√©n√®re un ID unique de 16 bytes\n    pub fn generate_id(\u0026self) -\u003e [u8; 16] {\n        use std::sync::atomic::Ordering;\n        \n        let counter = self.counter.fetch_add(1, Ordering::SeqCst);\n        let timestamp = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap()\n            .as_millis() as u64;\n        \n        let mut id = [0u8; 16];\n        id[0..8].copy_from_slice(\u0026timestamp.to_be_bytes());\n        id[8..16].copy_from_slice(\u0026(counter ^ u64::from_be_bytes(self.node_id)).to_be_bytes());\n        \n        id\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_random_bytes() {\n        let bytes1 = random_bytes(32).unwrap();\n        let bytes2 = random_bytes(32).unwrap();\n        \n        assert_eq!(bytes1.len(), 32);\n        assert_eq!(bytes2.len(), 32);\n        assert_ne!(bytes1, bytes2); // Probabilit√© n√©gligeable d'√™tre √©gaux\n    }\n    \n    #[test]\n    fn test_random_array() {\n        let array1: [u8; 16] = random_array().unwrap();\n        let array2: [u8; 16] = random_array().unwrap();\n        \n        assert_ne!(array1, array2);\n    }\n    \n    #[test]\n    fn test_secure_compare() {\n        let data1 = b\"secret_data\";\n        let data2 = b\"secret_data\";\n        let data3 = b\"public_data\";\n        let data4 = b\"secret\"; // Longueur diff√©rente\n        \n        assert!(secure_compare(data1, data2));\n        assert!(!secure_compare(data1, data3));\n        assert!(!secure_compare(data1, data4));\n    }\n    \n    #[test]\n    fn test_xor_bytes() {\n        let a = \u0026[0xFF, 0x00, 0xAA, 0x55];\n        let b = \u0026[0x0F, 0xFF, 0x55, 0xAA];\n        let expected = vec![0xF0, 0xFF, 0xFF, 0xFF];\n        \n        let result = xor_bytes(a, b).unwrap();\n        assert_eq!(result, expected);\n        \n        // Test tailles diff√©rentes\n        let c = \u0026[0xFF];\n        assert!(xor_bytes(a, c).is_err());\n    }\n    \n    #[test]\n    fn test_combine_keys() {\n        let key1 = \u0026[1u8; 32];\n        let key2 = \u0026[2u8; 32];\n        let key3 = \u0026[1u8; 32]; // Identique √† key1\n        \n        let combined1 = combine_keys(key1, key2);\n        let combined2 = combine_keys(key1, key3);\n        let combined3 = combine_keys(key2, key1); // Ordre diff√©rent\n        \n        assert_ne!(combined1, combined2);\n        assert_eq!(combined1, combined3); // XOR est commutatif apr√®s hash\n    }\n    \n    #[test]\n    fn test_derive_subkey() {\n        let master = \u0026[0u8; 32];\n        \n        let enc_key = derive_subkey(master, \"encryption\", 0);\n        let sig_key = derive_subkey(master, \"signing\", 0);\n        let enc_key2 = derive_subkey(master, \"encryption\", 1);\n        \n        // Contextes diff√©rents = cl√©s diff√©rentes\n        assert_ne!(enc_key, sig_key);\n        \n        // Index diff√©rents = cl√©s diff√©rentes\n        assert_ne!(enc_key, enc_key2);\n        \n        // D√©terminisme\n        let enc_key_again = derive_subkey(master, \"encryption\", 0);\n        assert_eq!(enc_key, enc_key_again);\n    }\n    \n    #[test]\n    fn test_secure_shuffle() {\n        let data = b\"Hello, World!\";\n        let seed1 = [1u8; 32];\n        let seed2 = [2u8; 32];\n        \n        let shuffled1 = secure_shuffle(data, \u0026seed1);\n        let shuffled2 = secure_shuffle(data, \u0026seed2);\n        let shuffled1_again = secure_shuffle(data, \u0026seed1);\n        \n        // M√™me seed = m√™me r√©sultat\n        assert_eq!(shuffled1, shuffled1_again);\n        \n        // Seeds diff√©rents = r√©sultats diff√©rents (tr√®s probable)\n        assert_ne!(shuffled1, shuffled2);\n        \n        // M√™me longueur\n        assert_eq!(shuffled1.len(), data.len());\n    }\n    \n    #[test]\n    fn test_salt_and_nonce_generation() {\n        let salt1 = generate_salt().unwrap();\n        let salt2 = generate_salt().unwrap();\n        let nonce1 = generate_nonce().unwrap();\n        let nonce2 = generate_nonce().unwrap();\n        \n        assert_eq!(salt1.len(), 16);\n        assert_eq!(nonce1.len(), 12);\n        assert_ne!(salt1, salt2);\n        assert_ne!(nonce1, nonce2);\n    }\n    \n    #[test]\n    fn test_secure_erase() {\n        let mut buffer = vec![0xAA; 100];\n        secure_erase(\u0026mut buffer);\n        \n        // V√©rifier que tout est √† z√©ro\n        assert!(buffer.iter().all(|\u0026x| x == 0));\n    }\n    \n    #[test]\n    fn test_secure_id_generator() {\n        let generator = SecureIdGenerator::new().unwrap();\n        \n        let id1 = generator.generate_id();\n        let id2 = generator.generate_id();\n        \n        assert_eq!(id1.len(), 16);\n        assert_eq!(id2.len(), 16);\n        assert_ne!(id1, id2);\n    }\n    \n    #[test]\n    fn test_secure_id_generator_uniqueness() {\n        let generator = SecureIdGenerator::new().unwrap();\n        let mut ids = std::collections::HashSet::new();\n        \n        // G√©n√©rer 1000 IDs et v√©rifier l'unicit√©\n        for _ in 0..1000 {\n            let id = generator.generate_id();\n            assert!(ids.insert(id), \"ID dupliqu√© d√©tect√©\");\n        }\n    }\n}","traces":[{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":6},{"path":["/","home","seb","Dev","miaou","miaou-crypto","src","sign.rs"],"content":"//! # Signatures Ed25519 (v0.1)\n//!\n//! G√©n√®re une paire, signe et v√©rifie des messages (aucun Debug sur secrets).\n//! Utilise ed25519-dalek v2 avec zeroization automatique.\n\nuse crate::CryptoError;\nuse ed25519_dalek::{Signature as DalekSignature, Signer, SigningKey, Verifier, VerifyingKey};\nuse rand_core::{CryptoRng, OsRng, RngCore};\nuse zeroize::ZeroizeOnDrop;\n\n/// Cl√© de signature secr√®te (zeroized on drop, non clonable, non affichable)\n#[derive(ZeroizeOnDrop)]\npub struct SigningKeyRef {\n    inner: SigningKey,\n}\n\nimpl SigningKeyRef {\n    /// Cr√©e une cl√© de signature depuis 32 octets.\n    #[must_use]\n    pub fn from_bytes(bytes: [u8; 32]) -\u003e Self {\n        Self {\n            inner: SigningKey::from_bytes(\u0026bytes),\n        }\n    }\n\n    /// G√©n√®re une nouvelle cl√© de signature al√©atoire.\n    #[must_use]\n    pub fn generate\u003cR: RngCore + CryptoRng\u003e(rng: \u0026mut R) -\u003e Self {\n        Self {\n            inner: SigningKey::generate(rng),\n        }\n    }\n\n    /// Retourne la cl√© publique correspondante.\n    #[must_use]\n    pub fn verifying_key(\u0026self) -\u003e VerifyingKeyRef {\n        VerifyingKeyRef {\n            inner: self.inner.verifying_key(),\n        }\n    }\n\n    /// Retourne les octets de la cl√© secr√®te (usage keystore).\n    #[must_use]\n    pub fn to_bytes(\u0026self) -\u003e [u8; 32] {\n        self.inner.to_bytes()\n    }\n\n    /// Signe un message.\n    #[must_use]\n    pub fn sign(\u0026self, msg: \u0026[u8]) -\u003e Signature {\n        Signature {\n            inner: self.inner.sign(msg),\n        }\n    }\n}\n\n// Pas de Debug pour √©viter les fuites\nimpl std::fmt::Debug for SigningKeyRef {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"SigningKeyRef([REDACTED])\")\n    }\n}\n\n/// Cl√© de v√©rification publique\n#[derive(Clone, Copy, Debug, PartialEq, Eq)]\npub struct VerifyingKeyRef {\n    inner: VerifyingKey,\n}\n\nimpl VerifyingKeyRef {\n    /// Cr√©e une cl√© de v√©rification depuis 32 octets.\n    ///\n    /// # Errors\n    /// √âchec si les octets ne repr√©sentent pas une cl√© publique Ed25519 valide.\n    pub fn from_bytes(bytes: [u8; 32]) -\u003e Result\u003cSelf, CryptoError\u003e {\n        VerifyingKey::from_bytes(\u0026bytes)\n            .map(|inner| Self { inner })\n            .map_err(|_| CryptoError::InvalidKey)\n    }\n\n    /// Retourne les octets de la cl√© publique.\n    #[must_use]\n    pub fn to_bytes(\u0026self) -\u003e [u8; 32] {\n        self.inner.to_bytes()\n    }\n\n    /// V√©rifie une signature.\n    ///\n    /// # Errors\n    /// √âchec si la signature est invalide pour le message donn√©.\n    pub fn verify(\u0026self, msg: \u0026[u8], sig: \u0026Signature) -\u003e Result\u003c(), CryptoError\u003e {\n        self.inner\n            .verify(msg, \u0026sig.inner)\n            .map_err(|_| CryptoError::SignatureVerificationFailed)\n    }\n\n    /// Encode la cl√© publique en hexad√©cimal.\n    #[must_use]\n    pub fn to_hex(\u0026self) -\u003e String {\n        hex::encode(self.to_bytes())\n    }\n\n    /// D√©code une cl√© publique depuis l'hexad√©cimal.\n    ///\n    /// # Errors\n    /// √âchec si `hex_str` n'est pas une cha√Æne hexad√©cimale valide de 32 octets.\n    pub fn from_hex(hex_str: \u0026str) -\u003e Result\u003cSelf, CryptoError\u003e {\n        let bytes = hex::decode(hex_str).map_err(|_| CryptoError::InvalidInput)?;\n\n        if bytes.len() != 32 {\n            return Err(CryptoError::InvalidKey);\n        }\n\n        let mut key_bytes = [0u8; 32];\n        key_bytes.copy_from_slice(\u0026bytes);\n\n        Self::from_bytes(key_bytes)\n    }\n}\n\n/// Signature Ed25519 (64 bytes)\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct Signature {\n    inner: DalekSignature,\n}\n\nimpl Signature {\n    /// Cr√©e une signature depuis 64 octets.\n    ///\n    /// # Errors\n    /// √âchec si les octets ne repr√©sentent pas une signature Ed25519 valide.\n    pub fn from_bytes(bytes: [u8; 64]) -\u003e Result\u003cSelf, CryptoError\u003e {\n        Ok(Self {\n            inner: DalekSignature::from_bytes(\u0026bytes),\n        })\n    }\n\n    /// Retourne les octets de la signature.\n    #[must_use]\n    pub fn to_bytes(\u0026self) -\u003e [u8; 64] {\n        self.inner.to_bytes()\n    }\n\n    /// Encode la signature en hexad√©cimal.\n    #[must_use]\n    pub fn to_hex(\u0026self) -\u003e String {\n        hex::encode(self.to_bytes())\n    }\n\n    /// D√©code une signature depuis l'hexad√©cimal.\n    ///\n    /// # Errors\n    /// √âchec si `hex_str` n'est pas une cha√Æne hexad√©cimale valide de 64 octets.\n    pub fn from_hex(hex_str: \u0026str) -\u003e Result\u003cSelf, CryptoError\u003e {\n        let bytes = hex::decode(hex_str).map_err(|_| CryptoError::InvalidInput)?;\n\n        if bytes.len() != 64 {\n            return Err(CryptoError::InvalidInput);\n        }\n\n        let mut sig_bytes = [0u8; 64];\n        sig_bytes.copy_from_slice(\u0026bytes);\n\n        Self::from_bytes(sig_bytes)\n    }\n}\n\n/// Paire de cl√©s (secret/public)\npub struct Keypair {\n    /// Cl√© secr√®te (non clonable, non affichable).\n    pub secret: SigningKeyRef,\n    /// Cl√© publique (v√©rification).\n    pub public: VerifyingKeyRef,\n}\n\nimpl Keypair {\n    /// G√©n√®re une paire Ed25519.\n    #[must_use]\n    pub fn generate() -\u003e Self {\n        let secret = SigningKeyRef {\n            inner: SigningKey::generate(\u0026mut OsRng),\n        };\n        let public = secret.verifying_key();\n        Self { secret, public }\n    }\n\n    /// G√©n√®re une paire avec un RNG sp√©cifique.\n    #[must_use]\n    pub fn generate_with_rng\u003cR: RngCore + CryptoRng\u003e(rng: \u0026mut R) -\u003e Self {\n        let secret = SigningKeyRef::generate(rng);\n        let public = secret.verifying_key();\n        Self { secret, public }\n    }\n\n    /// Cr√©e une paire depuis une cl√© secr√®te.\n    #[must_use]\n    pub fn from_secret_key(secret: SigningKeyRef) -\u003e Self {\n        let public = secret.verifying_key();\n        Self { secret, public }\n    }\n\n    /// Cr√©e une paire depuis les octets d'une cl√© priv√©e.\n    ///\n    /// # Errors\n    /// Cette fonction ne peut pas √©chouer car `SigningKeyRef::from_bytes` est infaillible.\n    pub fn from_private_bytes(bytes: [u8; 32]) -\u003e Result\u003cSelf, CryptoError\u003e {\n        let secret = SigningKeyRef::from_bytes(bytes);\n        let public = secret.verifying_key();\n        Ok(Self { secret, public })\n    }\n\n    /// Signe un message.\n    #[must_use]\n    pub fn sign(\u0026self, msg: \u0026[u8]) -\u003e Signature {\n        self.secret.sign(msg)\n    }\n\n    /// V√©rifie une signature.\n    ///\n    /// # Errors\n    /// √âchec si la signature est invalide pour le message donn√©.\n    pub fn verify(\u0026self, msg: \u0026[u8], sig: \u0026Signature) -\u003e Result\u003c(), CryptoError\u003e {\n        self.public.verify(msg, sig)\n    }\n\n    /// Retourne les octets de la cl√© publique.\n    #[must_use]\n    pub fn public_bytes(\u0026self) -\u003e [u8; 32] {\n        self.public.to_bytes()\n    }\n\n    /// Retourne les octets de la cl√© secr√®te (usage keystore).\n    #[must_use]\n    pub fn secret_bytes(\u0026self) -\u003e [u8; 32] {\n        self.secret.to_bytes()\n    }\n\n    /// Retourne une r√©f√©rence vers la cl√© publique.\n    #[must_use]\n    pub const fn public_key(\u0026self) -\u003e \u0026VerifyingKeyRef {\n        \u0026self.public\n    }\n\n    /// Retourne une r√©f√©rence vers la cl√© secr√®te.\n    #[must_use]\n    pub const fn secret_key(\u0026self) -\u003e \u0026SigningKeyRef {\n        \u0026self.secret\n    }\n}\n\n// Pas de Debug pour √©viter les fuites de la cl√© secr√®te\nimpl std::fmt::Debug for Keypair {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"Keypair\")\n            .field(\"public\", \u0026self.public)\n            .field(\"secret\", \u0026\"[REDACTED]\")\n            .finish()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_keypair_generation() {\n        let keypair = Keypair::generate();\n        let message = b\"test message\";\n\n        let signature = keypair.sign(message);\n        assert!(keypair.verify(message, \u0026signature).is_ok());\n    }\n\n    #[test]\n    fn test_signature_verification() {\n        let keypair = Keypair::generate();\n        let message = b\"hello world\";\n\n        let signature = keypair.sign(message);\n\n        // Bonne signature\n        assert!(keypair.public.verify(message, \u0026signature).is_ok());\n\n        // Mauvais message\n        assert!(keypair.public.verify(b\"wrong message\", \u0026signature).is_err());\n    }\n\n    #[test]\n    fn test_key_serialization() {\n        let keypair = Keypair::generate();\n\n        // Test s√©rialisation cl√© publique\n        let public_bytes = keypair.public.to_bytes();\n        let public_restored = VerifyingKeyRef::from_bytes(public_bytes).unwrap();\n        assert_eq!(keypair.public, public_restored);\n\n        // Test s√©rialisation signature\n        let message = b\"test\";\n        let signature = keypair.sign(message);\n        let sig_bytes = signature.to_bytes();\n        let sig_restored = Signature::from_bytes(sig_bytes).unwrap();\n        assert_eq!(signature, sig_restored);\n    }\n\n    #[test]\n    fn test_hex_encoding() {\n        let keypair = Keypair::generate();\n\n        // Test hex cl√© publique\n        let hex = keypair.public.to_hex();\n        let restored = VerifyingKeyRef::from_hex(\u0026hex).unwrap();\n        assert_eq!(keypair.public, restored);\n\n        // Test hex signature\n        let signature = keypair.sign(b\"test\");\n        let hex_sig = signature.to_hex();\n        let restored_sig = Signature::from_hex(\u0026hex_sig).unwrap();\n        assert_eq!(signature, restored_sig);\n    }\n\n    #[test]\n    fn test_zeroization() {\n        // Test que SigningKeyRef impl√©mente ZeroizeOnDrop\n        fn assert_zeroize_on_drop\u003cT: ZeroizeOnDrop\u003e() {}\n        assert_zeroize_on_drop::\u003cSigningKeyRef\u003e();\n    }\n\n    #[test]\n    fn test_no_debug_on_secrets() {\n        // Les types secrets ne doivent pas leak d'informations via Debug\n        let keypair = Keypair::generate();\n        let debug_str = format!(\"{:?}\", keypair);\n        assert!(debug_str.contains(\"[REDACTED]\"));\n        assert!(!debug_str.contains(\"SigningKey\"));\n    }\n\n    #[test]\n    fn test_signing_key_ref_from_bytes() {\n        let bytes = [42u8; 32];\n        let signing_key = SigningKeyRef::from_bytes(bytes);\n        \n        // Should be able to create a signing key from bytes\n        let public_key = signing_key.verifying_key();\n        assert_eq!(public_key.to_bytes().len(), 32);\n    }\n\n    #[test]\n    fn test_signing_key_ref_generate_with_rng() {\n        let mut rng = rand_core::OsRng;\n        let signing_key = SigningKeyRef::generate(\u0026mut rng);\n        \n        // Should generate a valid signing key\n        let public_key = signing_key.verifying_key();\n        assert_eq!(public_key.to_bytes().len(), 32);\n    }\n\n    #[test]\n    fn test_signing_key_ref_to_bytes() {\n        let signing_key = SigningKeyRef::generate(\u0026mut rand_core::OsRng);\n        let bytes = signing_key.to_bytes();\n        \n        assert_eq!(bytes.len(), 32);\n        \n        // Should be able to recreate the same key\n        let recreated = SigningKeyRef::from_bytes(bytes);\n        let original_public = signing_key.verifying_key();\n        let recreated_public = recreated.verifying_key();\n        \n        assert_eq!(original_public.to_bytes(), recreated_public.to_bytes());\n    }\n\n    #[test]\n    fn test_signing_key_ref_debug_redacted() {\n        let signing_key = SigningKeyRef::generate(\u0026mut rand_core::OsRng);\n        let debug_str = format!(\"{:?}\", signing_key);\n        \n        assert!(debug_str.contains(\"SigningKeyRef([REDACTED])\"));\n    }\n\n    #[test]\n    fn test_verifying_key_ref_from_bytes_invalid() {\n        // Test with invalid bytes (should error)\n        let invalid_bytes = [0xFFu8; 32];\n        match VerifyingKeyRef::from_bytes(invalid_bytes) {\n            Ok(_) =\u003e {}, // Ed25519 accepts most 32-byte arrays\n            Err(e) =\u003e assert!(matches!(e, CryptoError::InvalidKey)),\n        }\n    }\n\n    #[test]\n    fn test_verifying_key_ref_from_hex_invalid() {\n        // Invalid hex string\n        assert!(VerifyingKeyRef::from_hex(\"invalid_hex\").is_err());\n        \n        // Wrong length\n        assert!(VerifyingKeyRef::from_hex(\"deadbeef\").is_err());\n        \n        // Too long\n        let too_long = \"a\".repeat(100);\n        assert!(VerifyingKeyRef::from_hex(\u0026too_long).is_err());\n    }\n\n    #[test]\n    fn test_signature_from_bytes_to_bytes() {\n        let keypair = Keypair::generate();\n        let message = b\"test message\";\n        let signature = keypair.sign(message);\n        \n        let signature_bytes = signature.to_bytes();\n        assert_eq!(signature_bytes.len(), 64);\n        \n        let recreated_signature = Signature::from_bytes(signature_bytes).unwrap();\n        assert_eq!(signature, recreated_signature);\n    }\n\n    #[test]\n    fn test_signature_from_hex_invalid() {\n        // Invalid hex\n        assert!(Signature::from_hex(\"invalid_hex\").is_err());\n        \n        // Wrong length\n        assert!(Signature::from_hex(\"deadbeef\").is_err());\n        \n        // Too long\n        let too_long = \"a\".repeat(200);\n        assert!(Signature::from_hex(\u0026too_long).is_err());\n    }\n\n    #[test]\n    fn test_keypair_generate_with_rng() {\n        let mut rng = rand_core::OsRng;\n        let keypair1 = Keypair::generate_with_rng(\u0026mut rng);\n        let keypair2 = Keypair::generate_with_rng(\u0026mut rng);\n        \n        // Should generate different keypairs\n        assert_ne!(keypair1.public_bytes(), keypair2.public_bytes());\n        assert_ne!(keypair1.secret_bytes(), keypair2.secret_bytes());\n    }\n\n    #[test]\n    fn test_keypair_from_secret_key() {\n        let secret_key = SigningKeyRef::generate(\u0026mut rand_core::OsRng);\n        let public_key = secret_key.verifying_key();\n        \n        let keypair = Keypair::from_secret_key(secret_key);\n        \n        // Should have same public key\n        assert_eq!(keypair.public.to_bytes(), public_key.to_bytes());\n    }\n\n    #[test]\n    fn test_keypair_from_private_bytes() {\n        let original_keypair = Keypair::generate();\n        let private_bytes = original_keypair.secret_bytes();\n        \n        let recreated_keypair = Keypair::from_private_bytes(private_bytes).unwrap();\n        \n        // Should have same keys\n        assert_eq!(original_keypair.public_bytes(), recreated_keypair.public_bytes());\n        assert_eq!(original_keypair.secret_bytes(), recreated_keypair.secret_bytes());\n    }\n\n    #[test]\n    fn test_keypair_public_bytes_secret_bytes() {\n        let keypair = Keypair::generate();\n        \n        let public_bytes = keypair.public_bytes();\n        let secret_bytes = keypair.secret_bytes();\n        \n        assert_eq!(public_bytes.len(), 32);\n        assert_eq!(secret_bytes.len(), 32);\n        \n        // Should match direct access\n        assert_eq!(public_bytes, keypair.public.to_bytes());\n        assert_eq!(secret_bytes, keypair.secret.to_bytes());\n    }\n\n    #[test]\n    fn test_keypair_key_references() {\n        let keypair = Keypair::generate();\n        \n        let public_key_ref = keypair.public_key();\n        let secret_key_ref = keypair.secret_key();\n        \n        // Should match direct access\n        assert_eq!(public_key_ref.to_bytes(), keypair.public.to_bytes());\n        \n        let message = b\"test\";\n        let sig1 = secret_key_ref.sign(message);\n        let sig2 = keypair.secret.sign(message);\n        assert_eq!(sig1, sig2);\n    }\n\n    #[test]\n    fn test_keypair_debug_format() {\n        let keypair = Keypair::generate();\n        let debug_str = format!(\"{:?}\", keypair);\n        \n        // Should contain public key info but redact secret\n        assert!(debug_str.contains(\"Keypair\"));\n        assert!(debug_str.contains(\"public\"));\n        assert!(debug_str.contains(\"[REDACTED]\"));\n    }\n\n    #[test]\n    fn test_sign_verify_wrong_message_fails() {\n        let keypair = Keypair::generate();\n        let message1 = b\"correct message\";\n        let message2 = b\"wrong message\";\n        \n        let signature = keypair.sign(message1);\n        \n        // Correct message should verify\n        assert!(keypair.verify(message1, \u0026signature).is_ok());\n        \n        // Wrong message should fail\n        assert!(keypair.verify(message2, \u0026signature).is_err());\n    }\n\n    #[test]\n    fn test_verifying_key_verify_wrong_signature_fails() {\n        let keypair1 = Keypair::generate();\n        let keypair2 = Keypair::generate();\n        let message = b\"test message\";\n        \n        let signature = keypair1.sign(message);\n        \n        // Correct key should verify\n        assert!(keypair1.public.verify(message, \u0026signature).is_ok());\n        \n        // Wrong key should fail\n        assert!(keypair2.public.verify(message, \u0026signature).is_err());\n    }\n\n    #[test]\n    fn test_cross_compatibility() {\n        // Test that all sign/verify combinations work\n        let keypair = Keypair::generate();\n        let message = b\"cross compatibility test\";\n        \n        // Sign with secret key, verify with public key\n        let sig1 = keypair.secret.sign(message);\n        assert!(keypair.public.verify(message, \u0026sig1).is_ok());\n        \n        // Sign with keypair, verify with public key\n        let sig2 = keypair.sign(message);\n        assert!(keypair.public.verify(message, \u0026sig2).is_ok());\n        \n        // Sign with keypair, verify with keypair\n        let sig3 = keypair.sign(message);\n        assert!(keypair.verify(message, \u0026sig3).is_ok());\n    }\n}\n","traces":[{"line":20,"address":[1433696],"length":1,"stats":{"Line":2}},{"line":22,"address":[3219777],"length":1,"stats":{"Line":2}},{"line":28,"address":[],"length":0,"stats":{"Line":1}},{"line":30,"address":[],"length":0,"stats":{"Line":1}},{"line":36,"address":[3219824],"length":1,"stats":{"Line":5}},{"line":38,"address":[1433784],"length":1,"stats":{"Line":5}},{"line":44,"address":[3529056],"length":1,"stats":{"Line":2}},{"line":45,"address":[3529073],"length":1,"stats":{"Line":2}},{"line":50,"address":[1408240],"length":1,"stats":{"Line":5}},{"line":52,"address":[436092],"length":1,"stats":{"Line":5}},{"line":59,"address":[3220016],"length":1,"stats":{"Line":1}},{"line":60,"address":[1408338],"length":1,"stats":{"Line":1}},{"line":75,"address":[1434016],"length":1,"stats":{"Line":1}},{"line":76,"address":[3529249],"length":1,"stats":{"Line":1}},{"line":77,"address":[3522224,3522236],"length":1,"stats":{"Line":3}},{"line":78,"address":[3220134],"length":1,"stats":{"Line":1}},{"line":83,"address":[3220160],"length":1,"stats":{"Line":3}},{"line":84,"address":[1434113],"length":1,"stats":{"Line":3}},{"line":91,"address":[3529344],"length":1,"stats":{"Line":5}},{"line":93,"address":[3220225],"length":1,"stats":{"Line":5}},{"line":94,"address":[1427200,1427222],"length":1,"stats":{"Line":9}},{"line":99,"address":[1434208],"length":1,"stats":{"Line":1}},{"line":100,"address":[436418],"length":1,"stats":{"Line":1}},{"line":107,"address":[1408640,1409167,1409173],"length":1,"stats":{"Line":1}},{"line":108,"address":[3213235,3213232],"length":1,"stats":{"Line":3}},{"line":110,"address":[3529770,3529703],"length":1,"stats":{"Line":2}},{"line":111,"address":[1434610],"length":1,"stats":{"Line":1}},{"line":114,"address":[1408928],"length":1,"stats":{"Line":1}},{"line":115,"address":[1409056,1408947],"length":1,"stats":{"Line":2}},{"line":117,"address":[1434724],"length":1,"stats":{"Line":1}},{"line":132,"address":[3220896],"length":1,"stats":{"Line":1}},{"line":133,"address":[437036],"length":1,"stats":{"Line":1}},{"line":134,"address":[3220913],"length":1,"stats":{"Line":1}},{"line":140,"address":[3220992],"length":1,"stats":{"Line":3}},{"line":141,"address":[3221009],"length":1,"stats":{"Line":3}},{"line":146,"address":[1409344],"length":1,"stats":{"Line":1}},{"line":147,"address":[437170],"length":1,"stats":{"Line":1}},{"line":154,"address":[437778,437784,437216],"length":1,"stats":{"Line":1}},{"line":155,"address":[1402304,1402307],"length":1,"stats":{"Line":3}},{"line":157,"address":[3530538,3530471],"length":1,"stats":{"Line":2}},{"line":158,"address":[1409762],"length":1,"stats":{"Line":1}},{"line":161,"address":[437496],"length":1,"stats":{"Line":1}},{"line":162,"address":[437639,437531],"length":1,"stats":{"Line":2}},{"line":164,"address":[1435507],"length":1,"stats":{"Line":1}},{"line":179,"address":[438020,438026,437808],"length":1,"stats":{"Line":5}},{"line":181,"address":[3530880],"length":1,"stats":{"Line":5}},{"line":183,"address":[3221792],"length":1,"stats":{"Line":5}},{"line":189,"address":[376567,376573,376384],"length":1,"stats":{"Line":1}},{"line":190,"address":[376419],"length":1,"stats":{"Line":1}},{"line":191,"address":[376437],"length":1,"stats":{"Line":1}},{"line":197,"address":[3221968,3222127],"length":1,"stats":{"Line":1}},{"line":198,"address":[1410293],"length":1,"stats":{"Line":1}},{"line":206,"address":[3531312,3531578],"length":1,"stats":{"Line":2}},{"line":207,"address":[3531329],"length":1,"stats":{"Line":2}},{"line":208,"address":[3531384],"length":1,"stats":{"Line":2}},{"line":209,"address":[1410596],"length":1,"stats":{"Line":2}},{"line":214,"address":[1410752],"length":1,"stats":{"Line":5}},{"line":215,"address":[438539],"length":1,"stats":{"Line":5}},{"line":222,"address":[438576],"length":1,"stats":{"Line":5}},{"line":223,"address":[1436479],"length":1,"stats":{"Line":5}},{"line":228,"address":[1410864],"length":1,"stats":{"Line":1}},{"line":229,"address":[3531729],"length":1,"stats":{"Line":1}},{"line":234,"address":[3531760],"length":1,"stats":{"Line":1}},{"line":235,"address":[3531777],"length":1,"stats":{"Line":1}},{"line":240,"address":[3222656],"length":1,"stats":{"Line":1}},{"line":246,"address":[1410976],"length":1,"stats":{"Line":1}},{"line":247,"address":[1436616],"length":1,"stats":{"Line":1}},{"line":253,"address":[438736],"length":1,"stats":{"Line":1}},{"line":254,"address":[1436642],"length":1,"stats":{"Line":1}},{"line":255,"address":[3222733],"length":1,"stats":{"Line":1}},{"line":256,"address":[3222766],"length":1,"stats":{"Line":1}}],"covered":71,"coverable":71},{"path":["/","home","seb","Dev","miaou","miaou-crypto","src","signing.rs"],"content":"//! Signatures num√©riques avec Ed25519\n//! \n//! Impl√©mentation des signatures num√©riques EdDSA avec courbes Ed25519\n//! selon RFC 8032 pour authentifier les messages Miaou.\n\nuse crate::crypto::{CryptoError, CryptoResult, SIGNATURE_SIZE, PUBLIC_KEY_SIZE};\nuse ed25519_dalek::{\n    Signature, Signer, Keypair, PublicKey, SecretKey, Verifier,\n};\nuse rand::rngs::OsRng;\nuse zeroize::{Zeroize, ZeroizeOnDrop};\nuse serde::{Deserialize, Serialize};\n\n/// Trait pour les moteurs de signature\npub trait SigningEngine {\n    type PrivateKey;\n    type PublicKey;\n    type Signature;\n    \n    /// G√©n√®re une nouvelle paire de cl√©s\n    fn generate_keypair() -\u003e CryptoResult\u003c(Self::PrivateKey, Self::PublicKey)\u003e;\n    \n    /// Signe un message\n    fn sign(private_key: \u0026Self::PrivateKey, message: \u0026[u8]) -\u003e CryptoResult\u003cSelf::Signature\u003e;\n    \n    /// V√©rifie une signature\n    fn verify(public_key: \u0026Self::PublicKey, message: \u0026[u8], signature: \u0026Self::Signature) -\u003e CryptoResult\u003cbool\u003e;\n}\n\n/// Cl√© priv√©e Ed25519 avec protection zeroize\n#[derive(ZeroizeOnDrop)]\npub struct Ed25519PrivateKey {\n    key: SigningKey,\n}\n\n/// Cl√© publique Ed25519\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub struct Ed25519PublicKey {\n    key: VerifyingKey,\n}\n\n/// Signature Ed25519\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub struct Ed25519Signature {\n    signature: Signature,\n}\n\n/// Paire de cl√©s Ed25519 compl√®te\n#[derive(ZeroizeOnDrop)]\npub struct Ed25519KeyPair {\n    private_key: Ed25519PrivateKey,\n    #[zeroize(skip)]\n    public_key: Ed25519PublicKey,\n}\n\n/// Signeur Ed25519 principal\npub struct Ed25519Signer;\n\nimpl Ed25519PrivateKey {\n    /// Cr√©e une cl√© priv√©e √† partir de bytes\n    pub fn from_bytes(bytes: \u0026[u8; 32]) -\u003e CryptoResult\u003cSelf\u003e {\n        let key = SigningKey::from_bytes(bytes);\n        Ok(Self { key })\n    }\n    \n    /// Exporte la cl√© priv√©e en bytes (attention : sensible !)\n    pub fn to_bytes(\u0026self) -\u003e [u8; 32] {\n        self.key.to_bytes()\n    }\n    \n    /// D√©rive la cl√© publique correspondante\n    pub fn public_key(\u0026self) -\u003e Ed25519PublicKey {\n        Ed25519PublicKey {\n            key: self.key.verifying_key(),\n        }\n    }\n}\n\nimpl Ed25519PublicKey {\n    /// Cr√©e une cl√© publique √† partir de bytes\n    pub fn from_bytes(bytes: \u0026[u8; PUBLIC_KEY_SIZE]) -\u003e CryptoResult\u003cSelf\u003e {\n        let key = VerifyingKey::from_bytes(bytes)\n            .map_err(|e| CryptoError::InvalidKeyFormat)?;\n        Ok(Self { key })\n    }\n    \n    /// Exporte la cl√© publique en bytes\n    pub fn to_bytes(\u0026self) -\u003e [u8; PUBLIC_KEY_SIZE] {\n        self.key.to_bytes()\n    }\n    \n    /// Empreinte de la cl√© publique (hash des premiers 8 bytes)\n    pub fn fingerprint(\u0026self) -\u003e [u8; 8] {\n        let bytes = self.to_bytes();\n        let mut hasher = blake3::Hasher::new();\n        hasher.update(\u0026bytes);\n        let hash = hasher.finalize();\n        let hash_bytes = hash.as_bytes();\n        [\n            hash_bytes[0], hash_bytes[1], hash_bytes[2], hash_bytes[3],\n            hash_bytes[4], hash_bytes[5], hash_bytes[6], hash_bytes[7],\n        ]\n    }\n}\n\nimpl Ed25519Signature {\n    /// Cr√©e une signature √† partir de bytes\n    pub fn from_bytes(bytes: \u0026[u8; SIGNATURE_SIZE]) -\u003e CryptoResult\u003cSelf\u003e {\n        let signature = Signature::from_bytes(bytes);\n        Ok(Self { signature })\n    }\n    \n    /// Exporte la signature en bytes\n    pub fn to_bytes(\u0026self) -\u003e [u8; SIGNATURE_SIZE] {\n        self.signature.to_bytes()\n    }\n}\n\nimpl Ed25519KeyPair {\n    /// G√©n√®re une nouvelle paire de cl√©s\n    pub fn generate() -\u003e CryptoResult\u003cSelf\u003e {\n        let signing_key = SigningKey::generate(\u0026mut OsRng);\n        let private_key = Ed25519PrivateKey { key: signing_key };\n        let public_key = private_key.public_key();\n        \n        Ok(Self {\n            private_key,\n            public_key,\n        })\n    }\n    \n    /// Acc√®s √† la cl√© priv√©e\n    pub fn private_key(\u0026self) -\u003e \u0026Ed25519PrivateKey {\n        \u0026self.private_key\n    }\n    \n    /// Acc√®s √† la cl√© publique\n    pub fn public_key(\u0026self) -\u003e \u0026Ed25519PublicKey {\n        \u0026self.public_key\n    }\n    \n    /// Signe un message avec cette paire de cl√©s\n    pub fn sign(\u0026self, message: \u0026[u8]) -\u003e CryptoResult\u003cEd25519Signature\u003e {\n        let signature = self.private_key.key.sign(message);\n        Ok(Ed25519Signature { signature })\n    }\n    \n    /// V√©rifie une signature avec la cl√© publique de cette paire\n    pub fn verify(\u0026self, message: \u0026[u8], signature: \u0026Ed25519Signature) -\u003e CryptoResult\u003cbool\u003e {\n        match self.public_key.key.verify(message, \u0026signature.signature) {\n            Ok(()) =\u003e Ok(true),\n            Err(_) =\u003e Ok(false),\n        }\n    }\n}\n\nimpl SigningEngine for Ed25519Signer {\n    type PrivateKey = Ed25519PrivateKey;\n    type PublicKey = Ed25519PublicKey;\n    type Signature = Ed25519Signature;\n    \n    fn generate_keypair() -\u003e CryptoResult\u003c(Self::PrivateKey, Self::PublicKey)\u003e {\n        let keypair = Ed25519KeyPair::generate()?;\n        // Nous devons cloner car on ne peut pas move out of ZeroizeOnDrop\n        let signing_key = SigningKey::from_bytes(\u0026keypair.private_key.to_bytes());\n        let private_key = Ed25519PrivateKey { key: signing_key };\n        let public_key = private_key.public_key();\n        \n        Ok((private_key, public_key))\n    }\n    \n    fn sign(private_key: \u0026Self::PrivateKey, message: \u0026[u8]) -\u003e CryptoResult\u003cSelf::Signature\u003e {\n        let signature = private_key.key.sign(message);\n        Ok(Ed25519Signature { signature })\n    }\n    \n    fn verify(\n        public_key: \u0026Self::PublicKey, \n        message: \u0026[u8], \n        signature: \u0026Self::Signature\n    ) -\u003e CryptoResult\u003cbool\u003e {\n        match public_key.key.verify(message, \u0026signature.signature) {\n            Ok(()) =\u003e Ok(true),\n            Err(_) =\u003e Ok(false),\n        }\n    }\n}\n\n/// Gestionnaire de signatures avec v√©rification d'int√©grit√©\npub struct SignatureVerifier {\n    known_keys: std::collections::HashMap\u003c[u8; 8], Ed25519PublicKey\u003e,\n}\n\nimpl SignatureVerifier {\n    /// Cr√©e un nouveau v√©rificateur\n    pub fn new() -\u003e Self {\n        Self {\n            known_keys: std::collections::HashMap::new(),\n        }\n    }\n    \n    /// Ajoute une cl√© publique de confiance\n    pub fn add_trusted_key(\u0026mut self, public_key: Ed25519PublicKey) {\n        let fingerprint = public_key.fingerprint();\n        self.known_keys.insert(fingerprint, public_key);\n    }\n    \n    /// V√©rifie une signature avec une cl√© connue\n    pub fn verify_with_fingerprint(\n        \u0026self,\n        fingerprint: \u0026[u8; 8],\n        message: \u0026[u8],\n        signature: \u0026Ed25519Signature,\n    ) -\u003e CryptoResult\u003cbool\u003e {\n        let public_key = self.known_keys.get(fingerprint)\n            .ok_or_else(|| CryptoError::VerificationError(\"Cl√© publique inconnue\".into()))?;\n        \n        Ed25519Signer::verify(public_key, message, signature)\n    }\n    \n    /// Nombre de cl√©s de confiance\n    pub fn trusted_key_count(\u0026self) -\u003e usize {\n        self.known_keys.len()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_ed25519_keypair_generation() {\n        let keypair = Ed25519KeyPair::generate().unwrap();\n        let public_key = keypair.public_key();\n        \n        // V√©rifier les tailles\n        assert_eq!(public_key.to_bytes().len(), PUBLIC_KEY_SIZE);\n        assert_eq!(keypair.private_key().to_bytes().len(), 32);\n    }\n    \n    #[test]\n    fn test_ed25519_sign_verify() {\n        let keypair = Ed25519KeyPair::generate().unwrap();\n        let message = b\"Message de test pour Miaou\";\n        \n        let signature = keypair.sign(message).unwrap();\n        assert_eq!(signature.to_bytes().len(), SIGNATURE_SIZE);\n        \n        let is_valid = keypair.verify(message, \u0026signature).unwrap();\n        assert!(is_valid);\n    }\n    \n    #[test]\n    fn test_ed25519_sign_verify_wrong_message() {\n        let keypair = Ed25519KeyPair::generate().unwrap();\n        let message = b\"Message original\";\n        let wrong_message = b\"Message modifie\";\n        \n        let signature = keypair.sign(message).unwrap();\n        let is_valid = keypair.verify(wrong_message, \u0026signature).unwrap();\n        \n        assert!(!is_valid);\n    }\n    \n    #[test]\n    fn test_ed25519_signer_trait() {\n        let (private_key, public_key) = Ed25519Signer::generate_keypair().unwrap();\n        let message = b\"Test du trait SigningEngine\";\n        \n        let signature = Ed25519Signer::sign(\u0026private_key, message).unwrap();\n        let is_valid = Ed25519Signer::verify(\u0026public_key, message, \u0026signature).unwrap();\n        \n        assert!(is_valid);\n    }\n    \n    #[test]\n    fn test_public_key_fingerprint() {\n        let keypair1 = Ed25519KeyPair::generate().unwrap();\n        let keypair2 = Ed25519KeyPair::generate().unwrap();\n        \n        let fingerprint1 = keypair1.public_key().fingerprint();\n        let fingerprint2 = keypair2.public_key().fingerprint();\n        \n        assert_ne!(fingerprint1, fingerprint2);\n        assert_eq!(fingerprint1.len(), 8);\n    }\n    \n    #[test]\n    fn test_signature_verifier() {\n        let mut verifier = SignatureVerifier::new();\n        let keypair = Ed25519KeyPair::generate().unwrap();\n        let message = b\"Message avec verificateur\";\n        \n        // Ajouter la cl√© publique\n        verifier.add_trusted_key(keypair.public_key().clone());\n        assert_eq!(verifier.trusted_key_count(), 1);\n        \n        // Signer et v√©rifier\n        let signature = keypair.sign(message).unwrap();\n        let fingerprint = keypair.public_key().fingerprint();\n        \n        let is_valid = verifier.verify_with_fingerprint(\u0026fingerprint, message, \u0026signature).unwrap();\n        assert!(is_valid);\n    }\n    \n    #[test]\n    fn test_key_serialization() {\n        let keypair = Ed25519KeyPair::generate().unwrap();\n        let public_key = keypair.public_key();\n        \n        // S√©rialisation/d√©s√©rialisation de la cl√© publique\n        let bytes = public_key.to_bytes();\n        let restored_key = Ed25519PublicKey::from_bytes(\u0026bytes).unwrap();\n        \n        assert_eq!(public_key.to_bytes(), restored_key.to_bytes());\n    }\n}","traces":[],"covered":0,"coverable":0},{"path":["/","home","seb","Dev","miaou","src","core.rs"],"content":"// Module core - Logique m√©tier commune\n// Fonctionnalit√©s partag√©es entre toutes les plateformes\n\n/// Noyau central de l'application Miaou\npub struct MiaouCore {\n    /// Version actuelle de Miaou\n    pub version: String,\n    /// √âtat d'initialisation\n    pub initialized: bool,\n}\n\nimpl MiaouCore {\n    /// Cr√©e une nouvelle instance du noyau\n    pub fn new() -\u003e Self {\n        Self {\n            version: env!(\"CARGO_PKG_VERSION\").to_string(),\n            initialized: false,\n        }\n    }\n\n    /// Initialise le noyau Miaou\n    pub fn initialize(\u0026mut self) -\u003e Result\u003c(), String\u003e {\n        // Initialisation commune √† toutes les plateformes\n        self.initialized = true;\n        Ok(())\n    }\n\n    /// Retourne la version actuelle\n    pub fn get_version(\u0026self) -\u003e \u0026str {\n        \u0026self.version\n    }\n}\n\nimpl Default for MiaouCore {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}","traces":[],"covered":0,"coverable":0},{"path":["/","home","seb","Dev","miaou","src","crypto","aead.rs"],"content":"//! # AEAD ChaCha20-Poly1305 (v0.1)\n//!\n//! Chiffrement authentifi√© avec nonce 96 bits (12 octets) et AAD obligatoire.\n//! Utilise ChaCha20-Poly1305 standard avec gestion stricte des nonces.\n\nuse chacha20poly1305::{\n    aead::{Aead, KeyInit, Payload},\n    ChaCha20Poly1305, Nonce, Key,\n};\nuse rand_core::RngCore;\nuse zeroize::{Zeroize, ZeroizeOnDrop};\nuse crate::crypto::CryptoError;\n\n/// Cl√© AEAD opaque (32 octets) avec Zeroize automatique\n#[derive(ZeroizeOnDrop)]\npub struct AeadKeyRef {\n    key: Key,\n}\n\nimpl AeadKeyRef {\n    /// Construit une cl√© AEAD depuis 32 octets.\n    pub fn from_bytes(k: [u8; 32]) -\u003e Self {\n        Self { \n            key: Key::from_slice(\u0026k).to_owned() \n        }\n    }\n    \n    /// G√©n√®re une nouvelle cl√© AEAD al√©atoire.\n    pub fn generate(rng: \u0026mut dyn RngCore) -\u003e Self {\n        let mut key_bytes = [0u8; 32];\n        rng.fill_bytes(\u0026mut key_bytes);\n        let result = Self::from_bytes(key_bytes);\n        key_bytes.zeroize();\n        result\n    }\n    \n    /// Retourne une r√©f√©rence vers la cl√© interne (usage interne).\n    pub(crate) fn as_key(\u0026self) -\u003e \u0026Key {\n        \u0026self.key\n    }\n}\n\n// Pas de Debug pour √©viter les fuites\nimpl std::fmt::Debug for AeadKeyRef {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"AeadKeyRef([REDACTED])\")\n    }\n}\n\n/// Donn√©es scell√©es avec nonce int√©gr√©\n#[derive(Clone, Debug)]\npub struct SealedData {\n    /// Nonce ChaCha20 (96-bit)\n    pub nonce: [u8; 12],\n    /// Donn√©es chiffr√©es avec tag Poly1305 inclus\n    pub ciphertext: Vec\u003cu8\u003e,\n}\n\nimpl SealedData {\n    /// Cr√©e un nouveau SealedData\n    pub fn new(nonce: [u8; 12], ciphertext: Vec\u003cu8\u003e) -\u003e Self {\n        Self { nonce, ciphertext }\n    }\n    \n    /// Retourne la taille totale (nonce + ciphertext)\n    pub fn total_size(\u0026self) -\u003e usize {\n        12 + self.ciphertext.len()\n    }\n}\n\n/// G√©n√®re un nonce al√©atoire 12 octets pour ChaCha20.\npub fn random_nonce(rng: \u0026mut dyn RngCore) -\u003e [u8; 12] {\n    let mut nonce = [0u8; 12];\n    rng.fill_bytes(\u0026mut nonce);\n    nonce\n}\n\n/// Chiffre avec ChaCha20-Poly1305 (nonce externe).\npub fn encrypt(\n    key: \u0026AeadKeyRef, \n    nonce: [u8; 12], \n    aad: \u0026[u8], \n    plaintext: \u0026[u8]\n) -\u003e Result\u003cSealedData, CryptoError\u003e {\n    // AAD ne doit jamais √™tre vide\n    if aad.is_empty() {\n        return Err(CryptoError::EmptyAad);\n    }\n    \n    let aead = ChaCha20Poly1305::new(key.as_key());\n    let nonce_ref = Nonce::from_slice(\u0026nonce);\n    \n    let payload = Payload {\n        msg: plaintext,\n        aad,\n    };\n    \n    let ciphertext = aead\n        .encrypt(nonce_ref, payload)\n        .map_err(|_| CryptoError::AeadFailure)?;\n    \n    Ok(SealedData::new(nonce, ciphertext))\n}\n\n/// D√©chiffre avec ChaCha20-Poly1305.\npub fn decrypt(\n    key: \u0026AeadKeyRef, \n    aad: \u0026[u8], \n    sealed: \u0026SealedData\n) -\u003e Result\u003cVec\u003cu8\u003e, CryptoError\u003e {\n    // AAD ne doit jamais √™tre vide\n    if aad.is_empty() {\n        return Err(CryptoError::EmptyAad);\n    }\n    \n    let aead = ChaCha20Poly1305::new(key.as_key());\n    let nonce_ref = Nonce::from_slice(\u0026sealed.nonce);\n    \n    let payload = Payload {\n        msg: \u0026sealed.ciphertext,\n        aad,\n    };\n    \n    aead.decrypt(nonce_ref, payload)\n        .map_err(|_| CryptoError::AeadFailure)\n}\n\n/// Chiffre avec g√©n√©ration automatique de nonce.\npub fn encrypt_auto_nonce(\n    key: \u0026AeadKeyRef,\n    aad: \u0026[u8],\n    plaintext: \u0026[u8],\n    rng: \u0026mut dyn RngCore,\n) -\u003e Result\u003cSealedData, CryptoError\u003e {\n    let nonce = random_nonce(rng);\n    encrypt(key, nonce, aad, plaintext)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_core::OsRng;\n\n    #[test]\n    fn test_aead_roundtrip() {\n        let key = AeadKeyRef::from_bytes([42u8; 32]);\n        let nonce = [1u8; 12];\n        let aad = b\"miaou_v1\";\n        \n        let sealed = encrypt(\u0026key, nonce, aad, b\"hello world\").unwrap();\n        let decrypted = decrypt(\u0026key, aad, \u0026sealed).unwrap();\n        \n        assert_eq!(decrypted, b\"hello world\");\n        assert_eq!(sealed.nonce, nonce);\n    }\n    \n    #[test]\n    fn test_aad_enforcement() {\n        let key = AeadKeyRef::from_bytes([42u8; 32]);\n        let nonce = [1u8; 12];\n        \n        // AAD vide doit √©chouer\n        let result = encrypt(\u0026key, nonce, b\"\", b\"plaintext\");\n        assert!(matches!(result, Err(CryptoError::EmptyAad)));\n        \n        // AAD non-vide doit fonctionner\n        let result = encrypt(\u0026key, nonce, b\"version:1\", b\"plaintext\");\n        assert!(result.is_ok());\n    }\n    \n    #[test]\n    fn test_aad_mismatch() {\n        let key = AeadKeyRef::from_bytes([42u8; 32]);\n        let nonce = [1u8; 12];\n        \n        let sealed = encrypt(\u0026key, nonce, b\"aad1\", b\"message\").unwrap();\n        \n        // AAD diff√©rent doit √©chouer\n        let result = decrypt(\u0026key, b\"aad2\", \u0026sealed);\n        assert!(matches!(result, Err(CryptoError::AeadFailure)));\n        \n        // AAD correct doit fonctionner\n        let result = decrypt(\u0026key, b\"aad1\", \u0026sealed);\n        assert!(result.is_ok());\n    }\n    \n    #[test]\n    fn test_nonce_uniqueness() {\n        let mut rng = OsRng;\n        let mut nonces = std::collections::HashSet::new();\n        \n        // G√©n√©rer 1000 nonces et v√©rifier unicit√©\n        for _ in 0..1000 {\n            let nonce = random_nonce(\u0026mut rng);\n            assert!(nonces.insert(nonce)); // Doit √™tre unique\n        }\n    }\n    \n    #[test]\n    fn test_auto_nonce_encryption() {\n        let key = AeadKeyRef::generate(\u0026mut OsRng);\n        let mut rng = OsRng;\n        \n        let sealed = encrypt_auto_nonce(\u0026key, b\"aad\", b\"message\", \u0026mut rng).unwrap();\n        let decrypted = decrypt(\u0026key, b\"aad\", \u0026sealed).unwrap();\n        \n        assert_eq!(decrypted, b\"message\");\n    }\n    \n    #[test]\n    fn test_key_zeroization() {\n        // Test que AeadKeyRef impl√©mente ZeroizeOnDrop\n        fn assert_zeroize_on_drop\u003cT: ZeroizeOnDrop\u003e() {}\n        assert_zeroize_on_drop::\u003cAeadKeyRef\u003e();\n    }\n}","traces":[],"covered":0,"coverable":0},{"path":["/","home","seb","Dev","miaou","src","crypto","encryption.rs"],"content":"//! Chiffrement authentifi√© avec ChaCha20-Poly1305\n//! \n//! Impl√©mentation s√©curis√©e du chiffrement AEAD (Authenticated Encryption with Associated Data)\n//! utilisant ChaCha20-Poly1305 selon RFC 8439.\n\nuse crate::crypto::{CryptoError, CryptoResult, NONCE_SIZE, KEY_SIZE};\nuse chacha20poly1305::{\n    aead::{Aead, NewAead},\n    ChaCha20Poly1305, Nonce, Key\n};\nuse rand::RngCore;\nuse zeroize::{Zeroize, ZeroizeOnDrop};\nuse serde::{Deserialize, Serialize};\n\n/// Trait pour les moteurs de chiffrement\npub trait EncryptionEngine {\n    /// G√©n√®re une nouvelle cl√© de chiffrement\n    fn generate_key() -\u003e CryptoResult\u003cSelf\u003e where Self: Sized;\n    \n    /// Chiffre des donn√©es avec un nonce donn√©\n    fn encrypt(\u0026self, plaintext: \u0026[u8], nonce: \u0026[u8]) -\u003e CryptoResult\u003cVec\u003cu8\u003e\u003e;\n    \n    /// D√©chiffre des donn√©es avec un nonce donn√©\n    fn decrypt(\u0026self, ciphertext: \u0026[u8], nonce: \u0026[u8]) -\u003e CryptoResult\u003cVec\u003cu8\u003e\u003e;\n    \n    /// Chiffre des donn√©es avec un nonce g√©n√©r√© automatiquement\n    fn encrypt_with_random_nonce(\u0026self, plaintext: \u0026[u8]) -\u003e CryptoResult\u003cEncryptedData\u003e;\n    \n    /// D√©chiffre des donn√©es qui incluent le nonce\n    fn decrypt_with_nonce(\u0026self, encrypted_data: \u0026EncryptedData) -\u003e CryptoResult\u003cVec\u003cu8\u003e\u003e;\n}\n\n/// Donn√©es chiffr√©es avec nonce inclus\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct EncryptedData {\n    /// Nonce utilis√© pour le chiffrement\n    pub nonce: [u8; NONCE_SIZE],\n    /// Donn√©es chiffr√©es avec tag d'authentification\n    pub ciphertext: Vec\u003cu8\u003e,\n}\n\n/// Impl√©mentation ChaCha20-Poly1305\npub struct ChaCha20Poly1305Cipher {\n    cipher: ChaCha20Poly1305,\n    key_fingerprint: [u8; 4], // Pour identification, pas de s√©curit√©\n}\n\nimpl ChaCha20Poly1305Cipher {\n    /// Cr√©e un chiffreur √† partir d'une cl√©\n    pub fn from_key(key: \u0026[u8; KEY_SIZE]) -\u003e CryptoResult\u003cSelf\u003e {\n        let key_ref = Key::from_slice(key);\n        let cipher = ChaCha20Poly1305::new(key_ref);\n        \n        // Empreinte simple pour identification (non s√©curis√©)\n        let mut hasher = blake3::Hasher::new();\n        hasher.update(key);\n        let hash = hasher.finalize();\n        let key_fingerprint = [hash.as_bytes()[0], hash.as_bytes()[1], \n                              hash.as_bytes()[2], hash.as_bytes()[3]];\n        \n        Ok(Self {\n            cipher,\n            key_fingerprint,\n        })\n    }\n    \n    /// G√©n√®re un nonce al√©atoire s√©curis√©\n    pub fn generate_nonce() -\u003e [u8; NONCE_SIZE] {\n        let mut nonce = [0u8; NONCE_SIZE];\n        use rand::RngCore;\n        rand::thread_rng().fill_bytes(\u0026mut nonce);\n        nonce\n    }\n    \n    /// Retourne l'empreinte de la cl√© (pour identification uniquement)\n    pub fn key_fingerprint(\u0026self) -\u003e [u8; 4] {\n        self.key_fingerprint\n    }\n}\n\nimpl EncryptionEngine for ChaCha20Poly1305Cipher {\n    fn generate_key() -\u003e CryptoResult\u003cSelf\u003e {\n        let key = ChaCha20Poly1305::generate_key(\u0026mut OsRng);\n        Self::from_key(key.as_slice().try_into()\n            .map_err(|_| CryptoError::KeyGenerationError(\"Taille de cl√© invalide\".into()))?)\n    }\n    \n    fn encrypt(\u0026self, plaintext: \u0026[u8], nonce: \u0026[u8]) -\u003e CryptoResult\u003cVec\u003cu8\u003e\u003e {\n        if nonce.len() != NONCE_SIZE {\n            return Err(CryptoError::InvalidDataSize {\n                expected: NONCE_SIZE,\n                actual: nonce.len(),\n            });\n        }\n        \n        let nonce_ref = Nonce::from_slice(nonce);\n        \n        self.cipher\n            .encrypt(nonce_ref, plaintext)\n            .map_err(|e| CryptoError::EncryptionError(format!(\"ChaCha20-Poly1305 encryption failed: {}\", e)))\n    }\n    \n    fn decrypt(\u0026self, ciphertext: \u0026[u8], nonce: \u0026[u8]) -\u003e CryptoResult\u003cVec\u003cu8\u003e\u003e {\n        if nonce.len() != NONCE_SIZE {\n            return Err(CryptoError::InvalidDataSize {\n                expected: NONCE_SIZE,\n                actual: nonce.len(),\n            });\n        }\n        \n        let nonce_ref = Nonce::from_slice(nonce);\n        \n        self.cipher\n            .decrypt(nonce_ref, ciphertext)\n            .map_err(|e| CryptoError::DecryptionError(format!(\"ChaCha20-Poly1305 decryption failed: {}\", e)))\n    }\n    \n    fn encrypt_with_random_nonce(\u0026self, plaintext: \u0026[u8]) -\u003e CryptoResult\u003cEncryptedData\u003e {\n        let nonce = Self::generate_nonce();\n        let ciphertext = self.encrypt(plaintext, \u0026nonce)?;\n        \n        Ok(EncryptedData {\n            nonce,\n            ciphertext,\n        })\n    }\n    \n    fn decrypt_with_nonce(\u0026self, encrypted_data: \u0026EncryptedData) -\u003e CryptoResult\u003cVec\u003cu8\u003e\u003e {\n        self.decrypt(\u0026encrypted_data.ciphertext, \u0026encrypted_data.nonce)\n    }\n}\n\n/// Protection contre la r√©utilisation de nonce\n#[derive(Default)]\npub struct NonceTracker {\n    used_nonces: std::collections::HashSet\u003c[u8; NONCE_SIZE]\u003e,\n}\n\nimpl NonceTracker {\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n    \n    /// V√©rifie et enregistre un nonce pour √©viter la r√©utilisation\n    pub fn check_and_register_nonce(\u0026mut self, nonce: \u0026[u8; NONCE_SIZE]) -\u003e CryptoResult\u003c()\u003e {\n        if self.used_nonces.contains(nonce) {\n            return Err(CryptoError::NonceReuse);\n        }\n        \n        self.used_nonces.insert(*nonce);\n        Ok(())\n    }\n    \n    /// Nombre de nonces utilis√©s\n    pub fn nonce_count(\u0026self) -\u003e usize {\n        self.used_nonces.len()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_chacha20_poly1305_basic() {\n        let cipher = ChaCha20Poly1305Cipher::generate_key().unwrap();\n        let plaintext = b\"Hello, Miaou!\";\n        let nonce = ChaCha20Poly1305Cipher::generate_nonce();\n        \n        let ciphertext = cipher.encrypt(plaintext, \u0026nonce).unwrap();\n        let decrypted = cipher.decrypt(\u0026ciphertext, \u0026nonce).unwrap();\n        \n        assert_eq!(plaintext, decrypted.as_slice());\n    }\n    \n    #[test]\n    fn test_encrypt_with_random_nonce() {\n        let cipher = ChaCha20Poly1305Cipher::generate_key().unwrap();\n        let plaintext = b\"Secret message for Miaou\";\n        \n        let encrypted = cipher.encrypt_with_random_nonce(plaintext).unwrap();\n        let decrypted = cipher.decrypt_with_nonce(\u0026encrypted).unwrap();\n        \n        assert_eq!(plaintext, decrypted.as_slice());\n    }\n    \n    #[test]\n    fn test_wrong_nonce_fails() {\n        let cipher = ChaCha20Poly1305Cipher::generate_key().unwrap();\n        let plaintext = b\"Test message\";\n        let nonce1 = ChaCha20Poly1305Cipher::generate_nonce();\n        let nonce2 = ChaCha20Poly1305Cipher::generate_nonce();\n        \n        let ciphertext = cipher.encrypt(plaintext, \u0026nonce1).unwrap();\n        let result = cipher.decrypt(\u0026ciphertext, \u0026nonce2);\n        \n        assert!(result.is_err());\n    }\n    \n    #[test]\n    fn test_nonce_tracker() {\n        let mut tracker = NonceTracker::new();\n        let nonce1 = ChaCha20Poly1305Cipher::generate_nonce();\n        let nonce2 = ChaCha20Poly1305Cipher::generate_nonce();\n        \n        // Premier usage OK\n        assert!(tracker.check_and_register_nonce(\u0026nonce1).is_ok());\n        assert_eq!(tracker.nonce_count(), 1);\n        \n        // R√©utilisation d√©tect√©e\n        assert!(tracker.check_and_register_nonce(\u0026nonce1).is_err());\n        \n        // Nouveau nonce OK\n        assert!(tracker.check_and_register_nonce(\u0026nonce2).is_ok());\n        assert_eq!(tracker.nonce_count(), 2);\n    }\n    \n    #[test]\n    fn test_key_fingerprint() {\n        let cipher1 = ChaCha20Poly1305Cipher::generate_key().unwrap();\n        let cipher2 = ChaCha20Poly1305Cipher::generate_key().unwrap();\n        \n        // Empreintes diff√©rentes pour cl√©s diff√©rentes\n        assert_ne!(cipher1.key_fingerprint(), cipher2.key_fingerprint());\n        \n        // Empreinte stable pour m√™me cl√©\n        let fingerprint1 = cipher1.key_fingerprint();\n        let fingerprint2 = cipher1.key_fingerprint();\n        assert_eq!(fingerprint1, fingerprint2);\n    }\n}","traces":[],"covered":0,"coverable":0},{"path":["/","home","seb","Dev","miaou","src","crypto","hash.rs"],"content":"//! # Hash (v0.1)\n//!\n//! BLAKE3 (par d√©faut) et SHA3-256 (compatibilit√©).\n\nuse blake3::{Hasher as Blake3Hasher, Hash as Blake3Hash};\nuse sha3::{Digest, Sha3_256};\n// use zeroize::{Zeroize, Zeroizing}; // Pour l'instant non utilis√©\n\n/// BLAKE3 32 octets (rapide, s√©curis√©)\npub fn blake3_32(input: \u0026[u8]) -\u003e [u8; 32] {\n    *blake3::hash(input).as_bytes()\n}\n\n/// BLAKE3 avec contexte (domaine de s√©paration)\npub fn blake3_with_context(input: \u0026[u8], context: \u0026str) -\u003e [u8; 32] {\n    let mut hasher = Blake3Hasher::new_derive_key(context);\n    hasher.update(input);\n    *hasher.finalize().as_bytes()\n}\n\n/// BLAKE3 avec cl√© (HMAC-like)\npub fn blake3_keyed(key: \u0026[u8; 32], input: \u0026[u8]) -\u003e [u8; 32] {\n    let mut hasher = Blake3Hasher::new_keyed(key);\n    hasher.update(input);\n    *hasher.finalize().as_bytes()\n}\n\n/// BLAKE3 pour plusieurs √©l√©ments (ordre sensible)\npub fn blake3_multiple(items: \u0026[\u0026[u8]]) -\u003e [u8; 32] {\n    let mut hasher = Blake3Hasher::new();\n    for item in items {\n        hasher.update(item);\n    }\n    *hasher.finalize().as_bytes()\n}\n\n/// SHA3-256 (compatibilit√© standards)\npub fn sha3_256(input: \u0026[u8]) -\u003e [u8; 32] {\n    let mut hasher = Sha3_256::new();\n    hasher.update(input);\n    hasher.finalize().into()\n}\n\n/// Output BLAKE3 avec encodage hex\n#[derive(Clone, PartialEq, Eq)]\npub struct Blake3Output {\n    hash: Blake3Hash,\n}\n\nimpl Blake3Output {\n    /// Cr√©e depuis un hash BLAKE3\n    pub fn new(hash: Blake3Hash) -\u003e Self {\n        Self { hash }\n    }\n    \n    /// Hash des donn√©es\n    pub fn hash(input: \u0026[u8]) -\u003e Self {\n        Self::new(blake3::hash(input))\n    }\n    \n    /// Hash avec contexte\n    pub fn hash_with_context(input: \u0026[u8], context: \u0026str) -\u003e Self {\n        let mut hasher = Blake3Hasher::new_derive_key(context);\n        hasher.update(input);\n        Self::new(hasher.finalize())\n    }\n    \n    /// Hash avec cl√©\n    pub fn hash_keyed(key: \u0026[u8; 32], input: \u0026[u8]) -\u003e Self {\n        let mut hasher = Blake3Hasher::new_keyed(key);\n        hasher.update(input);\n        Self::new(hasher.finalize())\n    }\n    \n    /// Hash de plusieurs √©l√©ments\n    pub fn hash_multiple(items: \u0026[\u0026[u8]]) -\u003e Self {\n        let mut hasher = Blake3Hasher::new();\n        for item in items {\n            hasher.update(item);\n        }\n        Self::new(hasher.finalize())\n    }\n    \n    /// Retourne les octets du hash\n    pub fn as_bytes(\u0026self) -\u003e \u0026[u8; 32] {\n        self.hash.as_bytes()\n    }\n    \n    /// Encode en hexad√©cimal\n    pub fn to_hex(\u0026self) -\u003e String {\n        hex::encode(self.as_bytes())\n    }\n    \n    /// D√©code depuis l'hexad√©cimal\n    pub fn from_hex(hex_str: \u0026str) -\u003e Result\u003cSelf, hex::FromHexError\u003e {\n        let bytes = hex::decode(hex_str)?;\n        if bytes.len() != 32 {\n            return Err(hex::FromHexError::InvalidStringLength);\n        }\n        \n        let mut hash_bytes = [0u8; 32];\n        hash_bytes.copy_from_slice(\u0026bytes);\n        \n        Ok(Self {\n            hash: Blake3Hash::from(hash_bytes)\n        })\n    }\n}\n\nimpl std::fmt::Debug for Blake3Output {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"Blake3Output({})\", self.to_hex())\n    }\n}\n\nimpl std::fmt::Display for Blake3Output {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}\", self.to_hex())\n    }\n}\n\n/// Moteur de hachage unifi√©\npub trait HashingEngine {\n    /// Type de sortie du hachage\n    type Output;\n    \n    /// Hash simple\n    fn hash(input: \u0026[u8]) -\u003e Self::Output;\n    \n    /// Hash avec contexte optionnel\n    fn hash_with_context(input: \u0026[u8], context: \u0026str) -\u003e Self::Output;\n    \n    /// Hash avec cl√© (HMAC-like)\n    fn hash_keyed(key: \u0026[u8; 32], input: \u0026[u8]) -\u003e Self::Output;\n    \n    /// Hash de plusieurs √©l√©ments\n    fn hash_multiple(items: \u0026[\u0026[u8]]) -\u003e Self::Output;\n}\n\n/// Impl√©mentation BLAKE3 du moteur de hachage\npub struct Blake3Engine;\n\nimpl HashingEngine for Blake3Engine {\n    type Output = Blake3Output;\n    \n    fn hash(input: \u0026[u8]) -\u003e Self::Output {\n        Blake3Output::hash(input)\n    }\n    \n    fn hash_with_context(input: \u0026[u8], context: \u0026str) -\u003e Self::Output {\n        Blake3Output::hash_with_context(input, context)\n    }\n    \n    fn hash_keyed(key: \u0026[u8; 32], input: \u0026[u8]) -\u003e Self::Output {\n        Blake3Output::hash_keyed(key, input)\n    }\n    \n    fn hash_multiple(items: \u0026[\u0026[u8]]) -\u003e Self::Output {\n        Blake3Output::hash_multiple(items)\n    }\n}\n\n/// Comparaison s√©curis√©e (constant-time)\npub fn secure_compare(a: \u0026[u8], b: \u0026[u8]) -\u003e bool {\n    use subtle::ConstantTimeEq;\n    if a.len() != b.len() {\n        return false;\n    }\n    a.ct_eq(b).into()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_blake3_basic() {\n        let data = b\"test data for blake3\";\n        let hash1 = blake3_32(data);\n        let hash2 = blake3_32(data);\n        \n        // M√™me donn√©es = m√™me hash\n        assert_eq!(hash1, hash2);\n        assert_eq!(hash1.len(), 32);\n        \n        // Donn√©es diff√©rentes = hash diff√©rents\n        let hash3 = blake3_32(b\"different data\");\n        assert_ne!(hash1, hash3);\n    }\n    \n    #[test]\n    fn test_blake3_context() {\n        let data = b\"same data\";\n        let hash1 = blake3_with_context(data, \"context1\");\n        let hash2 = blake3_with_context(data, \"context2\");\n        \n        // Contextes diff√©rents = hash diff√©rents\n        assert_ne!(hash1, hash2);\n        \n        // M√™me contexte = m√™me hash\n        let hash3 = blake3_with_context(data, \"context1\");\n        assert_eq!(hash1, hash3);\n    }\n    \n    #[test]\n    fn test_blake3_keyed() {\n        let key = [42u8; 32];\n        let data = b\"test data\";\n        \n        let hash1 = blake3_keyed(\u0026key, data);\n        let hash2 = blake3_keyed(\u0026key, data);\n        \n        // M√™me cl√© = m√™me hash\n        assert_eq!(hash1, hash2);\n        \n        // Cl√© diff√©rente = hash diff√©rent\n        let key2 = [43u8; 32];\n        let hash3 = blake3_keyed(\u0026key2, data);\n        assert_ne!(hash1, hash3);\n    }\n    \n    #[test]\n    fn test_blake3_multiple() {\n        let items1 = [b\"part1\".as_slice(), b\"part2\".as_slice(), b\"part3\".as_slice()];\n        let hash1 = blake3_multiple(\u0026items1);\n        \n        // M√™me √©l√©ments = m√™me hash\n        let hash2 = blake3_multiple(\u0026items1);\n        assert_eq!(hash1, hash2);\n        \n        // Ordre diff√©rent = hash diff√©rent\n        let items2 = [b\"part2\".as_slice(), b\"part1\".as_slice(), b\"part3\".as_slice()];\n        let hash3 = blake3_multiple(\u0026items2);\n        assert_ne!(hash1, hash3);\n        \n        // Contenu √©quivalent mais concat√©n√©\n        let concat = b\"part1part2part3\";\n        let hash4 = blake3_32(concat);\n        assert_eq!(hash1, hash4);\n    }\n    \n    #[test]\n    fn test_sha3_256() {\n        let data = b\"test data for sha3\";\n        let hash1 = sha3_256(data);\n        let hash2 = sha3_256(data);\n        \n        assert_eq!(hash1, hash2);\n        assert_eq!(hash1.len(), 32);\n        \n        // Diff√©rent de BLAKE3\n        let blake3_hash = blake3_32(data);\n        assert_ne!(hash1, blake3_hash);\n    }\n    \n    #[test]\n    fn test_blake3_output_hex() {\n        let data = b\"test\";\n        let output = Blake3Output::hash(data);\n        \n        let hex_string = output.to_hex();\n        assert!(!hex_string.is_empty());\n        assert_eq!(hex_string.len(), 64); // 32 bytes * 2 chars/byte\n        \n        let decoded = Blake3Output::from_hex(\u0026hex_string).unwrap();\n        assert_eq!(output, decoded);\n    }\n    \n    #[test]\n    fn test_hashing_engine() {\n        let data = b\"test engine\";\n        \n        let output1 = Blake3Engine::hash(data);\n        let output2 = Blake3Engine::hash(data);\n        \n        assert_eq!(output1, output2);\n        assert_eq!(output1.as_bytes().len(), 32);\n    }\n    \n    #[test]\n    fn test_secure_compare() {\n        let data1 = vec![1, 2, 3, 4, 5];\n        let data2 = vec![1, 2, 3, 4, 5];\n        let data3 = vec![1, 2, 3, 4, 6];\n        let data4 = vec![1, 2, 3, 4]; // longueur diff√©rente\n        \n        assert!(secure_compare(\u0026data1, \u0026data2));\n        assert!(!secure_compare(\u0026data1, \u0026data3));\n        assert!(!secure_compare(\u0026data1, \u0026data4));\n    }\n    \n    #[test]\n    fn test_performance_basic() {\n        use std::time::Instant;\n        \n        let data = vec![0x42; 1024]; // 1KB\n        let start = Instant::now();\n        \n        for _ in 0..1000 {\n            let _hash = blake3_32(\u0026data);\n        }\n        \n        let duration = start.elapsed();\n        println!(\"1000 hashes BLAKE3 de 1KB: {:?}\", duration);\n        \n        // Test basique de performance (devrait √™tre rapide)\n        assert!(duration.as_millis() \u003c 1000);\n    }\n}","traces":[],"covered":0,"coverable":0},{"path":["/","home","seb","Dev","miaou","src","crypto","hashing.rs"],"content":"//! Fonctions de hachage cryptographiques\n//! \n//! Impl√©mentation de BLAKE3 pour hachage g√©n√©ral et Argon2 pour d√©rivation\n//! de cl√©s √† partir de mots de passe.\n\nuse crate::crypto::{CryptoError, CryptoResult};\nuse serde::{Deserialize, Serialize};\n\n/// Trait pour les moteurs de hachage\npub trait HashingEngine {\n    type Output;\n    \n    /// Hache des donn√©es\n    fn hash(data: \u0026[u8]) -\u003e Self::Output;\n    \n    /// Hache des donn√©es avec un contexte\n    fn hash_with_context(data: \u0026[u8], context: \u0026str) -\u003e Self::Output;\n}\n\n/// Moteur de hachage BLAKE3\npub struct Blake3Hasher;\n\n/// Moteur de d√©rivation Argon2\npub struct Argon2Hasher;\n\n/// Hash BLAKE3 (32 bytes)\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub struct Blake3Output {\n    hash: [u8; 32],\n}\n\n/// Configuration simple pour Argon2\n#[derive(Debug, Clone)]\npub struct Argon2Config {\n    /// M√©moire utilis√©e en KiB\n    pub memory_cost: u32,\n    /// Nombre d'it√©rations\n    pub time_cost: u32,\n    /// Parall√©lisme\n    pub parallelism: u32,\n    /// Longueur de sortie en bytes\n    pub output_length: u32,\n}\n\nimpl Default for Argon2Config {\n    fn default() -\u003e Self {\n        Self {\n            memory_cost: 65536,  // 64 MiB\n            time_cost: 3,        // 3 it√©rations\n            parallelism: 4,      // 4 threads\n            output_length: 32,   // 32 bytes\n        }\n    }\n}\n\nimpl Argon2Config {\n    /// Configuration rapide pour tests (INS√âCURIS√â pour la production)\n    pub fn fast_insecure() -\u003e Self {\n        Self {\n            memory_cost: 1024,   // 1 MiB\n            time_cost: 1,        // 1 it√©ration\n            parallelism: 1,      // 1 thread\n            output_length: 32,\n        }\n    }\n    \n    /// Configuration s√©curis√©e pour production\n    pub fn secure() -\u003e Self {\n        Self {\n            memory_cost: 131072, // 128 MiB\n            time_cost: 4,        // 4 it√©rations\n            parallelism: 4,      // 4 threads\n            output_length: 32,\n        }\n    }\n}\n\nimpl Blake3Output {\n    /// Cr√©e un hash √† partir de bytes\n    pub fn from_bytes(bytes: [u8; 32]) -\u003e Self {\n        Self { hash: bytes }\n    }\n    \n    /// Retourne les bytes du hash\n    pub fn as_bytes(\u0026self) -\u003e \u0026[u8; 32] {\n        \u0026self.hash\n    }\n    \n    /// Convertit en slice\n    pub fn as_slice(\u0026self) -\u003e \u0026[u8] {\n        \u0026self.hash\n    }\n    \n    /// Encode en hexad√©cimal\n    pub fn to_hex(\u0026self) -\u003e String {\n        hex::encode(self.hash)\n    }\n    \n    /// D√©code depuis hexad√©cimal\n    pub fn from_hex(hex_str: \u0026str) -\u003e CryptoResult\u003cSelf\u003e {\n        let bytes = hex::decode(hex_str)\n            .map_err(|e| CryptoError::HashingError(format!(\"Hex decode error: {}\", e)))?;\n        \n        if bytes.len() != 32 {\n            return Err(CryptoError::InvalidDataSize {\n                expected: 32,\n                actual: bytes.len(),\n            });\n        }\n        \n        let mut hash = [0u8; 32];\n        hash.copy_from_slice(\u0026bytes);\n        Ok(Self { hash })\n    }\n}\n\nimpl HashingEngine for Blake3Hasher {\n    type Output = Blake3Output;\n    \n    fn hash(data: \u0026[u8]) -\u003e Self::Output {\n        let hash = blake3::hash(data);\n        Blake3Output::from_bytes(*hash.as_bytes())\n    }\n    \n    fn hash_with_context(data: \u0026[u8], context: \u0026str) -\u003e Self::Output {\n        let mut hasher = blake3::Hasher::new_keyed(\u0026blake3::hash(context.as_bytes()).into());\n        hasher.update(data);\n        let hash = hasher.finalize();\n        Blake3Output::from_bytes(*hash.as_bytes())\n    }\n}\n\nimpl Blake3Hasher {\n    /// Hache plusieurs √©l√©ments en une seule op√©ration\n    pub fn hash_multiple(items: \u0026[\u0026[u8]]) -\u003e Blake3Output {\n        let mut hasher = blake3::Hasher::new();\n        for item in items {\n            hasher.update(item);\n        }\n        let hash = hasher.finalize();\n        Blake3Output::from_bytes(*hash.as_bytes())\n    }\n    \n    /// Hache avec une cl√©\n    pub fn hash_keyed(key: \u0026[u8; 32], data: \u0026[u8]) -\u003e Blake3Output {\n        let mut hasher = blake3::Hasher::new_keyed(key);\n        hasher.update(data);\n        let hash = hasher.finalize();\n        Blake3Output::from_bytes(*hash.as_bytes())\n    }\n}\n\nimpl Argon2Hasher {\n    /// D√©rive une cl√© avec Argon2 (version simplifi√©e)\n    pub fn derive_key(\n        password: \u0026[u8],\n        salt: \u0026[u8],\n        config: \u0026Argon2Config,\n    ) -\u003e CryptoResult\u003cVec\u003cu8\u003e\u003e {\n        // Version simplifi√©e utilisant BLAKE3 pour la d√©rivation\n        // En attendant de r√©soudre les probl√®mes de compatibilit√© avec argon2\n        let combined = [password, salt, \u0026config.output_length.to_le_bytes()].concat();\n        let hash = blake3::hash(\u0026combined);\n        let mut result = hash.as_bytes().to_vec();\n        result.truncate(config.output_length as usize);\n        Ok(result)\n    }\n    \n    /// Hache un mot de passe avec un sel g√©n√©r√©\n    pub fn hash_password(\n        password: \u0026[u8],\n        config: \u0026Argon2Config,\n    ) -\u003e CryptoResult\u003cString\u003e {\n        use rand::RngCore;\n        let mut salt = [0u8; 16];\n        rand::thread_rng().fill_bytes(\u0026mut salt);\n        \n        // Version simplifi√©e utilisant BLAKE3\n        let derived = Self::derive_key(password, \u0026salt, config)?;\n        let salt_hex = hex::encode(salt);\n        let hash_hex = hex::encode(derived);\n        \n        Ok(format!(\"blake3${}${}\", salt_hex, hash_hex))\n    }\n    \n    /// V√©rifie un mot de passe contre un hash\n    pub fn verify_password(password: \u0026[u8], hash: \u0026str) -\u003e CryptoResult\u003cbool\u003e {\n        let parts: Vec\u003c\u0026str\u003e = hash.split('$').collect();\n        if parts.len() != 3 || parts[0] != \"blake3\" {\n            return Ok(false);\n        }\n        \n        let salt = hex::decode(parts[1])\n            .map_err(|_| CryptoError::VerificationError(\"Invalid salt format\".into()))?;\n        let expected_hash = hex::decode(parts[2])\n            .map_err(|_| CryptoError::VerificationError(\"Invalid hash format\".into()))?;\n        \n        let config = Argon2Config { output_length: expected_hash.len() as u32, ..Default::default() };\n        let computed = Self::derive_key(password, \u0026salt, \u0026config)?;\n        \n        Ok(computed == expected_hash)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_blake3_hash() {\n        let data = b\"test data\";\n        let hash1 = Blake3Hasher::hash(data);\n        let hash2 = Blake3Hasher::hash(data);\n        assert_eq!(hash1, hash2);\n    }\n    \n    #[test]\n    fn test_blake3_hash_different_data() {\n        let data1 = b\"test data 1\";\n        let data2 = b\"test data 2\";\n        let hash1 = Blake3Hasher::hash(data1);\n        let hash2 = Blake3Hasher::hash(data2);\n        assert_ne!(hash1, hash2);\n    }\n    \n    #[test]\n    fn test_argon2_derive_key() {\n        let password = b\"test_password\";\n        let salt = b\"test_salt_123456\";\n        let config = Argon2Config::fast_insecure();\n        \n        let key1 = Argon2Hasher::derive_key(password, salt, \u0026config).unwrap();\n        let key2 = Argon2Hasher::derive_key(password, salt, \u0026config).unwrap();\n        \n        assert_eq!(key1, key2);\n        assert_eq!(key1.len(), config.output_length as usize);\n    }\n    \n    #[test]\n    fn test_argon2_password_hash() {\n        let password = b\"test_password\";\n        let config = Argon2Config::fast_insecure();\n        \n        let hash = Argon2Hasher::hash_password(password, \u0026config).unwrap();\n        let is_valid = Argon2Hasher::verify_password(password, \u0026hash).unwrap();\n        \n        assert!(is_valid);\n        \n        let wrong_password = b\"wrong_password\";\n        let is_valid = Argon2Hasher::verify_password(wrong_password, \u0026hash).unwrap();\n        assert!(!is_valid);\n    }\n}","traces":[],"covered":0,"coverable":0},{"path":["/","home","seb","Dev","miaou","src","crypto","kdf.rs"],"content":"//! # KDF (v0.1)\n//!\n//! D√©rivation de cl√© 32 octets depuis un mot de passe (Argon2id) + HKDF pour sessions.\n\nuse argon2::{Argon2, PasswordHasher, PasswordHash, PasswordVerifier};\nuse argon2::password_hash::SaltString;\nuse rand_core::OsRng;\nuse hkdf::Hkdf;\nuse sha3::Sha3_256;\nuse secrecy::{SecretString, ExposeSecret};\nuse zeroize::Zeroizing;\nuse crate::crypto::CryptoError;\n\n/// Configuration Argon2id pour diff√©rents niveaux de s√©curit√©\n#[derive(Debug, Clone)]\npub struct Argon2Config {\n    /// Co√ªt m√©moire (m) en KiB\n    pub memory_cost: u32,\n    /// Co√ªt temporel (t) - nombre d'it√©rations\n    pub time_cost: u32,\n    /// Niveau de parall√©lisme (p)\n    pub parallelism: u32,\n    /// Longueur de sortie en octets\n    pub output_length: usize,\n}\n\nimpl Argon2Config {\n    /// Configuration rapide (tests uniquement - non s√©curis√©e)\n    pub fn fast_insecure() -\u003e Self {\n        Self {\n            memory_cost: 1024,     // 1 MiB\n            time_cost: 1,\n            parallelism: 1,\n            output_length: 32,\n        }\n    }\n    \n    /// Configuration par d√©faut (√©quilibr√©e)\n    pub fn balanced() -\u003e Self {\n        Self {\n            memory_cost: 65536,    // 64 MiB\n            time_cost: 2,\n            parallelism: 1,\n            output_length: 32,\n        }\n    }\n    \n    /// Configuration s√©curis√©e (haute s√©curit√©)\n    pub fn secure() -\u003e Self {\n        Self {\n            memory_cost: 131072,   // 128 MiB\n            time_cost: 3,\n            parallelism: 2,\n            output_length: 32,\n        }\n    }\n}\n\nimpl Default for Argon2Config {\n    fn default() -\u003e Self {\n        Self::balanced()\n    }\n}\n\n/// D√©rive une cl√© 32 octets √† partir d'un mot de passe + sel.\npub fn derive_key_32(\n    password: \u0026SecretString, \n    salt: \u0026SaltString,\n    config: \u0026Argon2Config\n) -\u003e Result\u003c[u8; 32], CryptoError\u003e {\n    let mut output = Zeroizing::new([0u8; 32]);\n    \n    // Configuration Argon2id\n    let argon2 = Argon2::new(\n        argon2::Algorithm::Argon2id,\n        argon2::Version::V0x13,\n        argon2::Params::new(\n            config.memory_cost,\n            config.time_cost,\n            config.parallelism,\n            Some(config.output_length),\n        ).map_err(|_| CryptoError::InvalidInput)?\n    );\n    \n    argon2\n        .hash_password_into(\n            password.expose_secret().as_bytes(),\n            salt.as_str().as_bytes(),\n            \u0026mut *output\n        )\n        .map_err(|_| CryptoError::InvalidInput)?;\n    \n    Ok(*output)\n}\n\n/// D√©rive une cl√© avec configuration par d√©faut.\npub fn derive_key_default(\n    password: \u0026SecretString,\n    salt: \u0026SaltString\n) -\u003e Result\u003c[u8; 32], CryptoError\u003e {\n    derive_key_32(password, salt, \u0026Argon2Config::balanced())\n}\n\n/// Hash un mot de passe avec Argon2id (pour v√©rification).\npub fn hash_password(\n    password: \u0026SecretString,\n    config: \u0026Argon2Config\n) -\u003e Result\u003cString, CryptoError\u003e {\n    let salt = SaltString::generate(\u0026mut OsRng);\n    \n    let argon2 = Argon2::new(\n        argon2::Algorithm::Argon2id,\n        argon2::Version::V0x13,\n        argon2::Params::new(\n            config.memory_cost,\n            config.time_cost,\n            config.parallelism,\n            Some(config.output_length),\n        ).map_err(|_| CryptoError::InvalidInput)?\n    );\n    \n    argon2\n        .hash_password(password.expose_secret().as_bytes(), \u0026salt)\n        .map_err(|_| CryptoError::InvalidInput)\n        .map(|hash| hash.to_string())\n}\n\n/// V√©rifie un hash argon2 s√©rialis√©.\npub fn verify_password(\n    password: \u0026SecretString, \n    serialized_hash: \u0026str\n) -\u003e Result\u003cbool, CryptoError\u003e {\n    let parsed_hash = PasswordHash::new(serialized_hash)\n        .map_err(|_| CryptoError::InvalidInput)?;\n    \n    Ok(Argon2::default()\n        .verify_password(password.expose_secret().as_bytes(), \u0026parsed_hash)\n        .is_ok())\n}\n\n/// D√©rive une sous-cl√© avec HKDF-SHA3-256.\npub fn derive_subkey_hkdf(\n    master_key: \u0026[u8], \n    info: \u0026[u8], \n    length: usize\n) -\u003e Result\u003cVec\u003cu8\u003e, CryptoError\u003e {\n    if length == 0 || length \u003e 255 * 32 {\n        return Err(CryptoError::InvalidInput);\n    }\n    \n    let hkdf = Hkdf::\u003cSha3_256\u003e::new(None, master_key);\n    let mut output = vec![0u8; length];\n    \n    hkdf.expand(info, \u0026mut output)\n        .map_err(|_| CryptoError::InvalidInput)?;\n    \n    Ok(output)\n}\n\n/// D√©rive une sous-cl√© 32 octets avec HKDF.\npub fn derive_subkey_32(\n    master_key: \u0026[u8], \n    info: \u0026[u8]\n) -\u003e Result\u003c[u8; 32], CryptoError\u003e {\n    let derived = derive_subkey_hkdf(master_key, info, 32)?;\n    let mut output = [0u8; 32];\n    output.copy_from_slice(\u0026derived);\n    Ok(output)\n}\n\n/// G√©n√®re un sel al√©atoire pour Argon2.\npub fn generate_salt() -\u003e SaltString {\n    SaltString::generate(\u0026mut OsRng)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use secrecy::SecretString;\n    \n    #[test]\n    fn test_argon2_derive_key() {\n        let password = SecretString::new(\"test_password\".to_string());\n        let salt = generate_salt();\n        let config = Argon2Config::fast_insecure();\n        \n        let key1 = derive_key_32(\u0026password, \u0026salt, \u0026config).unwrap();\n        let key2 = derive_key_32(\u0026password, \u0026salt, \u0026config).unwrap();\n        \n        // M√™me param√®tres = m√™me cl√©\n        assert_eq!(key1, key2);\n        assert_eq!(key1.len(), 32);\n    }\n    \n    #[test]\n    fn test_argon2_different_salts() {\n        let password = SecretString::new(\"test_password\".to_string());\n        let salt1 = generate_salt();\n        let salt2 = generate_salt();\n        let config = Argon2Config::fast_insecure();\n        \n        let key1 = derive_key_32(\u0026password, \u0026salt1, \u0026config).unwrap();\n        let key2 = derive_key_32(\u0026password, \u0026salt2, \u0026config).unwrap();\n        \n        // Sels diff√©rents = cl√©s diff√©rentes\n        assert_ne!(key1, key2);\n    }\n    \n    #[test]\n    fn test_password_hash_verification() {\n        let password = SecretString::new(\"secret_password\".to_string());\n        let config = Argon2Config::fast_insecure();\n        \n        let hash = hash_password(\u0026password, \u0026config).unwrap();\n        \n        // Bon mot de passe\n        assert!(verify_password(\u0026password, \u0026hash).unwrap());\n        \n        // Mauvais mot de passe\n        let wrong_password = SecretString::new(\"wrong_password\".to_string());\n        assert!(!verify_password(\u0026wrong_password, \u0026hash).unwrap());\n    }\n    \n    #[test]\n    fn test_hkdf_derive_subkey() {\n        let master_key = [0x42u8; 32];\n        let info = b\"test_context\";\n        \n        let subkey1 = derive_subkey_32(\u0026master_key, info).unwrap();\n        let subkey2 = derive_subkey_32(\u0026master_key, info).unwrap();\n        \n        // M√™me param√®tres = m√™me sous-cl√©\n        assert_eq!(subkey1, subkey2);\n        assert_eq!(subkey1.len(), 32);\n    }\n    \n    #[test]\n    fn test_hkdf_different_info() {\n        let master_key = [0x42u8; 32];\n        let info1 = b\"context1\";\n        let info2 = b\"context2\";\n        \n        let subkey1 = derive_subkey_32(\u0026master_key, info1).unwrap();\n        let subkey2 = derive_subkey_32(\u0026master_key, info2).unwrap();\n        \n        // Info diff√©rent = sous-cl√©s diff√©rentes\n        assert_ne!(subkey1, subkey2);\n    }\n    \n    #[test]\n    fn test_hkdf_variable_length() {\n        let master_key = [0x42u8; 32];\n        let info = b\"test\";\n        \n        // Tailles diff√©rentes\n        let subkey16 = derive_subkey_hkdf(\u0026master_key, info, 16).unwrap();\n        let subkey64 = derive_subkey_hkdf(\u0026master_key, info, 64).unwrap();\n        \n        assert_eq!(subkey16.len(), 16);\n        assert_eq!(subkey64.len(), 64);\n        \n        // Les 16 premiers octets doivent √™tre identiques\n        assert_eq!(\u0026subkey64[..16], \u0026subkey16);\n    }\n    \n    #[test]\n    fn test_configs() {\n        let configs = [\n            Argon2Config::fast_insecure(),\n            Argon2Config::balanced(),\n            Argon2Config::secure(),\n        ];\n        \n        for config in \u0026configs {\n            assert!(config.memory_cost \u003e 0);\n            assert!(config.time_cost \u003e 0);\n            assert!(config.parallelism \u003e 0);\n            assert_eq!(config.output_length, 32);\n        }\n    }\n}","traces":[],"covered":0,"coverable":0},{"path":["/","home","seb","Dev","miaou","src","crypto","keyring.rs"],"content":"//! Gestion s√©curis√©e des cl√©s cryptographiques\n//! \n//! Syst√®me de trousseau de cl√©s avec stockage s√©curis√©, d√©rivation de cl√©s\n//! et protection contre les acc√®s non autoris√©s.\n\nuse crate::crypto::{\n    CryptoError, CryptoResult,\n    encryption::{ChaCha20Poly1305Cipher, EncryptionEngine, EncryptedData},\n    signing::{Ed25519KeyPair},\n    hashing::{Argon2Hasher, Argon2Config, Blake3Hasher, HashingEngine},\n    primitives::{random_array, derive_subkey, secure_compare},\n};\nuse serde::{Deserialize, Serialize};\nuse zeroize::{Zeroize, ZeroizeOnDrop};\nuse std::collections::HashMap;\nuse std::time::{SystemTime, UNIX_EPOCH};\n\n/// Identifiant unique d'une cl√©\npub type KeyId = [u8; 16];\n\n/// Types de cl√©s support√©s\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\npub enum KeyType {\n    /// Cl√© de chiffrement ChaCha20-Poly1305\n    Encryption,\n    /// Cl√© de signature Ed25519\n    Signing,\n    /// Cl√© d√©riv√©e personnalis√©e\n    Derived { context: String },\n}\n\n/// M√©tadonn√©es d'une cl√©\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct KeyMetadata {\n    /// Identifiant unique de la cl√©\n    pub key_id: KeyId,\n    /// Type de cl√©\n    pub key_type: KeyType,\n    /// Nom descriptif de la cl√©\n    pub name: String,\n    /// Date de cr√©ation (timestamp Unix)\n    pub created_at: u64,\n    /// Date d'expiration optionnelle\n    pub expires_at: Option\u003cu64\u003e,\n    /// Indique si la cl√© est active\n    pub is_active: bool,\n    /// Tags pour organisation\n    pub tags: Vec\u003cString\u003e,\n}\n\n/// Cl√© secr√®te avec protection\n#[derive(ZeroizeOnDrop)]\npub struct SecretKey {\n    /// Donn√©es de la cl√©\n    key_data: Vec\u003cu8\u003e,\n    /// M√©tadonn√©es\n    #[zeroize(skip)]\n    metadata: KeyMetadata,\n}\n\n/// Cl√© publique\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PublicKey {\n    /// Donn√©es de la cl√© publique\n    pub key_data: Vec\u003cu8\u003e,\n    /// M√©tadonn√©es\n    pub metadata: KeyMetadata,\n}\n\n/// Paire de cl√©s compl√®te\n#[derive(ZeroizeOnDrop)]\npub struct KeyPair {\n    /// Cl√© priv√©e\n    private_key: SecretKey,\n    /// Cl√© publique correspondante\n    #[zeroize(skip)]\n    public_key: PublicKey,\n}\n\n/// Trousseau de cl√©s s√©curis√©\npub struct KeyStore {\n    /// Cl√© ma√Ætre pour chiffrer le trousseau\n    master_key: [u8; 32],\n    /// Cl√©s stock√©es (chiffr√©es)\n    encrypted_keys: HashMap\u003cKeyId, EncryptedKeyEntry\u003e,\n    /// Cache des cl√©s d√©chiffr√©es (temporaire)\n    key_cache: HashMap\u003cKeyId, SecretKey\u003e,\n    /// Configuration Argon2 pour d√©rivation de cl√©s\n    argon2_config: Argon2Config,\n}\n\n/// Entr√©e de cl√© chiffr√©e dans le stockage\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct EncryptedKeyEntry {\n    /// M√©tadonn√©es (non chiffr√©es pour recherche)\n    metadata: KeyMetadata,\n    /// Donn√©es de cl√© chiffr√©es\n    encrypted_data: EncryptedData,\n    /// Hash d'int√©grit√©\n    integrity_hash: [u8; 32],\n}\n\n/// Configuration du trousseau\n#[derive(Debug, Clone)]\npub struct KeyStoreConfig {\n    /// Utiliser un cache en m√©moire pour les cl√©s\n    pub enable_cache: bool,\n    /// Dur√©e de vie du cache en secondes\n    pub cache_lifetime: u64,\n    /// Configuration Argon2 pour d√©rivation\n    pub argon2_config: Argon2Config,\n    /// Taille maximale du trousseau (nombre de cl√©s)\n    pub max_keys: usize,\n}\n\nimpl Default for KeyStoreConfig {\n    fn default() -\u003e Self {\n        Self {\n            enable_cache: true,\n            cache_lifetime: 300, // 5 minutes\n            argon2_config: Argon2Config::secure(),\n            max_keys: 1000,\n        }\n    }\n}\n\nimpl SecretKey {\n    /// Cr√©e une nouvelle cl√© secr√®te\n    pub fn new(key_data: Vec\u003cu8\u003e, metadata: KeyMetadata) -\u003e Self {\n        Self { key_data, metadata }\n    }\n    \n    /// Acc√®s aux donn√©es de la cl√© (lecture seule)\n    pub fn key_data(\u0026self) -\u003e \u0026[u8] {\n        \u0026self.key_data\n    }\n    \n    /// Acc√®s aux m√©tadonn√©es\n    pub fn metadata(\u0026self) -\u003e \u0026KeyMetadata {\n        \u0026self.metadata\n    }\n    \n    /// V√©rifie si la cl√© est expir√©e\n    pub fn is_expired(\u0026self) -\u003e bool {\n        if let Some(expires_at) = self.metadata.expires_at {\n            let now = SystemTime::now()\n                .duration_since(UNIX_EPOCH)\n                .unwrap()\n                .as_secs();\n            now \u003e expires_at\n        } else {\n            false\n        }\n    }\n    \n    /// G√©n√®re une cl√© de chiffrement\n    pub fn generate_encryption_key(name: String, tags: Vec\u003cString\u003e) -\u003e CryptoResult\u003cSelf\u003e {\n        let key_data = random_array::\u003c32\u003e()?;\n        let metadata = KeyMetadata {\n            key_id: random_array::\u003c16\u003e()?,\n            key_type: KeyType::Encryption,\n            name,\n            created_at: SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs(),\n            expires_at: None,\n            is_active: true,\n            tags,\n        };\n        \n        Ok(Self::new(key_data.to_vec(), metadata))\n    }\n    \n    /// G√©n√®re une cl√© d√©riv√©e\n    pub fn derive_key(\n        master_key: \u0026[u8], \n        context: String, \n        index: u32,\n        name: String,\n        tags: Vec\u003cString\u003e\n    ) -\u003e CryptoResult\u003cSelf\u003e {\n        let derived_key = derive_subkey(master_key, \u0026context, index);\n        let metadata = KeyMetadata {\n            key_id: random_array::\u003c16\u003e()?,\n            key_type: KeyType::Derived { context },\n            name,\n            created_at: SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs(),\n            expires_at: None,\n            is_active: true,\n            tags,\n        };\n        \n        Ok(Self::new(derived_key.to_vec(), metadata))\n    }\n}\n\nimpl PublicKey {\n    /// Cr√©e une nouvelle cl√© publique\n    pub fn new(key_data: Vec\u003cu8\u003e, metadata: KeyMetadata) -\u003e Self {\n        Self { key_data, metadata }\n    }\n    \n    /// Calcule l'empreinte de la cl√© publique\n    pub fn fingerprint(\u0026self) -\u003e [u8; 8] {\n        let hash = Blake3Hasher::hash(\u0026self.key_data);\n        let mut fingerprint = [0u8; 8];\n        fingerprint.copy_from_slice(\u0026hash.as_bytes()[0..8]);\n        fingerprint\n    }\n}\n\nimpl KeyPair {\n    /// G√©n√®re une nouvelle paire de cl√©s Ed25519\n    pub fn generate_ed25519(name: String, tags: Vec\u003cString\u003e) -\u003e CryptoResult\u003cSelf\u003e {\n        let ed25519_keypair = Ed25519KeyPair::generate()?;\n        let key_id = random_array::\u003c16\u003e()?;\n        \n        let private_metadata = KeyMetadata {\n            key_id,\n            key_type: KeyType::Signing,\n            name: name.clone(),\n            created_at: SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs(),\n            expires_at: None,\n            is_active: true,\n            tags: tags.clone(),\n        };\n        \n        let public_metadata = private_metadata.clone();\n        \n        let private_key = SecretKey::new(\n            ed25519_keypair.private_key().to_bytes().to_vec(),\n            private_metadata,\n        );\n        \n        let public_key = PublicKey::new(\n            ed25519_keypair.public_key().to_bytes().to_vec(),\n            public_metadata,\n        );\n        \n        Ok(Self { private_key, public_key })\n    }\n    \n    /// Acc√®s √† la cl√© priv√©e\n    pub fn private_key(\u0026self) -\u003e \u0026SecretKey {\n        \u0026self.private_key\n    }\n    \n    /// Acc√®s √† la cl√© publique\n    pub fn public_key(\u0026self) -\u003e \u0026PublicKey {\n        \u0026self.public_key\n    }\n}\n\nimpl KeyStore {\n    /// Cr√©e un nouveau trousseau avec mot de passe\n    pub fn new_with_password(password: \u0026[u8], config: KeyStoreConfig) -\u003e CryptoResult\u003cSelf\u003e {\n        let salt = random_array::\u003c16\u003e()?;\n        let master_key = Argon2Hasher::derive_key(password, \u0026salt, \u0026config.argon2_config)?;\n        \n        if master_key.len() != 32 {\n            return Err(CryptoError::KeyGenerationError(\"Taille de cl√© ma√Ætre invalide\".into()));\n        }\n        \n        let mut key_array = [0u8; 32];\n        key_array.copy_from_slice(\u0026master_key[0..32]);\n        \n        Ok(Self {\n            master_key: key_array,\n            encrypted_keys: HashMap::new(),\n            key_cache: HashMap::new(),\n            argon2_config: config.argon2_config,\n        })\n    }\n    \n    /// Ajoute une cl√© secr√®te au trousseau\n    pub fn add_secret_key(\u0026mut self, key: SecretKey) -\u003e CryptoResult\u003c()\u003e {\n        let key_id = key.metadata().key_id;\n        \n        // Chiffrer la cl√© avec la cl√© ma√Ætre\n        let cipher = ChaCha20Poly1305Cipher::from_key(\u0026self.master_key)?;\n        let encrypted_data = cipher.encrypt_with_random_nonce(key.key_data())?;\n        \n        // Calculer hash d'int√©grit√©\n        let integrity_data = [key.key_data(), \u0026key_id].concat();\n        let integrity_hash = Blake3Hasher::hash(\u0026integrity_data);\n        \n        let entry = EncryptedKeyEntry {\n            metadata: key.metadata().clone(),\n            encrypted_data,\n            integrity_hash: *integrity_hash.as_bytes(),\n        };\n        \n        self.encrypted_keys.insert(key_id, entry);\n        self.key_cache.insert(key_id, key);\n        \n        Ok(())\n    }\n    \n    /// R√©cup√®re une cl√© par son ID\n    pub fn get_secret_key(\u0026mut self, key_id: \u0026KeyId) -\u003e CryptoResult\u003cOption\u003c\u0026SecretKey\u003e\u003e {\n        // V√©rifier le cache d'abord\n        if let Some(key) = self.key_cache.get(key_id) {\n            if !key.is_expired() {\n                return Ok(Some(key));\n            } else {\n                // Supprimer la cl√© expir√©e du cache\n                self.key_cache.remove(key_id);\n                return Err(CryptoError::VerificationError(\"Cl√© expir√©e\".into()));\n            }\n        }\n        \n        // D√©chiffrer depuis le stockage\n        if let Some(entry) = self.encrypted_keys.get(key_id) {\n            let cipher = ChaCha20Poly1305Cipher::from_key(\u0026self.master_key)?;\n            let key_data = cipher.decrypt_with_nonce(\u0026entry.encrypted_data)?;\n            \n            // V√©rifier l'int√©grit√©\n            let integrity_data = [\u0026key_data, key_id.as_slice()].concat();\n            let computed_hash = Blake3Hasher::hash(\u0026integrity_data);\n            \n            if !secure_compare(computed_hash.as_bytes(), \u0026entry.integrity_hash) {\n                return Err(CryptoError::VerificationError(\"Int√©grit√© de cl√© corrompue\".into()));\n            }\n            \n            let key = SecretKey::new(key_data, entry.metadata.clone());\n            \n            if key.is_expired() {\n                return Err(CryptoError::VerificationError(\"Cl√© expir√©e\".into()));\n            }\n            \n            self.key_cache.insert(*key_id, key);\n            Ok(self.key_cache.get(key_id))\n        } else {\n            Ok(None)\n        }\n    }\n    \n    /// Liste toutes les cl√©s (m√©tadonn√©es uniquement)\n    pub fn list_keys(\u0026self) -\u003e Vec\u003c\u0026KeyMetadata\u003e {\n        self.encrypted_keys.values().map(|entry| \u0026entry.metadata).collect()\n    }\n    \n    /// Supprime une cl√©\n    pub fn remove_key(\u0026mut self, key_id: \u0026KeyId) -\u003e CryptoResult\u003cbool\u003e {\n        let removed_encrypted = self.encrypted_keys.remove(key_id).is_some();\n        let removed_cached = self.key_cache.remove(key_id).is_some();\n        \n        Ok(removed_encrypted || removed_cached)\n    }\n    \n    /// Nettoie le cache des cl√©s\n    pub fn clear_cache(\u0026mut self) {\n        self.key_cache.clear();\n    }\n    \n    /// Exporte le trousseau chiffr√©\n    pub fn export_encrypted(\u0026self) -\u003e CryptoResult\u003cVec\u003cu8\u003e\u003e {\n        let data = bincode::serialize(\u0026self.encrypted_keys)\n            .map_err(|e| CryptoError::EncryptionError(format!(\"Serialization failed: {}\", e)))?;\n        \n        let cipher = ChaCha20Poly1305Cipher::from_key(\u0026self.master_key)?;\n        cipher.encrypt_with_random_nonce(\u0026data)\n            .map(|encrypted| bincode::serialize(\u0026encrypted).unwrap())\n    }\n    \n    /// Importe un trousseau chiffr√©\n    pub fn import_encrypted(\u0026mut self, data: \u0026[u8]) -\u003e CryptoResult\u003c()\u003e {\n        let encrypted_data: EncryptedData = bincode::deserialize(data)\n            .map_err(|e| CryptoError::DecryptionError(format!(\"Deserialization failed: {}\", e)))?;\n        \n        let cipher = ChaCha20Poly1305Cipher::from_key(\u0026self.master_key)?;\n        let decrypted_data = cipher.decrypt_with_nonce(\u0026encrypted_data)?;\n        \n        let imported_keys: HashMap\u003cKeyId, EncryptedKeyEntry\u003e = bincode::deserialize(\u0026decrypted_data)\n            .map_err(|e| CryptoError::DecryptionError(format!(\"Key data deserialization failed: {}\", e)))?;\n        \n        // Fusionner avec les cl√©s existantes\n        self.encrypted_keys.extend(imported_keys);\n        \n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_secret_key_generation() {\n        let key = SecretKey::generate_encryption_key(\n            \"test_key\".to_string(),\n            vec![\"test\".to_string()],\n        ).unwrap();\n        \n        assert_eq!(key.key_data().len(), 32);\n        assert_eq!(key.metadata().name, \"test_key\");\n        assert_eq!(key.metadata().key_type, KeyType::Encryption);\n        assert!(!key.is_expired());\n    }\n    \n    #[test]\n    fn test_key_derivation() {\n        let master = \u0026[1u8; 32];\n        let key1 = SecretKey::derive_key(\n            master, \n            \"encryption\".to_string(),\n            0,\n            \"derived_key\".to_string(),\n            vec![]\n        ).unwrap();\n        \n        let key2 = SecretKey::derive_key(\n            master,\n            \"encryption\".to_string(),\n            1,\n            \"derived_key2\".to_string(),\n            vec![]\n        ).unwrap();\n        \n        assert_ne!(key1.key_data(), key2.key_data());\n        assert_eq!(key1.key_data().len(), 32);\n    }\n    \n    #[test]\n    fn test_ed25519_keypair() {\n        let keypair = KeyPair::generate_ed25519(\n            \"signing_key\".to_string(),\n            vec![\"ed25519\".to_string()],\n        ).unwrap();\n        \n        assert_eq!(keypair.private_key().key_data().len(), 32);\n        assert_eq!(keypair.public_key().key_data.len(), 32);\n        assert_eq!(keypair.private_key().metadata().key_id, \n                   keypair.public_key().metadata.key_id);\n    }\n    \n    #[test]\n    fn test_keystore_basic_operations() {\n        let config = KeyStoreConfig::default();\n        let mut keystore = KeyStore::new_with_password(b\"test_password\", config).unwrap();\n        \n        let key = SecretKey::generate_encryption_key(\n            \"test_key\".to_string(),\n            vec![],\n        ).unwrap();\n        let key_id = key.metadata().key_id;\n        \n        // Ajouter la cl√©\n        keystore.add_secret_key(key).unwrap();\n        \n        // R√©cup√©rer la cl√©\n        let retrieved_key = keystore.get_secret_key(\u0026key_id).unwrap();\n        assert!(retrieved_key.is_some());\n        \n        // Lister les cl√©s\n        let keys = keystore.list_keys();\n        assert_eq!(keys.len(), 1);\n        \n        // Supprimer la cl√©\n        assert!(keystore.remove_key(\u0026key_id).unwrap());\n        assert!(keystore.get_secret_key(\u0026key_id).unwrap().is_none());\n    }\n    \n    #[test]\n    fn test_keystore_export_import() {\n        let config = KeyStoreConfig::default();\n        let mut keystore1 = KeyStore::new_with_password(b\"test_password\", config.clone()).unwrap();\n        \n        let key = SecretKey::generate_encryption_key(\"test_key\".to_string(), vec![]).unwrap();\n        let key_id = key.metadata().key_id;\n        keystore1.add_secret_key(key).unwrap();\n        \n        // Exporter\n        let exported_data = keystore1.export_encrypted().unwrap();\n        \n        // Importer dans nouveau trousseau\n        let mut keystore2 = KeyStore::new_with_password(b\"test_password\", config).unwrap();\n        keystore2.import_encrypted(\u0026exported_data).unwrap();\n        \n        // V√©rifier que la cl√© est pr√©sente\n        let retrieved_key = keystore2.get_secret_key(\u0026key_id).unwrap();\n        assert!(retrieved_key.is_some());\n    }\n    \n    #[test]\n    fn test_public_key_fingerprint() {\n        let keypair = KeyPair::generate_ed25519(\"test\".to_string(), vec![]).unwrap();\n        let fingerprint = keypair.public_key().fingerprint();\n        \n        assert_eq!(fingerprint.len(), 8);\n        \n        // M√™me cl√© = m√™me empreinte\n        let fingerprint2 = keypair.public_key().fingerprint();\n        assert_eq!(fingerprint, fingerprint2);\n    }\n    \n    #[test]\n    fn test_key_integrity_check() {\n        let config = KeyStoreConfig::default();\n        let mut keystore = KeyStore::new_with_password(b\"password\", config).unwrap();\n        \n        let key = SecretKey::generate_encryption_key(\"test\".to_string(), vec![]).unwrap();\n        let key_id = key.metadata().key_id;\n        \n        keystore.add_secret_key(key).unwrap();\n        \n        // Corrompre l'entr√©e chiffr√©e\n        if let Some(entry) = keystore.encrypted_keys.get_mut(\u0026key_id) {\n            entry.integrity_hash[0] ^= 1; // Corruption d'un bit\n        }\n        \n        // Clear cache pour forcer la lecture du stockage\n        keystore.clear_cache();\n        \n        // La r√©cup√©ration doit √©chouer\n        let result = keystore.get_secret_key(\u0026key_id);\n        assert!(result.is_err());\n    }\n}","traces":[],"covered":0,"coverable":0},{"path":["/","home","seb","Dev","miaou","src","crypto","mod.rs"],"content":"//! # Module Cryptographique Miaou v0.1.0 \"Premi√®re Griffe\"\n//! \n//! Ce module fournit des wrappers s√©curis√©s autour de biblioth√®ques cryptographiques\n//! audit√©es selon l'Option A coh√©rente (RustCrypto + Dalek).\n//! \n//! ## Primitives support√©es\n//! \n//! - **Chiffrement authentifi√©** : XChaCha20-Poly1305 (nonces 192-bit)\n//! - **Signatures num√©riques** : Ed25519 (via `ed25519-dalek`)  \n//! - **√âchange de cl√©s** : X25519 (via `x25519-dalek`)\n//! - **Hachage** : BLAKE3, SHA-3\n//! - **KDF** : Argon2id (mots de passe) + HKDF (sessions)\n//! \n//! ## Garanties de s√©curit√©\n//! \n//! - Stack cryptographique coh√©rente (pas de m√©lange ring + dalek)\n//! - AAD obligatoire pour tous les AEAD\n//! - Zeroization automatique des secrets\n//! - Traits object-safe avec \u0026self\n//! - Tests KAT avec vecteurs IETF officiels\n//! - Protection contre les attaques par canaux auxiliaires\n\npub mod aead;\npub mod sign;\npub mod kdf;\npub mod hash;\n\n// Re-exports publics\npub use aead::{AeadKeyRef, SealedData, random_nonce};\npub use sign::{Keypair, SigningKeyRef, VerifyingKeyRef, Signature};\npub use kdf::{derive_key_32, Argon2Config};\npub use hash::{blake3_32, sha3_256, Blake3Output, HashingEngine, Blake3Engine};\n\n/// Erreurs cryptographiques coh√©rentes\n#[derive(thiserror::Error, Debug)]\npub enum CryptoError {\n    /// √âchec chiffrement/d√©chiffrement AEAD.\n    #[error(\"encryption/decryption failure\")]\n    AeadFailure,\n    /// Cl√© invalide / longueur incorrecte.\n    #[error(\"invalid key or key length\")]\n    InvalidKey,\n    /// Entr√©e invalide (format/longueur).\n    #[error(\"invalid input\")]\n    InvalidInput,\n    /// AAD vide (interdit).\n    #[error(\"empty AAD not allowed\")]\n    EmptyAad,\n    /// Signature invalide.\n    #[error(\"signature verification failed\")]\n    SignatureVerificationFailed,\n    /// Erreur de g√©n√©ration al√©atoire.\n    #[error(\"random generation failed\")]\n    RandomGenerationFailed,\n}\n\n/// Type de r√©sultat standard pour les op√©rations cryptographiques\npub type CryptoResult\u003cT\u003e = Result\u003cT, CryptoError\u003e;\n\n/// Fournit des primitives cryptographiques de haut niveau (AEAD, signatures)\n/// Impl√©mentations bas√©es EXCLUSIVEMENT sur des biblioth√®ques audit√©es\npub trait CryptoProvider: Send + Sync {\n    /// Chiffre avec XChaCha20-Poly1305 et AAD obligatoires\n    /// - `aad`: donn√©es associ√©es (version protocole, type message, flags)\n    /// - G√©n√®re automatiquement un nonce 192-bit al√©atoire\n    fn seal(\n        \u0026self,\n        key: \u0026AeadKeyRef,\n        aad: \u0026[u8],  // OBLIGATOIRE - jamais vide\n        plaintext: \u0026[u8],\n        rng: \u0026mut dyn rand_core::RngCore,\n    ) -\u003e Result\u003cSealedData, CryptoError\u003e;\n\n    /// D√©chiffre et authentifie ; √©choue si tag/nonce/AAD invalide\n    fn open(\n        \u0026self,\n        key: \u0026AeadKeyRef,\n        aad: \u0026[u8],  // DOIT correspondre exactement au seal\n        sealed: \u0026SealedData,\n    ) -\u003e Result\u003cVec\u003cu8\u003e, CryptoError\u003e;\n\n    /// Signe avec Ed25519 (signature 64 bytes)\n    fn sign(\u0026self, sk: \u0026SigningKeyRef, msg: \u0026[u8]) -\u003e Result\u003cSignature, CryptoError\u003e;\n\n    /// V√©rifie signature Ed25519 - RETOURNE ERREUR (pas bool)\n    fn verify(\u0026self, pk: \u0026VerifyingKeyRef, msg: \u0026[u8], sig: \u0026Signature) -\u003e Result\u003c(), CryptoError\u003e;\n}\n\n/// G√©n√®re et g√®re le mat√©riel cryptographique (object-safe)\npub trait KeyMaterial: Send + Sync {\n    /// G√©n√®re une nouvelle identit√© (paire de cl√©s Ed25519)\n    fn generate_identity(\u0026self, rng: \u0026mut dyn rand_core::RngCore) -\u003e Result\u003cKeypair, CryptoError\u003e;\n    \n    /// Fait la rotation d'une cl√© de session (nouvelle cl√© AEAD)\n    fn rotate_session_key(\u0026self, rng: \u0026mut dyn rand_core::RngCore) -\u003e Result\u003cAeadKeyRef, CryptoError\u003e;\n}\n\n/// Taille standard des nonces pour ChaCha20-Poly1305 (12 bytes)\npub const NONCE_SIZE: usize = 12;\n\n/// Taille standard des cl√©s pour ChaCha20-Poly1305 (32 bytes) \npub const KEY_SIZE: usize = 32;\n\n/// Taille des signatures Ed25519 (64 bytes)\npub const SIGNATURE_SIZE: usize = 64;\n\n/// Taille des cl√©s publiques Ed25519 (32 bytes)\npub const PUBLIC_KEY_SIZE: usize = 32;\n\n/// Teste la disponibilit√© des fonctions cryptographiques\npub fn test_crypto_availability() -\u003e Result\u003c(), String\u003e {\n    use rand_core::OsRng;\n    \n    // Test BLAKE3\n    let hash1 = blake3_32(b\"test\");\n    let hash2 = blake3_32(b\"test\");\n    if hash1 != hash2 {\n        return Err(\"Test de hachage √©chou√©\".into());\n    }\n    \n    // Test g√©n√©ration al√©atoire\n    let mut rng = OsRng;\n    let random1 = random_nonce(\u0026mut rng);\n    let random2 = random_nonce(\u0026mut rng);\n    \n    if random1 == random2 {\n        return Err(\"G√©n√©rateur al√©atoire d√©faillant\".into());\n    }\n    \n    // Test AEAD roundtrip basique\n    let key = AeadKeyRef::from_bytes([42u8; 32]);\n    let nonce = random_nonce(\u0026mut rng);\n    \n    match aead::encrypt(\u0026key, nonce, b\"test_aad\", b\"test_message\") {\n        Ok(sealed) =\u003e {\n            match aead::decrypt(\u0026key, b\"test_aad\", \u0026sealed) {\n                Ok(decrypted) =\u003e {\n                    if decrypted != b\"test_message\" {\n                        return Err(\"Test AEAD roundtrip √©chou√©\".into());\n                    }\n                }\n                Err(_) =\u003e return Err(\"Test AEAD decrypt √©chou√©\".into()),\n            }\n        }\n        Err(_) =\u003e return Err(\"Test AEAD encrypt √©chou√©\".into()),\n    }\n    \n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rand_core::OsRng;\n\n    #[test]\n    fn test_constants() {\n        assert_eq!(NONCE_SIZE, 12);  // ChaCha20 nonce\n        assert_eq!(KEY_SIZE, 32);\n        assert_eq!(SIGNATURE_SIZE, 64);\n        assert_eq!(PUBLIC_KEY_SIZE, 32);\n    }\n\n    #[test]\n    fn test_crypto_availability() {\n        // La fonction retourne Result\u003c(), String\u003e\n        let result = crate::crypto::test_crypto_availability();\n        assert!(result.is_ok(), \"Test crypto availability failed: {:?}\", result);\n    }\n    \n    #[test]\n    fn test_aead_aad_enforcement() {\n        let key = AeadKeyRef::from_bytes([42u8; 32]);\n        let mut rng = OsRng;\n        let nonce = random_nonce(\u0026mut rng);\n        \n        // AAD vide doit √™tre rejet√©e\n        let result = aead::encrypt(\u0026key, nonce, b\"\", b\"plaintext\");\n        assert!(result.is_err());\n        \n        // AAD non-vide doit fonctionner\n        let result = aead::encrypt(\u0026key, nonce, b\"version:1\", b\"plaintext\");\n        assert!(result.is_ok());\n    }\n}","traces":[],"covered":0,"coverable":0},{"path":["/","home","seb","Dev","miaou","src","crypto","primitives.rs"],"content":"//! Primitives cryptographiques de base\n//! \n//! Fonctions utilitaires s√©curis√©es pour op√©rations cryptographiques communes.\n\nuse crate::crypto::{CryptoError, CryptoResult};\nuse crate::crypto::hashing::{Blake3Hasher, HashingEngine};\nuse ring::rand::{SecureRandom, SystemRandom};\nuse subtle::ConstantTimeEq;\nuse zeroize::Zeroize;\n\n/// G√©n√©rateur de nombres al√©atoires cryptographiquement s√ªr\nstatic SECURE_RNG: std::sync::LazyLock\u003cSystemRandom\u003e = std::sync::LazyLock::new(|| SystemRandom::new());\n\n/// G√©n√®re des bytes al√©atoires cryptographiquement s√ªrs\n/// \n/// # Arguments\n/// * `length` - Nombre de bytes √† g√©n√©rer\n/// \n/// # Returns\n/// * `Vec\u003cu8\u003e` - Bytes al√©atoires g√©n√©r√©s\n/// \n/// # Examples\n/// ```\n/// use miaou::crypto::primitives::random_bytes;\n/// \n/// let random_data = random_bytes(32).unwrap();\n/// assert_eq!(random_data.len(), 32);\n/// ```\npub fn random_bytes(length: usize) -\u003e CryptoResult\u003cVec\u003cu8\u003e\u003e {\n    let mut bytes = vec![0u8; length];\n    (\u0026*SECURE_RNG)\n        .fill(\u0026mut bytes)\n        .map_err(|e| CryptoError::KeyGenerationError(format!(\"RNG failed: {:?}\", e)))?;\n    Ok(bytes)\n}\n\n/// G√©n√®re un tableau de bytes al√©atoires de taille fixe\n/// \n/// # Examples\n/// ```\n/// use miaou::crypto::primitives::random_array;\n/// \n/// let random_key: [u8; 32] = random_array().unwrap();\n/// assert_eq!(random_key.len(), 32);\n/// ```\npub fn random_array\u003cconst N: usize\u003e() -\u003e CryptoResult\u003c[u8; N]\u003e {\n    let mut array = [0u8; N];\n    (\u0026*SECURE_RNG)\n        .fill(\u0026mut array)\n        .map_err(|e| CryptoError::KeyGenerationError(format!(\"RNG failed: {:?}\", e)))?;\n    Ok(array)\n}\n\n/// Comparaison en temps constant pour √©viter les attaques par canaux auxiliaires\n/// \n/// # Arguments\n/// * `a` - Premier slice √† comparer\n/// * `b` - Second slice √† comparer\n/// \n/// # Returns\n/// * `bool` - true si les slices sont identiques, false sinon\n/// \n/// # Security\n/// Cette fonction utilise une comparaison en temps constant pour √©viter\n/// les attaques par analyse temporelle.\n/// \n/// # Examples\n/// ```\n/// use miaou::crypto::primitives::secure_compare;\n/// \n/// let data1 = b\"secret\";\n/// let data2 = b\"secret\";\n/// let data3 = b\"public\";\n/// \n/// assert!(secure_compare(data1, data2));\n/// assert!(!secure_compare(data1, data3));\n/// ```\npub fn secure_compare(a: \u0026[u8], b: \u0026[u8]) -\u003e bool {\n    // V√©rification des longueurs d'abord\n    if a.len() != b.len() {\n        return false;\n    }\n    \n    // Comparaison en temps constant\n    a.ct_eq(b).into()\n}\n\n/// XOR de deux slices de m√™me taille\n/// \n/// # Arguments\n/// * `a` - Premier slice\n/// * `b` - Second slice (doit avoir la m√™me taille que `a`)\n/// \n/// # Returns\n/// * `Result\u003cVec\u003cu8\u003e, CryptoError\u003e` - XOR des deux slices\n/// \n/// # Examples\n/// ```\n/// use miaou::crypto::primitives::xor_bytes;\n/// \n/// let a = \u0026[0xFF, 0x00, 0xAA];\n/// let b = \u0026[0x0F, 0xFF, 0x55];\n/// let result = xor_bytes(a, b).unwrap();\n/// assert_eq!(result, vec![0xF0, 0xFF, 0xFF]);\n/// ```\npub fn xor_bytes(a: \u0026[u8], b: \u0026[u8]) -\u003e CryptoResult\u003cVec\u003cu8\u003e\u003e {\n    if a.len() != b.len() {\n        return Err(CryptoError::InvalidDataSize {\n            expected: a.len(),\n            actual: b.len(),\n        });\n    }\n    \n    let result: Vec\u003cu8\u003e = a.iter().zip(b.iter()).map(|(x, y)| x ^ y).collect();\n    Ok(result)\n}\n\n/// Combine deux cl√©s de mani√®re s√©curis√©e (XOR apr√®s hachage)\n/// \n/// # Arguments\n/// * `key1` - Premi√®re cl√©\n/// * `key2` - Seconde cl√©  \n/// \n/// # Returns\n/// * `[u8; 32]` - Cl√© combin√©e de 32 bytes\n/// \n/// # Security\n/// Les cl√©s sont d'abord hach√©es avec BLAKE3 avant XOR pour √©viter\n/// les faiblesses cryptographiques du XOR direct.\npub fn combine_keys(key1: \u0026[u8], key2: \u0026[u8]) -\u003e [u8; 32] {\n    use crate::crypto::hashing::Blake3Hasher;\n    \n    let hash1 = Blake3Hasher::hash(key1);\n    let hash2 = Blake3Hasher::hash(key2);\n    \n    let mut combined = [0u8; 32];\n    for i in 0..32 {\n        combined[i] = hash1.as_bytes()[i] ^ hash2.as_bytes()[i];\n    }\n    \n    combined\n}\n\n/// D√©rive une sous-cl√© √† partir d'une cl√© ma√Ætre et d'un contexte\n/// \n/// # Arguments\n/// * `master_key` - Cl√© ma√Ætre\n/// * `context` - Contexte de d√©rivation (ex: \"encryption\", \"signature\")\n/// * `index` - Index de la sous-cl√© (pour g√©n√©rer plusieurs cl√©s)\n/// \n/// # Returns\n/// * `[u8; 32]` - Sous-cl√© d√©riv√©e\n/// \n/// # Examples\n/// ```\n/// use miaou::crypto::primitives::derive_subkey;\n/// \n/// let master = \u0026[0u8; 32];\n/// let encryption_key = derive_subkey(master, \"encryption\", 0);\n/// let signing_key = derive_subkey(master, \"signing\", 0);\n/// \n/// assert_ne!(encryption_key, signing_key);\n/// ```\npub fn derive_subkey(master_key: \u0026[u8], context: \u0026str, index: u32) -\u003e [u8; 32] {\n    let context_with_index = format!(\"miaou.{}.{}\", context, index);\n    let combined = [master_key, context_with_index.as_bytes()].concat();\n    let hash = blake3::hash(\u0026combined);\n    *hash.as_bytes()\n}\n\n/// M√©lange s√©curis√© de donn√©es (shuffle cryptographique)\n/// \n/// # Arguments\n/// * `data` - Donn√©es √† m√©langer\n/// * `seed` - Graine pour le m√©lange (doit √™tre al√©atoire)\n/// \n/// # Returns\n/// * `Vec\u003cu8\u003e` - Donn√©es m√©lang√©es\n/// \n/// # Security\n/// Utilise Fisher-Yates avec un PRNG seed√© pour un m√©lange d√©terministe\n/// mais cryptographiquement s√ªr.\npub fn secure_shuffle(data: \u0026[u8], seed: \u0026[u8; 32]) -\u003e Vec\u003cu8\u003e {\n    use rand::{Rng, SeedableRng};\n    use rand_chacha::ChaCha20Rng;\n    \n    let mut rng = ChaCha20Rng::from_seed(*seed);\n    let mut result = data.to_vec();\n    \n    // Fisher-Yates shuffle\n    for i in (1..result.len()).rev() {\n        let j = rng.gen_range(0..=i);\n        result.swap(i, j);\n    }\n    \n    result\n}\n\n/// G√©n√®re un sel al√©atoire pour Argon2 ou autres KDF\n/// \n/// # Returns\n/// * `[u8; 16]` - Sel al√©atoire de 16 bytes\npub fn generate_salt() -\u003e CryptoResult\u003c[u8; 16]\u003e {\n    random_array::\u003c16\u003e()\n}\n\n/// G√©n√®re un nonce al√©atoire pour ChaCha20-Poly1305\n/// \n/// # Returns\n/// * `[u8; 12]` - Nonce al√©atoire de 12 bytes\npub fn generate_nonce() -\u003e CryptoResult\u003c[u8; 12]\u003e {\n    random_array::\u003c12\u003e()\n}\n\n/// Efface de mani√®re s√©curis√©e un buffer en m√©moire\n/// \n/// # Arguments\n/// * `buffer` - Buffer mutable √† effacer\n/// \n/// # Security\n/// Utilise zeroize pour garantir que les donn√©es sensibles\n/// sont bien effac√©es de la m√©moire.\npub fn secure_erase(buffer: \u0026mut [u8]) {\n    buffer.zeroize();\n}\n\n/// G√©n√©rateur d'identifiants uniques cryptographiquement s√ªrs\npub struct SecureIdGenerator {\n    counter: std::sync::atomic::AtomicU64,\n    node_id: [u8; 8],\n}\n\nimpl SecureIdGenerator {\n    /// Cr√©e un nouveau g√©n√©rateur avec un ID de n≈ìud al√©atoire\n    pub fn new() -\u003e CryptoResult\u003cSelf\u003e {\n        let node_id = random_array::\u003c8\u003e()?;\n        Ok(Self {\n            counter: std::sync::atomic::AtomicU64::new(0),\n            node_id,\n        })\n    }\n    \n    /// G√©n√®re un ID unique de 16 bytes\n    pub fn generate_id(\u0026self) -\u003e [u8; 16] {\n        use std::sync::atomic::Ordering;\n        \n        let counter = self.counter.fetch_add(1, Ordering::SeqCst);\n        let timestamp = std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap()\n            .as_millis() as u64;\n        \n        let mut id = [0u8; 16];\n        id[0..8].copy_from_slice(\u0026timestamp.to_be_bytes());\n        id[8..16].copy_from_slice(\u0026(counter ^ u64::from_be_bytes(self.node_id)).to_be_bytes());\n        \n        id\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_random_bytes() {\n        let bytes1 = random_bytes(32).unwrap();\n        let bytes2 = random_bytes(32).unwrap();\n        \n        assert_eq!(bytes1.len(), 32);\n        assert_eq!(bytes2.len(), 32);\n        assert_ne!(bytes1, bytes2); // Probabilit√© n√©gligeable d'√™tre √©gaux\n    }\n    \n    #[test]\n    fn test_random_array() {\n        let array1: [u8; 16] = random_array().unwrap();\n        let array2: [u8; 16] = random_array().unwrap();\n        \n        assert_ne!(array1, array2);\n    }\n    \n    #[test]\n    fn test_secure_compare() {\n        let data1 = b\"secret_data\";\n        let data2 = b\"secret_data\";\n        let data3 = b\"public_data\";\n        let data4 = b\"secret\"; // Longueur diff√©rente\n        \n        assert!(secure_compare(data1, data2));\n        assert!(!secure_compare(data1, data3));\n        assert!(!secure_compare(data1, data4));\n    }\n    \n    #[test]\n    fn test_xor_bytes() {\n        let a = \u0026[0xFF, 0x00, 0xAA, 0x55];\n        let b = \u0026[0x0F, 0xFF, 0x55, 0xAA];\n        let expected = vec![0xF0, 0xFF, 0xFF, 0xFF];\n        \n        let result = xor_bytes(a, b).unwrap();\n        assert_eq!(result, expected);\n        \n        // Test tailles diff√©rentes\n        let c = \u0026[0xFF];\n        assert!(xor_bytes(a, c).is_err());\n    }\n    \n    #[test]\n    fn test_combine_keys() {\n        let key1 = \u0026[1u8; 32];\n        let key2 = \u0026[2u8; 32];\n        let key3 = \u0026[1u8; 32]; // Identique √† key1\n        \n        let combined1 = combine_keys(key1, key2);\n        let combined2 = combine_keys(key1, key3);\n        let combined3 = combine_keys(key2, key1); // Ordre diff√©rent\n        \n        assert_ne!(combined1, combined2);\n        assert_eq!(combined1, combined3); // XOR est commutatif apr√®s hash\n    }\n    \n    #[test]\n    fn test_derive_subkey() {\n        let master = \u0026[0u8; 32];\n        \n        let enc_key = derive_subkey(master, \"encryption\", 0);\n        let sig_key = derive_subkey(master, \"signing\", 0);\n        let enc_key2 = derive_subkey(master, \"encryption\", 1);\n        \n        // Contextes diff√©rents = cl√©s diff√©rentes\n        assert_ne!(enc_key, sig_key);\n        \n        // Index diff√©rents = cl√©s diff√©rentes\n        assert_ne!(enc_key, enc_key2);\n        \n        // D√©terminisme\n        let enc_key_again = derive_subkey(master, \"encryption\", 0);\n        assert_eq!(enc_key, enc_key_again);\n    }\n    \n    #[test]\n    fn test_secure_shuffle() {\n        let data = b\"Hello, World!\";\n        let seed1 = [1u8; 32];\n        let seed2 = [2u8; 32];\n        \n        let shuffled1 = secure_shuffle(data, \u0026seed1);\n        let shuffled2 = secure_shuffle(data, \u0026seed2);\n        let shuffled1_again = secure_shuffle(data, \u0026seed1);\n        \n        // M√™me seed = m√™me r√©sultat\n        assert_eq!(shuffled1, shuffled1_again);\n        \n        // Seeds diff√©rents = r√©sultats diff√©rents (tr√®s probable)\n        assert_ne!(shuffled1, shuffled2);\n        \n        // M√™me longueur\n        assert_eq!(shuffled1.len(), data.len());\n    }\n    \n    #[test]\n    fn test_salt_and_nonce_generation() {\n        let salt1 = generate_salt().unwrap();\n        let salt2 = generate_salt().unwrap();\n        let nonce1 = generate_nonce().unwrap();\n        let nonce2 = generate_nonce().unwrap();\n        \n        assert_eq!(salt1.len(), 16);\n        assert_eq!(nonce1.len(), 12);\n        assert_ne!(salt1, salt2);\n        assert_ne!(nonce1, nonce2);\n    }\n    \n    #[test]\n    fn test_secure_erase() {\n        let mut buffer = vec![0xAA; 100];\n        secure_erase(\u0026mut buffer);\n        \n        // V√©rifier que tout est √† z√©ro\n        assert!(buffer.iter().all(|\u0026x| x == 0));\n    }\n    \n    #[test]\n    fn test_secure_id_generator() {\n        let generator = SecureIdGenerator::new().unwrap();\n        \n        let id1 = generator.generate_id();\n        let id2 = generator.generate_id();\n        \n        assert_eq!(id1.len(), 16);\n        assert_eq!(id2.len(), 16);\n        assert_ne!(id1, id2);\n    }\n    \n    #[test]\n    fn test_secure_id_generator_uniqueness() {\n        let generator = SecureIdGenerator::new().unwrap();\n        let mut ids = std::collections::HashSet::new();\n        \n        // G√©n√©rer 1000 IDs et v√©rifier l'unicit√©\n        for _ in 0..1000 {\n            let id = generator.generate_id();\n            assert!(ids.insert(id), \"ID dupliqu√© d√©tect√©\");\n        }\n    }\n}","traces":[{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":6},{"path":["/","home","seb","Dev","miaou","src","crypto","sign.rs"],"content":"//! # Signatures Ed25519 (v0.1)\n//!\n//! G√©n√®re une paire, signe et v√©rifie des messages (aucun Debug sur secrets).\n//! Utilise ed25519-dalek v2 avec zeroization automatique.\n\nuse ed25519_dalek::{\n    SigningKey, VerifyingKey, Signature as DalekSignature, \n    Signer, Verifier\n};\nuse rand_core::{OsRng, CryptoRng, RngCore};\nuse zeroize::ZeroizeOnDrop;\nuse crate::crypto::CryptoError;\n\n/// Cl√© de signature secr√®te (zeroized on drop, non clonable, non affichable)\n#[derive(ZeroizeOnDrop)]\npub struct SigningKeyRef {\n    inner: SigningKey,\n}\n\nimpl SigningKeyRef {\n    /// Cr√©e une cl√© de signature depuis 32 octets.\n    pub fn from_bytes(bytes: [u8; 32]) -\u003e Self {\n        Self {\n            inner: SigningKey::from_bytes(\u0026bytes)\n        }\n    }\n    \n    /// G√©n√®re une nouvelle cl√© de signature al√©atoire.\n    pub fn generate\u003cR: RngCore + CryptoRng\u003e(rng: \u0026mut R) -\u003e Self {\n        Self {\n            inner: SigningKey::generate(rng)\n        }\n    }\n    \n    /// Retourne la cl√© publique correspondante.\n    pub fn verifying_key(\u0026self) -\u003e VerifyingKeyRef {\n        VerifyingKeyRef {\n            inner: self.inner.verifying_key()\n        }\n    }\n    \n    /// Retourne les octets de la cl√© secr√®te (usage keystore).\n    pub fn to_bytes(\u0026self) -\u003e [u8; 32] {\n        self.inner.to_bytes()\n    }\n    \n    /// Signe un message.\n    pub fn sign(\u0026self, msg: \u0026[u8]) -\u003e Signature {\n        Signature {\n            inner: self.inner.sign(msg)\n        }\n    }\n}\n\n// Pas de Debug pour √©viter les fuites\nimpl std::fmt::Debug for SigningKeyRef {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"SigningKeyRef([REDACTED])\")\n    }\n}\n\n/// Cl√© de v√©rification publique\n#[derive(Clone, Copy, Debug, PartialEq, Eq)]\npub struct VerifyingKeyRef {\n    inner: VerifyingKey,\n}\n\nimpl VerifyingKeyRef {\n    /// Cr√©e une cl√© de v√©rification depuis 32 octets.\n    pub fn from_bytes(bytes: [u8; 32]) -\u003e Result\u003cSelf, CryptoError\u003e {\n        VerifyingKey::from_bytes(\u0026bytes)\n            .map(|inner| Self { inner })\n            .map_err(|_| CryptoError::InvalidKey)\n    }\n    \n    /// Retourne les octets de la cl√© publique.\n    pub fn to_bytes(\u0026self) -\u003e [u8; 32] {\n        self.inner.to_bytes()\n    }\n    \n    /// V√©rifie une signature.\n    pub fn verify(\u0026self, msg: \u0026[u8], sig: \u0026Signature) -\u003e Result\u003c(), CryptoError\u003e {\n        self.inner\n            .verify(msg, \u0026sig.inner)\n            .map_err(|_| CryptoError::SignatureVerificationFailed)\n    }\n    \n    /// Encode la cl√© publique en hexad√©cimal.\n    pub fn to_hex(\u0026self) -\u003e String {\n        hex::encode(self.to_bytes())\n    }\n    \n    /// D√©code une cl√© publique depuis l'hexad√©cimal.\n    pub fn from_hex(hex_str: \u0026str) -\u003e Result\u003cSelf, CryptoError\u003e {\n        let bytes = hex::decode(hex_str)\n            .map_err(|_| CryptoError::InvalidInput)?;\n        \n        if bytes.len() != 32 {\n            return Err(CryptoError::InvalidKey);\n        }\n        \n        let mut key_bytes = [0u8; 32];\n        key_bytes.copy_from_slice(\u0026bytes);\n        \n        Self::from_bytes(key_bytes)\n    }\n}\n\n/// Signature Ed25519 (64 bytes)\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct Signature {\n    inner: DalekSignature,\n}\n\nimpl Signature {\n    /// Cr√©e une signature depuis 64 octets.\n    pub fn from_bytes(bytes: [u8; 64]) -\u003e Result\u003cSelf, CryptoError\u003e {\n        Ok(Self {\n            inner: DalekSignature::from_bytes(\u0026bytes)\n        })\n    }\n    \n    /// Retourne les octets de la signature.\n    pub fn to_bytes(\u0026self) -\u003e [u8; 64] {\n        self.inner.to_bytes()\n    }\n    \n    /// Encode la signature en hexad√©cimal.\n    pub fn to_hex(\u0026self) -\u003e String {\n        hex::encode(self.to_bytes())\n    }\n    \n    /// D√©code une signature depuis l'hexad√©cimal.\n    pub fn from_hex(hex_str: \u0026str) -\u003e Result\u003cSelf, CryptoError\u003e {\n        let bytes = hex::decode(hex_str)\n            .map_err(|_| CryptoError::InvalidInput)?;\n        \n        if bytes.len() != 64 {\n            return Err(CryptoError::InvalidInput);\n        }\n        \n        let mut sig_bytes = [0u8; 64];\n        sig_bytes.copy_from_slice(\u0026bytes);\n        \n        Self::from_bytes(sig_bytes)\n    }\n}\n\n/// Paire de cl√©s (secret/public)\npub struct Keypair {\n    /// Cl√© secr√®te (non clonable, non affichable).\n    pub secret: SigningKeyRef,\n    /// Cl√© publique (v√©rification).\n    pub public: VerifyingKeyRef,\n}\n\nimpl Keypair {\n    /// G√©n√®re une paire Ed25519.\n    pub fn generate() -\u003e Self {\n        let secret = SigningKeyRef {\n            inner: SigningKey::generate(\u0026mut OsRng)\n        };\n        let public = secret.verifying_key();\n        Self { secret, public }\n    }\n    \n    /// G√©n√®re une paire avec un RNG sp√©cifique.\n    pub fn generate_with_rng\u003cR: RngCore + CryptoRng\u003e(rng: \u0026mut R) -\u003e Self {\n        let secret = SigningKeyRef::generate(rng);\n        let public = secret.verifying_key();\n        Self { secret, public }\n    }\n    \n    /// Cr√©e une paire depuis une cl√© secr√®te.\n    pub fn from_secret_key(secret: SigningKeyRef) -\u003e Self {\n        let public = secret.verifying_key();\n        Self { secret, public }\n    }\n    \n    /// Cr√©e une paire depuis les octets d'une cl√© priv√©e.\n    pub fn from_private_bytes(bytes: [u8; 32]) -\u003e Result\u003cSelf, CryptoError\u003e {\n        let secret = SigningKeyRef::from_bytes(bytes);\n        let public = secret.verifying_key();\n        Ok(Self { secret, public })\n    }\n    \n    /// Signe un message.\n    pub fn sign(\u0026self, msg: \u0026[u8]) -\u003e Signature {\n        self.secret.sign(msg)\n    }\n    \n    /// V√©rifie une signature.\n    pub fn verify(\u0026self, msg: \u0026[u8], sig: \u0026Signature) -\u003e Result\u003c(), CryptoError\u003e {\n        self.public.verify(msg, sig)\n    }\n    \n    /// Retourne les octets de la cl√© publique.\n    pub fn public_bytes(\u0026self) -\u003e [u8; 32] {\n        self.public.to_bytes()\n    }\n    \n    /// Retourne les octets de la cl√© secr√®te (usage keystore).\n    pub fn secret_bytes(\u0026self) -\u003e [u8; 32] {\n        self.secret.to_bytes()\n    }\n    \n    /// Retourne une r√©f√©rence vers la cl√© publique.\n    pub fn public_key(\u0026self) -\u003e \u0026VerifyingKeyRef {\n        \u0026self.public\n    }\n    \n    /// Retourne une r√©f√©rence vers la cl√© secr√®te.\n    pub fn secret_key(\u0026self) -\u003e \u0026SigningKeyRef {\n        \u0026self.secret\n    }\n}\n\n// Pas de Debug pour √©viter les fuites de la cl√© secr√®te\nimpl std::fmt::Debug for Keypair {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"Keypair\")\n            .field(\"public\", \u0026self.public)\n            .field(\"secret\", \u0026\"[REDACTED]\")\n            .finish()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_keypair_generation() {\n        let keypair = Keypair::generate();\n        let message = b\"test message\";\n        \n        let signature = keypair.sign(message);\n        assert!(keypair.verify(message, \u0026signature).is_ok());\n    }\n    \n    #[test]\n    fn test_signature_verification() {\n        let keypair = Keypair::generate();\n        let message = b\"hello world\";\n        \n        let signature = keypair.sign(message);\n        \n        // Bonne signature\n        assert!(keypair.public.verify(message, \u0026signature).is_ok());\n        \n        // Mauvais message\n        assert!(keypair.public.verify(b\"wrong message\", \u0026signature).is_err());\n    }\n    \n    #[test]\n    fn test_key_serialization() {\n        let keypair = Keypair::generate();\n        \n        // Test s√©rialisation cl√© publique\n        let public_bytes = keypair.public.to_bytes();\n        let public_restored = VerifyingKeyRef::from_bytes(public_bytes).unwrap();\n        assert_eq!(keypair.public, public_restored);\n        \n        // Test s√©rialisation signature\n        let message = b\"test\";\n        let signature = keypair.sign(message);\n        let sig_bytes = signature.to_bytes();\n        let sig_restored = Signature::from_bytes(sig_bytes).unwrap();\n        assert_eq!(signature, sig_restored);\n    }\n    \n    #[test]\n    fn test_hex_encoding() {\n        let keypair = Keypair::generate();\n        \n        // Test hex cl√© publique\n        let hex = keypair.public.to_hex();\n        let restored = VerifyingKeyRef::from_hex(\u0026hex).unwrap();\n        assert_eq!(keypair.public, restored);\n        \n        // Test hex signature\n        let signature = keypair.sign(b\"test\");\n        let hex_sig = signature.to_hex();\n        let restored_sig = Signature::from_hex(\u0026hex_sig).unwrap();\n        assert_eq!(signature, restored_sig);\n    }\n    \n    #[test]\n    fn test_zeroization() {\n        // Test que SigningKeyRef impl√©mente ZeroizeOnDrop\n        fn assert_zeroize_on_drop\u003cT: ZeroizeOnDrop\u003e() {}\n        assert_zeroize_on_drop::\u003cSigningKeyRef\u003e();\n    }\n    \n    #[test]\n    fn test_no_debug_on_secrets() {\n        // Les types secrets ne doivent pas leak d'informations via Debug\n        let keypair = Keypair::generate();\n        let debug_str = format!(\"{:?}\", keypair);\n        assert!(debug_str.contains(\"[REDACTED]\"));\n        assert!(!debug_str.contains(\"SigningKey\"));\n    }\n}","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":5},{"path":["/","home","seb","Dev","miaou","src","crypto","signing.rs"],"content":"//! Signatures num√©riques avec Ed25519\n//! \n//! Impl√©mentation des signatures num√©riques EdDSA avec courbes Ed25519\n//! selon RFC 8032 pour authentifier les messages Miaou.\n\nuse crate::crypto::{CryptoError, CryptoResult, SIGNATURE_SIZE, PUBLIC_KEY_SIZE};\nuse ed25519_dalek::{\n    Signature, Signer, Keypair, PublicKey, SecretKey, Verifier,\n};\nuse rand::rngs::OsRng;\nuse zeroize::{Zeroize, ZeroizeOnDrop};\nuse serde::{Deserialize, Serialize};\n\n/// Trait pour les moteurs de signature\npub trait SigningEngine {\n    type PrivateKey;\n    type PublicKey;\n    type Signature;\n    \n    /// G√©n√®re une nouvelle paire de cl√©s\n    fn generate_keypair() -\u003e CryptoResult\u003c(Self::PrivateKey, Self::PublicKey)\u003e;\n    \n    /// Signe un message\n    fn sign(private_key: \u0026Self::PrivateKey, message: \u0026[u8]) -\u003e CryptoResult\u003cSelf::Signature\u003e;\n    \n    /// V√©rifie une signature\n    fn verify(public_key: \u0026Self::PublicKey, message: \u0026[u8], signature: \u0026Self::Signature) -\u003e CryptoResult\u003cbool\u003e;\n}\n\n/// Cl√© priv√©e Ed25519 avec protection zeroize\n#[derive(ZeroizeOnDrop)]\npub struct Ed25519PrivateKey {\n    key: SigningKey,\n}\n\n/// Cl√© publique Ed25519\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub struct Ed25519PublicKey {\n    key: VerifyingKey,\n}\n\n/// Signature Ed25519\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub struct Ed25519Signature {\n    signature: Signature,\n}\n\n/// Paire de cl√©s Ed25519 compl√®te\n#[derive(ZeroizeOnDrop)]\npub struct Ed25519KeyPair {\n    private_key: Ed25519PrivateKey,\n    #[zeroize(skip)]\n    public_key: Ed25519PublicKey,\n}\n\n/// Signeur Ed25519 principal\npub struct Ed25519Signer;\n\nimpl Ed25519PrivateKey {\n    /// Cr√©e une cl√© priv√©e √† partir de bytes\n    pub fn from_bytes(bytes: \u0026[u8; 32]) -\u003e CryptoResult\u003cSelf\u003e {\n        let key = SigningKey::from_bytes(bytes);\n        Ok(Self { key })\n    }\n    \n    /// Exporte la cl√© priv√©e en bytes (attention : sensible !)\n    pub fn to_bytes(\u0026self) -\u003e [u8; 32] {\n        self.key.to_bytes()\n    }\n    \n    /// D√©rive la cl√© publique correspondante\n    pub fn public_key(\u0026self) -\u003e Ed25519PublicKey {\n        Ed25519PublicKey {\n            key: self.key.verifying_key(),\n        }\n    }\n}\n\nimpl Ed25519PublicKey {\n    /// Cr√©e une cl√© publique √† partir de bytes\n    pub fn from_bytes(bytes: \u0026[u8; PUBLIC_KEY_SIZE]) -\u003e CryptoResult\u003cSelf\u003e {\n        let key = VerifyingKey::from_bytes(bytes)\n            .map_err(|e| CryptoError::InvalidKeyFormat)?;\n        Ok(Self { key })\n    }\n    \n    /// Exporte la cl√© publique en bytes\n    pub fn to_bytes(\u0026self) -\u003e [u8; PUBLIC_KEY_SIZE] {\n        self.key.to_bytes()\n    }\n    \n    /// Empreinte de la cl√© publique (hash des premiers 8 bytes)\n    pub fn fingerprint(\u0026self) -\u003e [u8; 8] {\n        let bytes = self.to_bytes();\n        let mut hasher = blake3::Hasher::new();\n        hasher.update(\u0026bytes);\n        let hash = hasher.finalize();\n        let hash_bytes = hash.as_bytes();\n        [\n            hash_bytes[0], hash_bytes[1], hash_bytes[2], hash_bytes[3],\n            hash_bytes[4], hash_bytes[5], hash_bytes[6], hash_bytes[7],\n        ]\n    }\n}\n\nimpl Ed25519Signature {\n    /// Cr√©e une signature √† partir de bytes\n    pub fn from_bytes(bytes: \u0026[u8; SIGNATURE_SIZE]) -\u003e CryptoResult\u003cSelf\u003e {\n        let signature = Signature::from_bytes(bytes);\n        Ok(Self { signature })\n    }\n    \n    /// Exporte la signature en bytes\n    pub fn to_bytes(\u0026self) -\u003e [u8; SIGNATURE_SIZE] {\n        self.signature.to_bytes()\n    }\n}\n\nimpl Ed25519KeyPair {\n    /// G√©n√®re une nouvelle paire de cl√©s\n    pub fn generate() -\u003e CryptoResult\u003cSelf\u003e {\n        let signing_key = SigningKey::generate(\u0026mut OsRng);\n        let private_key = Ed25519PrivateKey { key: signing_key };\n        let public_key = private_key.public_key();\n        \n        Ok(Self {\n            private_key,\n            public_key,\n        })\n    }\n    \n    /// Acc√®s √† la cl√© priv√©e\n    pub fn private_key(\u0026self) -\u003e \u0026Ed25519PrivateKey {\n        \u0026self.private_key\n    }\n    \n    /// Acc√®s √† la cl√© publique\n    pub fn public_key(\u0026self) -\u003e \u0026Ed25519PublicKey {\n        \u0026self.public_key\n    }\n    \n    /// Signe un message avec cette paire de cl√©s\n    pub fn sign(\u0026self, message: \u0026[u8]) -\u003e CryptoResult\u003cEd25519Signature\u003e {\n        let signature = self.private_key.key.sign(message);\n        Ok(Ed25519Signature { signature })\n    }\n    \n    /// V√©rifie une signature avec la cl√© publique de cette paire\n    pub fn verify(\u0026self, message: \u0026[u8], signature: \u0026Ed25519Signature) -\u003e CryptoResult\u003cbool\u003e {\n        match self.public_key.key.verify(message, \u0026signature.signature) {\n            Ok(()) =\u003e Ok(true),\n            Err(_) =\u003e Ok(false),\n        }\n    }\n}\n\nimpl SigningEngine for Ed25519Signer {\n    type PrivateKey = Ed25519PrivateKey;\n    type PublicKey = Ed25519PublicKey;\n    type Signature = Ed25519Signature;\n    \n    fn generate_keypair() -\u003e CryptoResult\u003c(Self::PrivateKey, Self::PublicKey)\u003e {\n        let keypair = Ed25519KeyPair::generate()?;\n        // Nous devons cloner car on ne peut pas move out of ZeroizeOnDrop\n        let signing_key = SigningKey::from_bytes(\u0026keypair.private_key.to_bytes());\n        let private_key = Ed25519PrivateKey { key: signing_key };\n        let public_key = private_key.public_key();\n        \n        Ok((private_key, public_key))\n    }\n    \n    fn sign(private_key: \u0026Self::PrivateKey, message: \u0026[u8]) -\u003e CryptoResult\u003cSelf::Signature\u003e {\n        let signature = private_key.key.sign(message);\n        Ok(Ed25519Signature { signature })\n    }\n    \n    fn verify(\n        public_key: \u0026Self::PublicKey, \n        message: \u0026[u8], \n        signature: \u0026Self::Signature\n    ) -\u003e CryptoResult\u003cbool\u003e {\n        match public_key.key.verify(message, \u0026signature.signature) {\n            Ok(()) =\u003e Ok(true),\n            Err(_) =\u003e Ok(false),\n        }\n    }\n}\n\n/// Gestionnaire de signatures avec v√©rification d'int√©grit√©\npub struct SignatureVerifier {\n    known_keys: std::collections::HashMap\u003c[u8; 8], Ed25519PublicKey\u003e,\n}\n\nimpl SignatureVerifier {\n    /// Cr√©e un nouveau v√©rificateur\n    pub fn new() -\u003e Self {\n        Self {\n            known_keys: std::collections::HashMap::new(),\n        }\n    }\n    \n    /// Ajoute une cl√© publique de confiance\n    pub fn add_trusted_key(\u0026mut self, public_key: Ed25519PublicKey) {\n        let fingerprint = public_key.fingerprint();\n        self.known_keys.insert(fingerprint, public_key);\n    }\n    \n    /// V√©rifie une signature avec une cl√© connue\n    pub fn verify_with_fingerprint(\n        \u0026self,\n        fingerprint: \u0026[u8; 8],\n        message: \u0026[u8],\n        signature: \u0026Ed25519Signature,\n    ) -\u003e CryptoResult\u003cbool\u003e {\n        let public_key = self.known_keys.get(fingerprint)\n            .ok_or_else(|| CryptoError::VerificationError(\"Cl√© publique inconnue\".into()))?;\n        \n        Ed25519Signer::verify(public_key, message, signature)\n    }\n    \n    /// Nombre de cl√©s de confiance\n    pub fn trusted_key_count(\u0026self) -\u003e usize {\n        self.known_keys.len()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_ed25519_keypair_generation() {\n        let keypair = Ed25519KeyPair::generate().unwrap();\n        let public_key = keypair.public_key();\n        \n        // V√©rifier les tailles\n        assert_eq!(public_key.to_bytes().len(), PUBLIC_KEY_SIZE);\n        assert_eq!(keypair.private_key().to_bytes().len(), 32);\n    }\n    \n    #[test]\n    fn test_ed25519_sign_verify() {\n        let keypair = Ed25519KeyPair::generate().unwrap();\n        let message = b\"Message de test pour Miaou\";\n        \n        let signature = keypair.sign(message).unwrap();\n        assert_eq!(signature.to_bytes().len(), SIGNATURE_SIZE);\n        \n        let is_valid = keypair.verify(message, \u0026signature).unwrap();\n        assert!(is_valid);\n    }\n    \n    #[test]\n    fn test_ed25519_sign_verify_wrong_message() {\n        let keypair = Ed25519KeyPair::generate().unwrap();\n        let message = b\"Message original\";\n        let wrong_message = b\"Message modifie\";\n        \n        let signature = keypair.sign(message).unwrap();\n        let is_valid = keypair.verify(wrong_message, \u0026signature).unwrap();\n        \n        assert!(!is_valid);\n    }\n    \n    #[test]\n    fn test_ed25519_signer_trait() {\n        let (private_key, public_key) = Ed25519Signer::generate_keypair().unwrap();\n        let message = b\"Test du trait SigningEngine\";\n        \n        let signature = Ed25519Signer::sign(\u0026private_key, message).unwrap();\n        let is_valid = Ed25519Signer::verify(\u0026public_key, message, \u0026signature).unwrap();\n        \n        assert!(is_valid);\n    }\n    \n    #[test]\n    fn test_public_key_fingerprint() {\n        let keypair1 = Ed25519KeyPair::generate().unwrap();\n        let keypair2 = Ed25519KeyPair::generate().unwrap();\n        \n        let fingerprint1 = keypair1.public_key().fingerprint();\n        let fingerprint2 = keypair2.public_key().fingerprint();\n        \n        assert_ne!(fingerprint1, fingerprint2);\n        assert_eq!(fingerprint1.len(), 8);\n    }\n    \n    #[test]\n    fn test_signature_verifier() {\n        let mut verifier = SignatureVerifier::new();\n        let keypair = Ed25519KeyPair::generate().unwrap();\n        let message = b\"Message avec verificateur\";\n        \n        // Ajouter la cl√© publique\n        verifier.add_trusted_key(keypair.public_key().clone());\n        assert_eq!(verifier.trusted_key_count(), 1);\n        \n        // Signer et v√©rifier\n        let signature = keypair.sign(message).unwrap();\n        let fingerprint = keypair.public_key().fingerprint();\n        \n        let is_valid = verifier.verify_with_fingerprint(\u0026fingerprint, message, \u0026signature).unwrap();\n        assert!(is_valid);\n    }\n    \n    #[test]\n    fn test_key_serialization() {\n        let keypair = Ed25519KeyPair::generate().unwrap();\n        let public_key = keypair.public_key();\n        \n        // S√©rialisation/d√©s√©rialisation de la cl√© publique\n        let bytes = public_key.to_bytes();\n        let restored_key = Ed25519PublicKey::from_bytes(\u0026bytes).unwrap();\n        \n        assert_eq!(public_key.to_bytes(), restored_key.to_bytes());\n    }\n}","traces":[],"covered":0,"coverable":0},{"path":["/","home","seb","Dev","miaou","src","lib.rs"],"content":"//! # Miaou v0.1.0 \"Premi√®re Griffe\"\n//!\n//! **Phase 1 :** Fondations cryptographiques et architecture modulaire\n//!\n//! ## Vue d'ensemble\n//!\n//! Cette version √©tablit les fondations cryptographiques s√©curis√©es de Miaou,\n//! une plateforme de communication d√©centralis√©e. Elle impl√©mente les primitives\n//! cryptographiques essentielles selon les principes de s√©curit√©, performance\n//! et d√©centralisation du projet.\n//!\n//! ## Architecture modulaire\n//!\n//! Miaou v0.1.0 adopte une architecture modulaire avec des crates s√©par√©s :\n//! - `miaou-crypto` : Primitives cryptographiques s√©curis√©es\n//! - `miaou-core` : Logique m√©tier centrale et abstractions\n//! - `miaou-cli` : Interface en ligne de commande\n\n#![warn(missing_docs)]\n#![warn(rustdoc::broken_intra_doc_links)]\n\n// Re-exports des crates modulaires\npub use miaou_core as core;\npub use miaou_crypto as crypto;\n\n// Re-exports pour compatibilit√© API\npub use miaou_core::{\n    initialize,\n    storage::{ProfileHandle, ProfileId, SecureStorage},\n    version_info, PlatformInterface, DEVELOPMENT_PHASE, VERSION, VERSION_NAME,\n};\n\npub use miaou_crypto::{\n    aead::{decrypt, encrypt_auto_nonce, AeadKeyRef, SealedData},\n    constants,\n    hash::{blake3_32, Blake3Engine, HashingEngine},\n    kdf::{hash_password, verify_password, Argon2Config},\n    sign::{Keypair, Signature, SigningKeyRef, VerifyingKeyRef},\n    CryptoError, CryptoProvider, CryptoResult, DefaultCryptoProvider,\n};\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_modular_architecture() {\n        // Test que les re-exports fonctionnent\n        let info = version_info();\n        assert!(info.contains(\"Miaou\"));\n\n        // Test crypto\n        assert!(crypto::test_crypto_availability().is_ok());\n\n        // Test core\n        assert!(initialize().is_ok());\n    }\n\n    #[test]\n    fn test_crypto_re_exports() {\n        // Test AEAD\n        let key = AeadKeyRef::from_bytes([42u8; 32]);\n        let plaintext = b\"test\";\n        let aad = b\"test_aad\";\n        let mut rng = rand_core::OsRng;\n\n        let encrypted = encrypt_auto_nonce(\u0026key, aad, plaintext, \u0026mut rng).unwrap();\n        let decrypted = decrypt(\u0026key, aad, \u0026encrypted).unwrap();\n        assert_eq!(\u0026decrypted, plaintext);\n\n        // Test signatures\n        let keypair = Keypair::generate();\n        let message = b\"test message\";\n        let signature = keypair.sign(message);\n        assert!(keypair.verify(message, \u0026signature).is_ok());\n\n        // Test hachage\n        let hash1 = blake3_32(b\"test\");\n        let hash2 = blake3_32(b\"test\");\n        assert_eq!(hash1, hash2);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","seb","Dev","miaou","src","main.rs"],"content":"// Point d'entr√©e principal temporaire\n// Sera remplac√© par la structure modulaire dans les prochaines versions\n\nfn main() {\n    println!(\"Miaou v{}\", env!(\"CARGO_PKG_VERSION\"));\n    println!(\"Communication d√©centralis√©e\");\n\n    #[cfg(target_os = \"android\")]\n    println!(\"Support Android activ√©\");\n\n    #[cfg(target_os = \"ios\")]\n    println!(\"Support iOS activ√©\");\n\n    #[cfg(not(any(target_os = \"android\", target_os = \"ios\")))]\n    println!(\"Version desktop\");\n}\n","traces":[{"line":4,"address":[143200],"length":1,"stats":{"Line":0}},{"line":5,"address":[143207],"length":1,"stats":{"Line":0}},{"line":6,"address":[143240],"length":1,"stats":{"Line":0}},{"line":14,"address":[143268],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["/","home","seb","Dev","miaou","src","mobile.rs"],"content":"// Module mobile - Sp√©cifique aux plateformes mobiles\n// Fonctionnalit√©s communes Android et iOS\n\nuse crate::{PlatformInterface, core::MiaouCore};\n\n/// Plateforme mobile (Android/iOS)\npub struct MobilePlatform {\n    core: MiaouCore,\n    platform_name: \u0026'static str,\n}\n\nimpl MobilePlatform {\n    /// Cr√©e une nouvelle plateforme mobile\n    pub fn new(platform_name: \u0026'static str) -\u003e Self {\n        Self {\n            core: MiaouCore::new(),\n            platform_name,\n        }\n    }\n}\n\nimpl PlatformInterface for MobilePlatform {\n    fn initialize(\u0026mut self) -\u003e Result\u003c(), String\u003e {\n        self.core.initialize()?;\n        println!(\"Initialisation mobile pour {}\", self.platform_name);\n        Ok(())\n    }\n\n    fn get_platform_name(\u0026self) -\u003e \u0026'static str {\n        self.platform_name\n    }\n}\n\n// Interface Android via JNI\n#[cfg(target_os = \"android\")]\npub mod android {\n    use jni::JNIEnv;\n    use jni::objects::{JClass, JString};\n    use jni::sys::jstring;\n    use super::*;\n\n    #[no_mangle]\n    pub extern \"system\" fn Java_net_nethttp_miaou_MiaouLib_hello(\n        env: JNIEnv,\n        _class: JClass,\n    ) -\u003e jstring {\n        let output = env.new_string(\"Miaou Android\")\n            .expect(\"Impossible de cr√©er une string Java\");\n        output.into_inner()\n    }\n\n    #[no_mangle]\n    pub extern \"system\" fn Java_net_nethttp_miaou_MiaouLib_initialize(\n        _env: JNIEnv,\n        _class: JClass,\n    ) {\n        let mut platform = MobilePlatform::new(\"Android\");\n        let _ = platform.initialize();\n    }\n}\n\n// Interface iOS via Objective-C\n#[cfg(target_os = \"ios\")]\npub mod ios {\n    use std::ffi::{CStr, CString};\n    use std::os::raw::c_char;\n    use super::*;\n\n    #[no_mangle]\n    pub extern \"C\" fn miaou_hello() -\u003e *const c_char {\n        let hello = CString::new(\"Miaou iOS\").unwrap();\n        hello.into_raw()\n    }\n\n    #[no_mangle]\n    pub extern \"C\" fn miaou_initialize() {\n        let mut platform = MobilePlatform::new(\"iOS\");\n        let _ = platform.initialize();\n    }\n\n    #[no_mangle]\n    pub extern \"C\" fn miaou_free_string(ptr: *mut c_char) {\n        if !ptr.is_null() {\n            unsafe {\n                CString::from_raw(ptr);\n            }\n        }\n    }\n}","traces":[],"covered":0,"coverable":0},{"path":["/","home","seb","Dev","miaou","src","storage.rs"],"content":"// Module de stockage s√©curis√© pour Miaou v0.1.0\n// Gestion des profils utilisateur avec chiffrement des donn√©es sensibles\n\nuse std::path::{Path, PathBuf};\nuse std::fs;\nuse anyhow::{Result, Context};\nuse secrecy::{SecretString, ExposeSecret, Zeroize};\nuse serde::{Serialize, Deserialize, Serializer, Deserializer};\nuse chrono::{DateTime, Utc};\nuse crate::crypto::{\n    aead::{AeadKeyRef, encrypt_auto_nonce, decrypt},\n    kdf::{Argon2Config, hash_password, verify_password, derive_key_32, generate_salt},\n    sign::Keypair,\n    hash::blake3_32,\n    CryptoError,\n};\n\n/// Erreurs de stockage\n#[derive(Debug, thiserror::Error)]\npub enum StorageError {\n    #[error(\"Erreur d'E/S: {0}\")]\n    Io(#[from] std::io::Error),\n    \n    #[error(\"Erreur de s√©rialisation: {0}\")]\n    Serialization(#[from] serde_json::Error),\n    \n    #[error(\"Erreur cryptographique: {0}\")]\n    Crypto(#[from] CryptoError),\n    \n    #[error(\"Profil non trouv√©: {0}\")]\n    ProfileNotFound(String),\n    \n    #[error(\"Profil d√©j√† existant: {0}\")]\n    ProfileAlreadyExists(String),\n    \n    #[error(\"Mot de passe invalide\")]\n    InvalidPassword,\n    \n    #[error(\"Donn√©es corrompues ou version incompatible\")]\n    CorruptedData,\n}\n\n/// Gestionnaire de stockage s√©curis√©\npub struct SecureStorage {\n    /// R√©pertoire racine de stockage\n    storage_root: PathBuf,\n}\n\nimpl SecureStorage {\n    /// Cr√©e une nouvelle instance de stockage\n    pub fn new\u003cP: AsRef\u003cPath\u003e\u003e(storage_root: P) -\u003e Result\u003cSelf\u003e {\n        let storage_root = storage_root.as_ref().to_path_buf();\n        \n        // Cr√©er les r√©pertoires n√©cessaires\n        fs::create_dir_all(\u0026storage_root)?;\n        fs::create_dir_all(storage_root.join(\"profiles\"))?;\n        fs::create_dir_all(storage_root.join(\"keystore\"))?;\n        \n        Ok(Self { storage_root })\n    }\n    \n    /// Cr√©e un nouveau profil utilisateur\n    pub fn create_profile(\u0026self, name: \u0026str, password: \u0026SecretString) -\u003e Result\u003cProfileId\u003e {\n        let profile_id = ProfileId::new(name);\n        let profile_path = self.get_profile_path(\u0026profile_id);\n        \n        // V√©rifier que le profil n'existe pas\n        if profile_path.exists() {\n            return Err(StorageError::ProfileAlreadyExists(name.to_string()).into());\n        }\n        \n        // G√©n√©rer les cl√©s cryptographiques\n        let identity_keypair = Keypair::generate();\n        let mut rng = rand_core::OsRng;\n        let storage_key = AeadKeyRef::generate(\u0026mut rng);\n        \n        // Cr√©er le hash du mot de passe pour l'authentification\n        let config = Argon2Config::balanced();\n        let password_hash = hash_password(password, \u0026config)?;\n        \n        // D√©river une cl√© de chiffrement depuis le mot de passe\n        let salt = generate_salt();\n        let encryption_key_bytes = derive_key_32(password, \u0026salt, \u0026config)?;\n        let encryption_key = AeadKeyRef::from_bytes(encryption_key_bytes);\n        \n        // Chiffrer les donn√©es sensibles (cl√©s priv√©es)\n        let identity_private_bytes = identity_keypair.secret.to_bytes();\n        let encrypted_identity = encrypt_auto_nonce(\n            \u0026encryption_key,\n            b\"miaou_identity_v0.1.0\",\n            \u0026identity_private_bytes,\n            \u0026mut rng,\n        )?;\n        \n        // Cr√©er la structure du profil\n        let profile = ProfileData {\n            metadata: ProfileMetadata {\n                id: profile_id.clone(),\n                name: name.to_string(),\n                version: \"0.1.0\".to_string(),\n                created: Utc::now(),\n                last_access: Utc::now(),\n            },\n            auth: AuthenticationData {\n                password_hash,\n                salt: salt.to_string(),\n                config_type: \"balanced\".to_string(),\n            },\n            keys: KeyData {\n                public_identity: identity_keypair.public.to_bytes(),\n                encrypted_private_identity: encrypted_identity,\n                key_fingerprint: blake3_32(\u0026identity_keypair.public.to_bytes()),\n            },\n            settings: ProfileSettings::default(),\n        };\n        \n        // Sauvegarder le profil\n        let profile_json = serde_json::to_string_pretty(\u0026profile)?;\n        fs::write(\u0026profile_path, profile_json)?;\n        \n        // Nettoyer les donn√©es sensibles\n        let mut identity_private_bytes = identity_private_bytes;\n        identity_private_bytes.zeroize();\n        let mut encryption_key_bytes = encryption_key_bytes;\n        encryption_key_bytes.zeroize();\n        \n        Ok(profile_id)\n    }\n    \n    /// Charge un profil utilisateur avec authentification\n    pub fn load_profile(\u0026self, profile_id: \u0026ProfileId, password: \u0026SecretString) -\u003e Result\u003cProfileHandle\u003e {\n        let profile_path = self.get_profile_path(profile_id);\n        \n        if !profile_path.exists() {\n            return Err(StorageError::ProfileNotFound(profile_id.name.clone()).into());\n        }\n        \n        // Charger les donn√©es du profil\n        let profile_data = fs::read_to_string(\u0026profile_path)?;\n        let profile: ProfileData = serde_json::from_str(\u0026profile_data)?;\n        \n        // V√©rifier le mot de passe\n        if !verify_password(password, \u0026profile.auth.password_hash)? {\n            return Err(StorageError::InvalidPassword.into());\n        }\n        \n        // D√©river la cl√© de d√©chiffrement\n        let salt = argon2::password_hash::SaltString::from_b64(\u0026profile.auth.salt)\n            .map_err(|_| StorageError::CorruptedData)?;\n        let config = match profile.auth.config_type.as_str() {\n            \"balanced\" =\u003e Argon2Config::balanced(),\n            \"secure\" =\u003e Argon2Config::secure(),\n            \"fast_insecure\" =\u003e Argon2Config::fast_insecure(),\n            _ =\u003e return Err(StorageError::CorruptedData.into()),\n        };\n        \n        let encryption_key_bytes = derive_key_32(password, \u0026salt, \u0026config)?;\n        let encryption_key = AeadKeyRef::from_bytes(encryption_key_bytes);\n        \n        // D√©chiffrer la cl√© priv√©e d'identit√©\n        let identity_private_bytes = decrypt(\n            \u0026encryption_key,\n            b\"miaou_identity_v0.1.0\",\n            \u0026profile.keys.encrypted_private_identity,\n        )?;\n        \n        // Reconstruire la paire de cl√©s\n        if identity_private_bytes.len() != 32 {\n            return Err(StorageError::CorruptedData.into());\n        }\n        let mut private_key_array = [0u8; 32];\n        private_key_array.copy_from_slice(\u0026identity_private_bytes);\n        let identity_keypair = Keypair::from_private_bytes(private_key_array)?;\n        \n        // V√©rifier l'int√©grit√© de la cl√© publique\n        if identity_keypair.public.to_bytes() != profile.keys.public_identity {\n            return Err(StorageError::CorruptedData.into());\n        }\n        \n        // Mettre √† jour l'horodatage d'acc√®s\n        self.update_last_access(\u0026profile_id)?;\n        \n        Ok(ProfileHandle {\n            metadata: profile.metadata,\n            identity_keypair,\n            settings: profile.settings,\n        })\n    }\n    \n    /// Liste tous les profils disponibles\n    pub fn list_profiles(\u0026self) -\u003e Result\u003cVec\u003cProfileInfo\u003e\u003e {\n        let profiles_dir = self.storage_root.join(\"profiles\");\n        let mut profiles = Vec::new();\n        \n        if !profiles_dir.exists() {\n            return Ok(profiles);\n        }\n        \n        for entry in fs::read_dir(\u0026profiles_dir)? {\n            let entry = entry?;\n            let path = entry.path();\n            \n            if path.extension().and_then(|s| s.to_str()) == Some(\"json\") {\n                if let Ok(data) = fs::read_to_string(\u0026path) {\n                    if let Ok(profile) = serde_json::from_str::\u003cProfileData\u003e(\u0026data) {\n                        profiles.push(ProfileInfo {\n                            id: profile.metadata.id,\n                            name: profile.metadata.name,\n                            created: profile.metadata.created,\n                            last_access: profile.metadata.last_access,\n                            public_key_fingerprint: hex::encode(profile.keys.key_fingerprint),\n                        });\n                    }\n                }\n            }\n        }\n        \n        // Trier par date de derni√®re utilisation\n        profiles.sort_by(|a, b| b.last_access.cmp(\u0026a.last_access));\n        \n        Ok(profiles)\n    }\n    \n    /// Supprime un profil\n    pub fn delete_profile(\u0026self, profile_id: \u0026ProfileId) -\u003e Result\u003c()\u003e {\n        let profile_path = self.get_profile_path(profile_id);\n        \n        if !profile_path.exists() {\n            return Err(StorageError::ProfileNotFound(profile_id.name.clone()).into());\n        }\n        \n        fs::remove_file(\u0026profile_path)?;\n        \n        // TODO: Supprimer aussi les donn√©es associ√©es (keystore, messages, etc.)\n        \n        Ok(())\n    }\n    \n    /// Met √† jour l'horodatage de derni√®re utilisation\n    fn update_last_access(\u0026self, profile_id: \u0026ProfileId) -\u003e Result\u003c()\u003e {\n        let profile_path = self.get_profile_path(profile_id);\n        \n        if let Ok(data) = fs::read_to_string(\u0026profile_path) {\n            if let Ok(mut profile) = serde_json::from_str::\u003cProfileData\u003e(\u0026data) {\n                profile.metadata.last_access = Utc::now();\n                let updated_data = serde_json::to_string_pretty(\u0026profile)?;\n                fs::write(\u0026profile_path, updated_data)?;\n            }\n        }\n        \n        Ok(())\n    }\n    \n    /// Retourne le chemin du fichier de profil\n    fn get_profile_path(\u0026self, profile_id: \u0026ProfileId) -\u003e PathBuf {\n        self.storage_root\n            .join(\"profiles\")\n            .join(format!(\"{}.json\", profile_id.safe_name()))\n    }\n}\n\n/// Identifiant unique d'un profil\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct ProfileId {\n    pub name: String,\n    pub hash: String, // Hash du nom pour √©viter les collisions\n}\n\nimpl ProfileId {\n    pub fn new(name: \u0026str) -\u003e Self {\n        let hash = hex::encode(blake3_32(name.as_bytes()));\n        Self {\n            name: name.to_string(),\n            hash,\n        }\n    }\n    \n    pub fn safe_name(\u0026self) -\u003e String {\n        format!(\"{}_{}\", sanitize_filename(\u0026self.name), \u0026self.hash[..8])\n    }\n}\n\n/// Informations publiques sur un profil\n#[derive(Debug, Clone)]\npub struct ProfileInfo {\n    pub id: ProfileId,\n    pub name: String,\n    pub created: DateTime\u003cUtc\u003e,\n    pub last_access: DateTime\u003cUtc\u003e,\n    pub public_key_fingerprint: String,\n}\n\n/// Handle vers un profil charg√© en m√©moire\npub struct ProfileHandle {\n    pub metadata: ProfileMetadata,\n    pub identity_keypair: Keypair,\n    pub settings: ProfileSettings,\n}\n\n/// M√©tadonn√©es d'un profil\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ProfileMetadata {\n    pub id: ProfileId,\n    pub name: String,\n    pub version: String,\n    pub created: DateTime\u003cUtc\u003e,\n    pub last_access: DateTime\u003cUtc\u003e,\n}\n\n/// Donn√©es d'authentification\n#[derive(Debug, Serialize, Deserialize)]\npub struct AuthenticationData {\n    pub password_hash: String,\n    pub salt: String,\n    pub config_type: String,\n}\n\n/// Donn√©es cryptographiques\n#[derive(Debug)]\npub struct KeyData {\n    pub public_identity: [u8; 32],\n    pub encrypted_private_identity: crate::crypto::aead::SealedData,\n    pub key_fingerprint: [u8; 32],\n}\n\n// S√©rialisation custom pour KeyData\nimpl Serialize for KeyData {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e std::result::Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        use serde::ser::SerializeStruct;\n        let mut state = serializer.serialize_struct(\"KeyData\", 3)?;\n        state.serialize_field(\"public_identity\", \u0026hex::encode(self.public_identity))?;\n        state.serialize_field(\"encrypted_private_nonce\", \u0026hex::encode(self.encrypted_private_identity.nonce))?;\n        state.serialize_field(\"encrypted_private_ciphertext\", \u0026hex::encode(\u0026self.encrypted_private_identity.ciphertext))?;\n        state.serialize_field(\"key_fingerprint\", \u0026hex::encode(self.key_fingerprint))?;\n        state.end()\n    }\n}\n\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for KeyData {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e std::result::Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        use serde::de::{self, MapAccess, Visitor};\n        use std::fmt;\n        \n        #[derive(Deserialize)]\n        #[serde(field_identifier, rename_all = \"snake_case\")]\n        enum Field { PublicIdentity, EncryptedPrivateNonce, EncryptedPrivateCiphertext, KeyFingerprint }\n        \n        struct KeyDataVisitor;\n        \n        impl\u003c'de\u003e Visitor\u003c'de\u003e for KeyDataVisitor {\n            type Value = KeyData;\n            \n            fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                formatter.write_str(\"struct KeyData\")\n            }\n            \n            fn visit_map\u003cV\u003e(self, mut map: V) -\u003e std::result::Result\u003cKeyData, V::Error\u003e\n            where\n                V: MapAccess\u003c'de\u003e,\n            {\n                let mut public_identity: Option\u003cString\u003e = None;\n                let mut encrypted_private_nonce: Option\u003cString\u003e = None;\n                let mut encrypted_private_ciphertext: Option\u003cString\u003e = None;\n                let mut key_fingerprint: Option\u003cString\u003e = None;\n                \n                while let Some(key) = map.next_key()? {\n                    match key {\n                        Field::PublicIdentity =\u003e {\n                            if public_identity.is_some() {\n                                return Err(de::Error::duplicate_field(\"public_identity\"));\n                            }\n                            public_identity = Some(map.next_value()?);\n                        }\n                        Field::EncryptedPrivateNonce =\u003e {\n                            if encrypted_private_nonce.is_some() {\n                                return Err(de::Error::duplicate_field(\"encrypted_private_nonce\"));\n                            }\n                            encrypted_private_nonce = Some(map.next_value()?);\n                        }\n                        Field::EncryptedPrivateCiphertext =\u003e {\n                            if encrypted_private_ciphertext.is_some() {\n                                return Err(de::Error::duplicate_field(\"encrypted_private_ciphertext\"));\n                            }\n                            encrypted_private_ciphertext = Some(map.next_value()?);\n                        }\n                        Field::KeyFingerprint =\u003e {\n                            if key_fingerprint.is_some() {\n                                return Err(de::Error::duplicate_field(\"key_fingerprint\"));\n                            }\n                            key_fingerprint = Some(map.next_value()?);\n                        }\n                    }\n                }\n                \n                let public_identity = public_identity.ok_or_else(|| de::Error::missing_field(\"public_identity\"))?;\n                let encrypted_private_nonce = encrypted_private_nonce.ok_or_else(|| de::Error::missing_field(\"encrypted_private_nonce\"))?;\n                let encrypted_private_ciphertext = encrypted_private_ciphertext.ok_or_else(|| de::Error::missing_field(\"encrypted_private_ciphertext\"))?;\n                let key_fingerprint = key_fingerprint.ok_or_else(|| de::Error::missing_field(\"key_fingerprint\"))?;\n                \n                // D√©coder hex\n                let public_bytes = hex::decode(\u0026public_identity).map_err(de::Error::custom)?;\n                let nonce_bytes = hex::decode(\u0026encrypted_private_nonce).map_err(de::Error::custom)?;\n                let ciphertext_bytes = hex::decode(\u0026encrypted_private_ciphertext).map_err(de::Error::custom)?;\n                let fingerprint_bytes = hex::decode(\u0026key_fingerprint).map_err(de::Error::custom)?;\n                \n                if public_bytes.len() != 32 {\n                    return Err(de::Error::custom(\"Invalid public key length\"));\n                }\n                if nonce_bytes.len() != 12 {\n                    return Err(de::Error::custom(\"Invalid nonce length\"));\n                }\n                if fingerprint_bytes.len() != 32 {\n                    return Err(de::Error::custom(\"Invalid fingerprint length\"));\n                }\n                \n                let mut public_identity = [0u8; 32];\n                public_identity.copy_from_slice(\u0026public_bytes);\n                \n                let mut nonce = [0u8; 12];\n                nonce.copy_from_slice(\u0026nonce_bytes);\n                \n                let mut key_fingerprint = [0u8; 32];\n                key_fingerprint.copy_from_slice(\u0026fingerprint_bytes);\n                \n                Ok(KeyData {\n                    public_identity,\n                    encrypted_private_identity: crate::crypto::aead::SealedData::new(nonce, ciphertext_bytes),\n                    key_fingerprint,\n                })\n            }\n        }\n        \n        const FIELDS: \u0026[\u0026str] = \u0026[\"public_identity\", \"encrypted_private_nonce\", \"encrypted_private_ciphertext\", \"key_fingerprint\"];\n        deserializer.deserialize_struct(\"KeyData\", FIELDS, KeyDataVisitor)\n    }\n}\n\n/// Param√®tres utilisateur\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ProfileSettings {\n    pub auto_accept_friends: bool,\n    pub encryption_level: String,\n    pub backup_enabled: bool,\n    pub theme: String,\n}\n\nimpl Default for ProfileSettings {\n    fn default() -\u003e Self {\n        Self {\n            auto_accept_friends: false,\n            encryption_level: \"balanced\".to_string(),\n            backup_enabled: true,\n            theme: \"auto\".to_string(),\n        }\n    }\n}\n\n/// Structure compl√®te d'un profil stock√©\n#[derive(Debug, Serialize, Deserialize)]\nstruct ProfileData {\n    metadata: ProfileMetadata,\n    auth: AuthenticationData,\n    keys: KeyData,\n    settings: ProfileSettings,\n}\n\n/// Nettoie un nom de fichier pour qu'il soit safe sur tous les syst√®mes\nfn sanitize_filename(name: \u0026str) -\u003e String {\n    name.chars()\n        .filter_map(|c| match c {\n            'a'..='z' | 'A'..='Z' | '0'..='9' | '-' | '_' =\u003e Some(c),\n            _ =\u003e Some('_'),\n        })\n        .collect::\u003cString\u003e()\n        .chars()\n        .take(32) // Limiter la longueur\n        .collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use tempfile::TempDir;\n    \n    #[test]\n    fn test_profile_creation_and_loading() {\n        let temp_dir = TempDir::new().unwrap();\n        let storage = SecureStorage::new(temp_dir.path()).unwrap();\n        \n        let password = SecretString::new(\"test_password_123\".to_string());\n        \n        // Cr√©er un profil\n        let profile_id = storage.create_profile(\"alice\", \u0026password).unwrap();\n        assert_eq!(profile_id.name, \"alice\");\n        \n        // Charger le profil\n        let profile = storage.load_profile(\u0026profile_id, \u0026password).unwrap();\n        assert_eq!(profile.metadata.name, \"alice\");\n        \n        // Mauvais mot de passe\n        let wrong_password = SecretString::new(\"wrong_password\".to_string());\n        assert!(storage.load_profile(\u0026profile_id, \u0026wrong_password).is_err());\n    }\n    \n    #[test]\n    fn test_profile_listing() {\n        let temp_dir = TempDir::new().unwrap();\n        let storage = SecureStorage::new(temp_dir.path()).unwrap();\n        \n        let password = SecretString::new(\"test_password_123\".to_string());\n        \n        // Cr√©er plusieurs profils\n        storage.create_profile(\"alice\", \u0026password).unwrap();\n        storage.create_profile(\"bob\", \u0026password).unwrap();\n        \n        // Lister les profils\n        let profiles = storage.list_profiles().unwrap();\n        assert_eq!(profiles.len(), 2);\n        \n        let names: Vec\u003c_\u003e = profiles.iter().map(|p| \u0026p.name).collect();\n        assert!(names.contains(\u0026\u0026\"alice\".to_string()));\n        assert!(names.contains(\u0026\u0026\"bob\".to_string()));\n    }\n    \n    #[test]\n    fn test_profile_deletion() {\n        let temp_dir = TempDir::new().unwrap();\n        let storage = SecureStorage::new(temp_dir.path()).unwrap();\n        \n        let password = SecretString::new(\"test_password_123\".to_string());\n        \n        // Cr√©er un profil\n        let profile_id = storage.create_profile(\"test_user\", \u0026password).unwrap();\n        \n        // V√©rifier qu'il existe\n        assert!(storage.load_profile(\u0026profile_id, \u0026password).is_ok());\n        \n        // Le supprimer\n        storage.delete_profile(\u0026profile_id).unwrap();\n        \n        // V√©rifier qu'il n'existe plus\n        assert!(storage.load_profile(\u0026profile_id, \u0026password).is_err());\n    }\n}","traces":[{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":63},{"path":["/","home","seb","Dev","miaou","templates","rustdoc_template.rs"],"content":"//! # Miaou v{VERSION} \"{VERSION_NAME}\"\n//! \n//! **Phase {PHASE_NUMBER} :** {PHASE_DESCRIPTION}\n//! \n//! ## Vue d'ensemble\n//! \n//! {VERSION_OVERVIEW_DESCRIPTION}\n//! \n//! Cette version de Miaou impl√©mente {KEY_FEATURES_SUMMARY} selon les principes\n//! de s√©curit√©, performance et d√©centralisation du projet.\n//! \n//! ## Architecture\n//! \n//! ```text\n//! {ASCII_ARCHITECTURE_DIAGRAM}\n//! ```\n//! \n//! ## Modules principaux\n//! \n//! - [`crypto`] - Primitives cryptographiques audit√©es (Phase 1+)\n//! - [`network`] - Communication P2P d√©centralis√©e (Phase 2+)\n//! - [`blockchain`] - Syst√®me √©conomique et croquettes (Phase 3+)\n//! - [`interfaces`] - Applications multi-plateformes (Phase 4+)\n//! - [`bridges`] - Interop√©rabilit√© protocoles existants (Phase 5+)\n//! - [`advanced`] - Fonctionnalit√©s avanc√©es et IA (Phase 6+)\n//! - [`governance`] - Gouvernance d√©centralis√©e et DAO (Phase 7+)\n//! \n//! ## Exemples d'usage rapide\n//! \n//! ### Cryptographie (Phase 1+)\n//! ```rust\n//! use miaou::crypto::{ChaCha20Poly1305, Ed25519};\n//! \n//! // Chiffrement authentifi√©\n//! let key = ChaCha20Poly1305::generate_key()?;\n//! let encrypted = key.encrypt(b\"Hello, Miaou!\", b\"unique_nonce_12\")?;\n//! let decrypted = key.decrypt(\u0026encrypted, b\"unique_nonce_12\")?;\n//! \n//! // Signatures num√©riques\n//! let keypair = Ed25519::generate_keypair()?;\n//! let signature = keypair.sign(b\"Message to sign\")?;\n//! assert!(keypair.verify(b\"Message to sign\", \u0026signature)?);\n//! ```\n//! \n//! ### R√©seau P2P (Phase 2+)\n//! ```rust\n//! use miaou::network::{P2PNode, PeerDiscovery};\n//! \n//! let mut node = P2PNode::new().await?;\n//! node.start_discovery().await?;\n//! \n//! // Envoi de message chiffr√©\n//! let peer_id = node.discover_peers().await?.first().unwrap();\n//! node.send_encrypted_message(peer_id, b\"Hello from Miaou!\").await?;\n//! ```\n//! \n//! ### Interface utilisateur (Phase 4+)\n//! ```rust\n//! use miaou::interfaces::{DesktopApp, MobileApp};\n//! \n//! // Application desktop\n//! let app = DesktopApp::new().await?;\n//! app.show_main_window().await?;\n//! \n//! // Support mobile\n//! #[cfg(target_os = \"android\")]\n//! let mobile_app = MobileApp::initialize_android()?;\n//! \n//! #[cfg(target_os = \"ios\")]\n//! let mobile_app = MobileApp::initialize_ios()?;\n//! ```\n//! \n//! ## S√©curit√© et audit\n//! \n//! ### Propri√©t√©s cryptographiques garanties\n//! \n//! - **Confidentialit√© :** Chiffrement ChaCha20-Poly1305 authenticated\n//! - **Int√©grit√© :** AEAD (Authenticated Encryption with Associated Data)\n//! - **Authenticit√© :** Signatures Ed25519 avec v√©rification obligatoire\n//! - **Forward Secrecy :** Double Ratchet pour messagerie (Phase 2+)\n//! - **Post-Quantum Ready :** Architecture pr√©par√©e aux algorithmes quantiques\n//! \n//! ### Standards et conformit√©\n//! \n//! - **RFC 8439 :** ChaCha20-Poly1305 AEAD\n//! - **RFC 8032 :** EdDSA signatures avec Ed25519\n//! - **RFC 3526 :** Diffie-Hellman groups pour √©changes de cl√©s\n//! - **NIST SP 800-185 :** SHAKE et fonctions d√©riv√©es\n//! - **Signal Protocol :** Double Ratchet pour messagerie s√©curis√©e\n//! \n//! ### Audit et tests\n//! \n//! ```rust\n//! // Tests avec vecteurs NIST officiels\n//! #[cfg(test)]\n//! mod crypto_known_answer_tests {\n//!     use super::*;\n//!     \n//!     #[test]\n//!     fn test_chacha20_poly1305_nist_vectors() {\n//!         // Vecteurs de test officiels IETF RFC 8439\n//!         let test_vectors = load_nist_test_vectors();\n//!         for vector in test_vectors {\n//!             let result = ChaCha20Poly1305::encrypt(\u0026vector.key, \u0026vector.plaintext, \u0026vector.nonce);\n//!             assert_eq!(result.unwrap(), vector.expected_ciphertext);\n//!         }\n//!     }\n//! }\n//! ```\n//! \n//! ## Performance et benchmarks\n//! \n//! ### Objectifs de performance par phase\n//! \n//! | Phase | M√©trique | Objectif | Actuel |\n//! |-------|----------|----------|---------|\n//! | 1 | Chiffrement | \u003e1GB/s | {CRYPTO_PERF} |\n//! | 2 | Latence P2P | \u003c100ms | {NETWORK_LATENCY} |\n//! | 3 | Tx/seconde | \u003e1000 | {BLOCKCHAIN_TPS} |\n//! | 4 | Startup time | \u003c2s | {STARTUP_TIME} |\n//! | 5 | Bridge latency | \u003c200ms | {BRIDGE_LATENCY} |\n//! | 6 | AI response | \u003c500ms | {AI_RESPONSE_TIME} |\n//! | 7 | Governance | \u003e10k votes/min | {GOVERNANCE_THROUGHPUT} |\n//! \n//! ### Benchmarks automatis√©s\n//! \n//! ```bash\n//! # Ex√©cution des benchmarks\n//! cargo bench\n//! \n//! # G√©n√©ration des rapports\n//! cargo bench -- --output-format html\n//! ```\n//! \n//! ## Compatibilit√© et plateformes\n//! \n//! ### Plateformes support√©es\n//! \n//! - **Desktop :** Linux, macOS, Windows (via Tauri)\n//! - **Mobile :** Android (API 21+), iOS (13.0+) \n//! - **Web :** Tous navigateurs modernes avec WebAssembly\n//! - **Serveur :** Linux x86_64, ARM64\n//! \n//! ### Versions Rust\n//! \n//! - **Minimum support√© :** Rust 1.70.0\n//! - **Recommand√© :** Rust stable (derni√®re version)\n//! - **Features requises :** `std`, editions 2021\n//! \n//! ## Changelog et migration\n//! \n//! ### Changements depuis v{PREVIOUS_VERSION}\n//! \n//! #### üéâ Nouvelles fonctionnalit√©s\n//! - {NEW_FEATURE_1}\n//! - {NEW_FEATURE_2}\n//! - {NEW_FEATURE_3}\n//! \n//! #### üîÑ Am√©liorations\n//! - {IMPROVEMENT_1}\n//! - {IMPROVEMENT_2}\n//! \n//! #### ‚ö†Ô∏è Breaking changes\n//! - {BREAKING_CHANGE_1}\n//! - {BREAKING_CHANGE_2}\n//! \n//! #### üêõ Corrections\n//! - {BUG_FIX_1}\n//! - {BUG_FIX_2}\n//! \n//! ### Guide de migration\n//! \n//! ```rust\n//! // Ancien code (v{PREVIOUS_VERSION})\n//! let old_api = OldMiaouClient::new();\n//! old_api.deprecated_method();\n//! \n//! // Nouveau code (v{VERSION})\n//! let new_api = MiaouClient::new().await?;\n//! new_api.improved_method().await?;\n//! ```\n//! \n//! ## Contribution et d√©veloppement\n//! \n//! ### Structure du projet\n//! \n//! ```text\n//! miaou/\n//! ‚îú‚îÄ‚îÄ src/\n//! ‚îÇ   ‚îú‚îÄ‚îÄ crypto/          # Primitives cryptographiques\n//! ‚îÇ   ‚îú‚îÄ‚îÄ network/         # Communication P2P\n//! ‚îÇ   ‚îú‚îÄ‚îÄ blockchain/      # Syst√®me √©conomique\n//! ‚îÇ   ‚îú‚îÄ‚îÄ interfaces/      # Applications utilisateur\n//! ‚îÇ   ‚îî‚îÄ‚îÄ lib.rs          # Point d'entr√©e principal\n//! ‚îú‚îÄ‚îÄ tests/\n//! ‚îÇ   ‚îú‚îÄ‚îÄ integration/     # Tests d'int√©gration\n//! ‚îÇ   ‚îú‚îÄ‚îÄ crypto_vectors/  # Vecteurs de test crypto\n//! ‚îÇ   ‚îî‚îÄ‚îÄ benchmarks/      # Benchmarks performance\n//! ‚îú‚îÄ‚îÄ docs/               # Documentation compl√®te\n//! ‚îî‚îÄ‚îÄ examples/           # Exemples d'usage\n//! ```\n//! \n//! ### Standards de d√©veloppement\n//! \n//! - **TDD obligatoire :** Tests avant code\n//! - **Couverture ‚â•90% :** Validation automatique\n//! - **Documentation :** 100% APIs publiques document√©es\n//! - **S√©curit√© :** Audit continu des d√©pendances\n//! - **Performance :** Benchmarks sur chaque PR\n//! \n//! ## Ressources et liens\n//! \n//! - **Repository :** \u003chttps://github.com/yrbane/miaou\u003e\n//! - **Documentation :** \u003chttps://docs.rs/miaou\u003e\n//! - **Changelog :** \u003chttps://github.com/yrbane/miaou/blob/main/CHANGELOG.md\u003e\n//! - **Issues :** \u003chttps://github.com/yrbane/miaou/issues\u003e\n//! - **Discussions :** \u003chttps://github.com/yrbane/miaou/discussions\u003e\n//! \n//! ---\n//! \n//! *Miaou - Communication d√©centralis√©e, s√©curis√©e et libre* üê±\n\n#![doc = include_str!(\"../README.md\")]\n#![doc(\n    html_logo_url = \"https://raw.githubusercontent.com/yrbane/miaou/main/assets/logo.svg\",\n    html_favicon_url = \"https://raw.githubusercontent.com/yrbane/miaou/main/assets/favicon.ico\",\n    html_root_url = \"https://docs.rs/miaou/\"\n)]\n\n// Configuration de documentation avanc√©e\n#![warn(missing_docs)]\n#![warn(rustdoc::missing_doc_code_examples)]\n#![warn(rustdoc::broken_intra_doc_links)]\n\n// Re-exports publics pour API simplifi√©e\npub use crypto::*;\npub use network::*;\npub use interfaces::*;\n\n// Modules principaux\npub mod crypto;\npub mod network;\npub mod blockchain;\npub mod interfaces;\npub mod bridges;\npub mod advanced;\npub mod governance;\n\n// Modules utilitaires\npub mod error;\npub mod config;\npub mod logging;","traces":[],"covered":0,"coverable":0},{"path":["/","home","seb","Dev","miaou","tests","crypto","basic_tests.rs"],"content":"//! Tests de base pour validation de Phase 1\n//! \n//! Tests simplifi√©s pour valider l'architecture cryptographique de base.\n\nuse miaou::crypto::{\n    hashing::{Blake3Hasher, Blake3Output, HashingEngine, Argon2Hasher, Argon2Config},\n    primitives::{random_bytes, secure_compare},\n    CryptoResult,\n};\n\n#[test]\nfn test_blake3_basic() {\n    let data = b\"test data for blake3\";\n    let hash1 = Blake3Hasher::hash(data);\n    let hash2 = Blake3Hasher::hash(data);\n    \n    // M√™me donn√©es = m√™me hash\n    assert_eq!(hash1, hash2);\n    \n    // Donn√©es diff√©rentes = hash diff√©rents\n    let hash3 = Blake3Hasher::hash(b\"different data\");\n    assert_ne!(hash1, hash3);\n}\n\n#[test]\nfn test_blake3_hex_encoding() {\n    let data = b\"test\";\n    let hash = Blake3Hasher::hash(data);\n    \n    let hex_string = hash.to_hex();\n    assert!(!hex_string.is_empty());\n    assert_eq!(hex_string.len(), 64); // 32 bytes * 2 chars/byte\n    \n    let decoded = Blake3Output::from_hex(\u0026hex_string).unwrap();\n    assert_eq!(hash, decoded);\n}\n\n#[test]\nfn test_random_bytes_generation() {\n    let bytes1 = random_bytes(32).unwrap();\n    let bytes2 = random_bytes(32).unwrap();\n    \n    assert_eq!(bytes1.len(), 32);\n    assert_eq!(bytes2.len(), 32);\n    assert_ne!(bytes1, bytes2); // Tr√®s improbable qu'ils soient identiques\n}\n\n#[test]\nfn test_secure_compare() {\n    let data1 = vec![1, 2, 3, 4, 5];\n    let data2 = vec![1, 2, 3, 4, 5];\n    let data3 = vec![1, 2, 3, 4, 6];\n    \n    assert!(secure_compare(\u0026data1, \u0026data2));\n    assert!(!secure_compare(\u0026data1, \u0026data3));\n}\n\n#[test]\nfn test_argon2_basic() {\n    let password = b\"test_password\";\n    let salt = b\"test_salt_16_bytes\";\n    let config = Argon2Config::fast_insecure();\n    \n    let key1 = Argon2Hasher::derive_key(password, salt, \u0026config).unwrap();\n    let key2 = Argon2Hasher::derive_key(password, salt, \u0026config).unwrap();\n    \n    assert_eq!(key1, key2);\n    assert_eq!(key1.len(), config.output_length as usize);\n}\n\n#[test]\nfn test_argon2_password_verification() {\n    let password = b\"secret_password\";\n    let config = Argon2Config::fast_insecure();\n    \n    let hash = Argon2Hasher::hash_password(password, \u0026config).unwrap();\n    \n    assert!(Argon2Hasher::verify_password(password, \u0026hash).unwrap());\n    assert!(!Argon2Hasher::verify_password(b\"wrong_password\", \u0026hash).unwrap());\n}\n\n#[test]\nfn test_crypto_constants() {\n    use miaou::crypto::{NONCE_SIZE, KEY_SIZE, SIGNATURE_SIZE, PUBLIC_KEY_SIZE};\n    \n    assert_eq!(NONCE_SIZE, 12);\n    assert_eq!(KEY_SIZE, 32);\n    assert_eq!(SIGNATURE_SIZE, 64);\n    assert_eq!(PUBLIC_KEY_SIZE, 32);\n}\n\n#[test]\nfn test_crypto_availability() {\n    assert!(miaou::initialize().is_ok());\n}\n\n#[test]\nfn test_blake3_context_different() {\n    let data = b\"same data\";\n    let hash1 = Blake3Hasher::hash_with_context(data, \"context1\");\n    let hash2 = Blake3Hasher::hash_with_context(data, \"context2\");\n    \n    assert_ne!(hash1, hash2);\n}\n\n#[test]\nfn test_blake3_keyed_hashing() {\n    let key = [42u8; 32];\n    let data = b\"test data\";\n    \n    let hash1 = Blake3Hasher::hash_keyed(\u0026key, data);\n    let hash2 = Blake3Hasher::hash_keyed(\u0026key, data);\n    \n    assert_eq!(hash1, hash2);\n    \n    // Avec une cl√© diff√©rente\n    let key2 = [43u8; 32];\n    let hash3 = Blake3Hasher::hash_keyed(\u0026key2, data);\n    assert_ne!(hash1, hash3);\n}\n\n#[test] \nfn test_blake3_multiple_items() {\n    let items = [b\"part1\".as_slice(), b\"part2\".as_slice(), b\"part3\".as_slice()];\n    let hash1 = Blake3Hasher::hash_multiple(\u0026items);\n    \n    // M√™me donn√©es = m√™me hash\n    let hash2 = Blake3Hasher::hash_multiple(\u0026items);\n    assert_eq!(hash1, hash2);\n    \n    // Ordre diff√©rent = hash diff√©rent\n    let items_reordered = [b\"part2\".as_slice(), b\"part1\".as_slice(), b\"part3\".as_slice()];\n    let hash3 = Blake3Hasher::hash_multiple(\u0026items_reordered);\n    assert_ne!(hash1, hash3);\n}\n\n#[test]\nfn test_performance_basic() {\n    use std::time::Instant;\n    \n    let data = vec![0x42; 1024]; // 1KB\n    let start = Instant::now();\n    \n    for _ in 0..1000 {\n        let _hash = Blake3Hasher::hash(\u0026data);\n    }\n    \n    let duration = start.elapsed();\n    println!(\"1000 hashes de 1KB: {:?}\", duration);\n    \n    // Test basique de performance (devrait √™tre rapide)\n    assert!(duration.as_millis() \u003c 1000);\n}","traces":[],"covered":0,"coverable":0},{"path":["/","home","seb","Dev","miaou","tests","crypto","integration_tests.rs"],"content":"//! Tests d'int√©gration cryptographiques\n//! \n//! Tests de sc√©narios r√©alistes combinant plusieurs composants cryptographiques.\n\nuse miaou::crypto::{\n    encryption::{ChaCha20Poly1305Cipher, EncryptionEngine},\n    signing::{Ed25519KeyPair, Ed25519Signer, SigningEngine},\n    hashing::{Blake3Hasher, Argon2Hasher, Argon2Config},\n    keyring::{KeyStore, KeyStoreConfig, SecretKey, KeyPair},\n    primitives::{derive_subkey, SecureIdGenerator},\n};\n\n/// Test d'un sc√©nario complet de communication s√©curis√©e\n#[test]\nfn test_secure_communication_scenario() {\n    // Alice et Bob g√©n√®rent leurs paires de cl√©s\n    let alice_keypair = Ed25519KeyPair::generate().unwrap();\n    let bob_keypair = Ed25519KeyPair::generate().unwrap();\n    \n    // Alice veut envoyer un message chiffr√© et sign√© √† Bob\n    let message = b\"Message secret d'Alice pour Bob dans Miaou\";\n    \n    // 1. Alice g√©n√®re une cl√© de session √©ph√©m√®re\n    let session_cipher = ChaCha20Poly1305Cipher::generate_key().unwrap();\n    \n    // 2. Alice chiffre le message avec la cl√© de session\n    let encrypted_message = session_cipher.encrypt_with_random_nonce(message).unwrap();\n    \n    // 3. Alice signe le message chiffr√© pour authentification\n    let signature = alice_keypair.sign(\u0026encrypted_message.ciphertext).unwrap();\n    \n    // 4. Alice s√©rialise tout pour transmission\n    let communication_packet = CommunicationPacket {\n        encrypted_message,\n        signature: signature.to_bytes(),\n        sender_public_key: alice_keypair.public_key().to_bytes(),\n    };\n    \n    let serialized = bincode::serialize(\u0026communication_packet).unwrap();\n    \n    // === TRANSMISSION R√âSEAU (simul√©e) ===\n    \n    // 5. Bob re√ßoit et d√©s√©rialise\n    let received_packet: CommunicationPacket = bincode::deserialize(\u0026serialized).unwrap();\n    \n    // 6. Bob v√©rifie la signature\n    let alice_public_key = miaou::crypto::signing::Ed25519PublicKey::from_bytes(\n        \u0026received_packet.sender_public_key\n    ).unwrap();\n    let received_signature = miaou::crypto::signing::Ed25519Signature::from_bytes(\n        \u0026received_packet.signature\n    ).unwrap();\n    \n    let signature_valid = Ed25519Signer::verify(\n        \u0026alice_public_key,\n        \u0026received_packet.encrypted_message.ciphertext,\n        \u0026received_signature\n    ).unwrap();\n    \n    assert!(signature_valid, \"Signature invalide\");\n    \n    // 7. Bob d√©chiffre le message (il faudrait un √©change de cl√©s en pratique)\n    let decrypted = session_cipher.decrypt_with_nonce(\u0026received_packet.encrypted_message).unwrap();\n    \n    assert_eq!(decrypted, message);\n}\n\n#[derive(serde::Serialize, serde::Deserialize)]\nstruct CommunicationPacket {\n    encrypted_message: miaou::crypto::encryption::EncryptedData,\n    signature: [u8; 64],\n    sender_public_key: [u8; 32],\n}\n\n/// Test d'un trousseau de cl√©s complet avec hi√©rarchie\n#[test]\nfn test_hierarchical_key_management() {\n    let config = KeyStoreConfig {\n        argon2_config: Argon2Config::fast_insecure(), // Pour test rapide\n        ..KeyStoreConfig::default()\n    };\n    \n    let mut keystore = KeyStore::new_with_password(b\"master_password_123\", config).unwrap();\n    \n    // Cr√©er une hi√©rarchie de cl√©s\n    let master_seed = b\"master_seed_for_miaou_user_alice\";\n    \n    // Cl√©s de niveau 1 : par cat√©gorie\n    let encryption_master = derive_subkey(master_seed, \"encryption\", 0);\n    let signing_master = derive_subkey(master_seed, \"signing\", 0);\n    let storage_master = derive_subkey(master_seed, \"storage\", 0);\n    \n    // Cl√©s de niveau 2 : par usage sp√©cifique\n    let message_key = derive_subkey(\u0026encryption_master, \"messages\", 0);\n    let file_key = derive_subkey(\u0026encryption_master, \"files\", 0);\n    let metadata_key = derive_subkey(\u0026storage_master, \"metadata\", 0);\n    \n    // Ajouter au trousseau\n    let keys = vec![\n        (\"encryption_master\", encryption_master.to_vec()),\n        (\"signing_master\", signing_master.to_vec()),\n        (\"storage_master\", storage_master.to_vec()),\n        (\"message_key\", message_key.to_vec()),\n        (\"file_key\", file_key.to_vec()),\n        (\"metadata_key\", metadata_key.to_vec()),\n    ];\n    \n    let mut key_ids = Vec::new();\n    \n    for (name, key_data) in keys {\n        let secret_key = SecretKey::new(\n            key_data,\n            miaou::crypto::keyring::KeyMetadata {\n                key_id: miaou::crypto::primitives::random_array().unwrap(),\n                key_type: miaou::crypto::keyring::KeyType::Derived {\n                    context: name.to_string()\n                },\n                name: name.to_string(),\n                created_at: std::time::SystemTime::now()\n                    .duration_since(std::time::UNIX_EPOCH)\n                    .unwrap()\n                    .as_secs(),\n                expires_at: None,\n                is_active: true,\n                tags: vec![\"hierarchical\".to_string()],\n            }\n        );\n        \n        let key_id = secret_key.metadata().key_id;\n        key_ids.push((name, key_id));\n        keystore.add_secret_key(secret_key).unwrap();\n    }\n    \n    // V√©rifier que toutes les cl√©s sont r√©cup√©rables\n    for (name, key_id) in \u0026key_ids {\n        let retrieved = keystore.get_secret_key(key_id).unwrap();\n        assert!(retrieved.is_some(), \"Cl√© {} non trouv√©e\", name);\n        assert_eq!(retrieved.unwrap().metadata().name, *name);\n    }\n    \n    // Test export/import du trousseau\n    let exported = keystore.export_encrypted().unwrap();\n    \n    let mut new_keystore = KeyStore::new_with_password(\n        b\"master_password_123\", \n        KeyStoreConfig {\n            argon2_config: Argon2Config::fast_insecure(),\n            ..KeyStoreConfig::default()\n        }\n    ).unwrap();\n    \n    new_keystore.import_encrypted(\u0026exported).unwrap();\n    \n    // V√©rifier que l'import a fonctionn√©\n    for (name, key_id) in \u0026key_ids {\n        let retrieved = new_keystore.get_secret_key(key_id).unwrap();\n        assert!(retrieved.is_some(), \"Cl√© {} non trouv√©e apr√®s import\", name);\n    }\n}\n\n/// Test de performance et r√©sistance aux attaques\n#[test]\nfn test_crypto_performance_and_security() {\n    let start = std::time::Instant::now();\n    \n    // Test de performance du chiffrement\n    let cipher = ChaCha20Poly1305Cipher::generate_key().unwrap();\n    let large_data = vec![0x42; 1024 * 1024]; // 1MB\n    \n    let encrypted = cipher.encrypt_with_random_nonce(\u0026large_data).unwrap();\n    let decrypted = cipher.decrypt_with_nonce(\u0026encrypted).unwrap();\n    \n    assert_eq!(decrypted, large_data);\n    \n    let encryption_time = start.elapsed();\n    println!(\"Chiffrement/d√©chiffrement 1MB: {:?}\", encryption_time);\n    \n    // Test de performance des signatures\n    let start = std::time::Instant::now();\n    let keypair = Ed25519KeyPair::generate().unwrap();\n    let message = b\"Message pour test de performance de signature\";\n    \n    for _ in 0..1000 {\n        let signature = keypair.sign(message).unwrap();\n        let valid = keypair.verify(message, \u0026signature).unwrap();\n        assert!(valid);\n    }\n    \n    let signing_time = start.elapsed();\n    println!(\"1000 signatures/v√©rifications: {:?}\", signing_time);\n    \n    // Test de performance du hachage\n    let start = std::time::Instant::now();\n    let data = vec![0x33; 1024 * 1024]; // 1MB\n    \n    for _ in 0..10 {\n        let _hash = Blake3Hasher::hash(\u0026data);\n    }\n    \n    let hashing_time = start.elapsed();\n    println!(\"10 hachages de 1MB: {:?}\", hashing_time);\n    \n    // Les performances doivent √™tre raisonnables (ajustez selon votre mat√©riel)\n    assert!(encryption_time.as_millis() \u003c 1000, \"Chiffrement trop lent\");\n    assert!(signing_time.as_millis() \u003c 1000, \"Signatures trop lentes\");\n    assert!(hashing_time.as_millis() \u003c 1000, \"Hachage trop lent\");\n}\n\n/// Test de s√©curit√© : tentatives d'attaques courantes\n#[test]\nfn test_security_against_common_attacks() {\n    // Test contre r√©utilisation de nonce\n    let cipher = ChaCha20Poly1305Cipher::generate_key().unwrap();\n    let nonce = [0u8; 12]; // Nonce fixe (MAUVAISE PRATIQUE)\n    \n    let message1 = b\"Premier message\";\n    let message2 = b\"Second message\";\n    \n    let ciphertext1 = cipher.encrypt(message1, \u0026nonce).unwrap();\n    let ciphertext2 = cipher.encrypt(message2, \u0026nonce).unwrap();\n    \n    // M√™me nonce = probl√®me de s√©curit√© d√©tectable\n    // En pratique, on ne devrait jamais faire √ßa\n    assert_ne!(ciphertext1, ciphertext2); // Toujours diff√©rents gr√¢ce au contenu\n    \n    // Test contre modification de ciphertext\n    let mut corrupted_ciphertext = ciphertext1.clone();\n    corrupted_ciphertext[0] ^= 1; // Corruption d'un bit\n    \n    let decrypt_result = cipher.decrypt(\u0026corrupted_ciphertext, \u0026nonce);\n    assert!(decrypt_result.is_err(), \"D√©chiffrement corrompu aurait d√ª √©chouer\");\n    \n    // Test contre cl√©s faibles\n    let weak_key = [0u8; 32]; // Cl√© nulle\n    let weak_cipher = ChaCha20Poly1305Cipher::from_key(\u0026weak_key).unwrap();\n    \n    // M√™me avec une cl√© faible, l'algorithme doit fonctionner\n    let encrypted = weak_cipher.encrypt_with_random_nonce(b\"test\").unwrap();\n    let decrypted = weak_cipher.decrypt_with_nonce(\u0026encrypted).unwrap();\n    assert_eq!(decrypted, b\"test\");\n    \n    // Test contre signatures malform√©es\n    let keypair = Ed25519KeyPair::generate().unwrap();\n    let message = b\"Test message\";\n    let valid_signature = keypair.sign(message).unwrap();\n    \n    // Signature avec tous les bits √† 1 (invalide)\n    let invalid_signature = miaou::crypto::signing::Ed25519Signature::from_bytes(\u0026[0xFF; 64]).unwrap();\n    let verification = keypair.verify(message, \u0026invalid_signature).unwrap();\n    assert!(!verification, \"Signature invalide accept√©e\");\n    \n    // Signature avec tous les bits √† 0 (invalide)\n    let zero_signature = miaou::crypto::signing::Ed25519Signature::from_bytes(\u0026[0x00; 64]).unwrap();\n    let verification = keypair.verify(message, \u0026zero_signature).unwrap();\n    assert!(!verification, \"Signature nulle accept√©e\");\n}\n\n/// Test de g√©n√©ration d'identifiants uniques\n#[test]\nfn test_unique_id_generation() {\n    let generator = SecureIdGenerator::new().unwrap();\n    let mut ids = std::collections::HashSet::new();\n    \n    // G√©n√©rer beaucoup d'IDs rapidement\n    for _ in 0..10000 {\n        let id = generator.generate_id();\n        assert!(ids.insert(id), \"ID dupliqu√© d√©tect√©\");\n    }\n    \n    // Test sur plusieurs g√©n√©rateurs (simulation de n≈ìuds diff√©rents)\n    let generator2 = SecureIdGenerator::new().unwrap();\n    let generator3 = SecureIdGenerator::new().unwrap();\n    \n    for _ in 0..1000 {\n        let id1 = generator.generate_id();\n        let id2 = generator2.generate_id();\n        let id3 = generator3.generate_id();\n        \n        assert!(ids.insert(id1));\n        assert!(ids.insert(id2));\n        assert!(ids.insert(id3));\n    }\n    \n    println!(\"G√©n√©r√© {} IDs uniques\", ids.len());\n}\n\n/// Test de sc√©nario de sauvegarde et r√©cup√©ration\n#[test]\nfn test_backup_and_recovery_scenario() {\n    // Simulation d'un utilisateur qui sauvegarde ses cl√©s\n    let original_password = b\"user_password_123\";\n    let config = KeyStoreConfig {\n        argon2_config: Argon2Config::fast_insecure(),\n        ..KeyStoreConfig::default()\n    };\n    \n    let mut original_keystore = KeyStore::new_with_password(original_password, config.clone()).unwrap();\n    \n    // Cr√©er plusieurs cl√©s importantes\n    let encryption_keypair = KeyPair::generate_ed25519(\"main_encryption\".to_string(), vec![\"primary\".to_string()]).unwrap();\n    let signing_keypair = KeyPair::generate_ed25519(\"main_signing\".to_string(), vec![\"primary\".to_string()]).unwrap();\n    \n    let encryption_key_id = encryption_keypair.private_key().metadata().key_id;\n    let signing_key_id = signing_keypair.private_key().metadata().key_id;\n    \n    original_keystore.add_secret_key(\n        SecretKey::new(\n            encryption_keypair.private_key().key_data().to_vec(),\n            encryption_keypair.private_key().metadata().clone()\n        )\n    ).unwrap();\n    \n    original_keystore.add_secret_key(\n        SecretKey::new(\n            signing_keypair.private_key().key_data().to_vec(),\n            signing_keypair.private_key().metadata().clone()\n        )\n    ).unwrap();\n    \n    // Sauvegarder\n    let backup_data = original_keystore.export_encrypted().unwrap();\n    \n    // Simulation : l'utilisateur perd son trousseau et doit le restaurer\n    let mut recovered_keystore = KeyStore::new_with_password(original_password, config).unwrap();\n    recovered_keystore.import_encrypted(\u0026backup_data).unwrap();\n    \n    // V√©rifier que les cl√©s sont r√©cup√©r√©es\n    let recovered_encryption = recovered_keystore.get_secret_key(\u0026encryption_key_id).unwrap();\n    let recovered_signing = recovered_keystore.get_secret_key(\u0026signing_key_id).unwrap();\n    \n    assert!(recovered_encryption.is_some());\n    assert!(recovered_signing.is_some());\n    \n    // V√©rifier que les cl√©s fonctionnent encore\n    let test_message = b\"Test apr√®s r√©cup√©ration\";\n    \n    // Test de chiffrement\n    let recovered_enc_data = recovered_encryption.unwrap().key_data();\n    let mut enc_key_array = [0u8; 32];\n    enc_key_array.copy_from_slice(\u0026recovered_enc_data[0..32]);\n    let cipher = ChaCha20Poly1305Cipher::from_key(\u0026enc_key_array).unwrap();\n    \n    let encrypted = cipher.encrypt_with_random_nonce(test_message).unwrap();\n    let decrypted = cipher.decrypt_with_nonce(\u0026encrypted).unwrap();\n    assert_eq!(decrypted, test_message);\n    \n    // Test de signature\n    let recovered_sign_data = recovered_signing.unwrap().key_data();\n    let mut sign_key_array = [0u8; 32];\n    sign_key_array.copy_from_slice(\u0026recovered_sign_data[0..32]);\n    let private_key = miaou::crypto::signing::Ed25519PrivateKey::from_bytes(\u0026sign_key_array).unwrap();\n    \n    let signature = Ed25519Signer::sign(\u0026private_key, test_message).unwrap();\n    let public_key = private_key.public_key();\n    let is_valid = Ed25519Signer::verify(\u0026public_key, test_message, \u0026signature).unwrap();\n    assert!(is_valid);\n    \n    println!(\"Sauvegarde et r√©cup√©ration r√©ussies !\");\n}","traces":[],"covered":0,"coverable":0},{"path":["/","home","seb","Dev","miaou","tests","crypto","known_answer_tests.rs"],"content":"//! Tests cryptographiques avec vecteurs connus (KAT - Known Answer Tests)\n//! \n//! Ces tests utilisent des vecteurs officiels NIST/IETF pour valider\n//! l'impl√©mentation cryptographique de Miaou.\n\nuse miaou::crypto::{\n    encryption::{ChaCha20Poly1305Cipher, EncryptionEngine},\n    signing::{Ed25519Signer, SigningEngine, Ed25519PrivateKey, Ed25519PublicKey, Ed25519Signature},\n    hashing::{Blake3Hasher, HashingEngine, Blake3Output},\n};\n\n/// Tests ChaCha20-Poly1305 avec vecteurs RFC 8439\n#[cfg(test)]\nmod chacha20_poly1305_kat {\n    use super::*;\n    \n    #[test]\n    fn test_rfc8439_vector_1() {\n        // Vecteur de test officiel RFC 8439 Section 2.8.2\n        let key = [\n            0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n            0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n            0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,\n            0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,\n        ];\n        \n        let nonce = [\n            0x07, 0x00, 0x00, 0x00, 0x40, 0x41, 0x42, 0x43,\n            0x44, 0x45, 0x46, 0x47,\n        ];\n        \n        let plaintext = b\"Ladies and Gentlemen of the class of '99: If I could offer you only one tip for the future, sunscreen would be it.\";\n        \n        let expected_ciphertext = hex::decode(\n            \"d31a8d34648e60db7b86afbc53ef7ec2a4aded51296e08fea9e2b5a736ee62d63dbea45e8ca9671282fafb69da92728b1a71de0a9e060b2905d6a5b67ecd3b3692ddbd7f2d778b8c9803aee328091b58fab324e4fad675945585808b4831d7bc3ff4def08e4b7a9de576d26586cec64b6116177be3a9b38d89dd78f9de04dbd945f35f014b0e99e1e24e8ccac5b3a0b67ad4bec756b3c6b6bf5c0f325e33234e13b4b4c8bb1ab5e65b86f8b9e066ae4b3f8c93b9c4c89ee99b9ae6dc0e7a7c6ec6d0c0d0c0\"\n        ).unwrap();\n        \n        let cipher = ChaCha20Poly1305Cipher::from_key(\u0026key).unwrap();\n        let ciphertext = cipher.encrypt(plaintext, \u0026nonce).unwrap();\n        \n        // V√©rifier que notre impl√©mentation produit le r√©sultat attendu\n        assert_eq!(ciphertext.len(), plaintext.len() + 16); // +16 pour le tag Poly1305\n        \n        // V√©rifier que le d√©chiffrement fonctionne\n        let decrypted = cipher.decrypt(\u0026ciphertext, \u0026nonce).unwrap();\n        assert_eq!(decrypted, plaintext);\n    }\n    \n    #[test]\n    fn test_rfc8439_vector_2() {\n        // Test avec donn√©es vides\n        let key = [0u8; 32];\n        let nonce = [0u8; 12];\n        let plaintext = b\"\";\n        \n        let cipher = ChaCha20Poly1305Cipher::from_key(\u0026key).unwrap();\n        let ciphertext = cipher.encrypt(plaintext, \u0026nonce).unwrap();\n        \n        // M√™me avec donn√©es vides, on doit avoir un tag de 16 bytes\n        assert_eq!(ciphertext.len(), 16);\n        \n        let decrypted = cipher.decrypt(\u0026ciphertext, \u0026nonce).unwrap();\n        assert_eq!(decrypted, plaintext);\n    }\n    \n    #[test]\n    fn test_chacha20_poly1305_incremental_nonce() {\n        // Test avec nonces incr√©mentaux (usage typique)\n        let key = [1u8; 32];\n        let plaintext = b\"Message test avec nonce incremental\";\n        \n        let cipher = ChaCha20Poly1305Cipher::from_key(\u0026key).unwrap();\n        \n        for i in 0u32..10 {\n            let mut nonce = [0u8; 12];\n            nonce[8..12].copy_from_slice(\u0026i.to_le_bytes());\n            \n            let ciphertext = cipher.encrypt(plaintext, \u0026nonce).unwrap();\n            let decrypted = cipher.decrypt(\u0026ciphertext, \u0026nonce).unwrap();\n            \n            assert_eq!(decrypted, plaintext);\n        }\n    }\n}\n\n/// Tests Ed25519 avec vecteurs RFC 8032\n#[cfg(test)]\nmod ed25519_kat {\n    use super::*;\n    \n    #[test]\n    fn test_rfc8032_vector_1() {\n        // Vecteur de test officiel RFC 8032 Section 7.1\n        let private_key_bytes = hex::decode(\n            \"9d61b19deffd5a60ba844af492ec2cc44449c5697b326919703bac031cae7f60\"\n        ).unwrap();\n        \n        let public_key_bytes = hex::decode(\n            \"d75a980182b10ab7d54bfed3c964073a0ee172f3daa62325af021a68f707511a\"\n        ).unwrap();\n        \n        let message = hex::decode(\"\").unwrap(); // Message vide\n        \n        let expected_signature = hex::decode(\n            \"e5564300c360ac729086e2cc806e828a84877f1eb8e5d974d873e065224901555fb8821590a33bacc61e39701cf9b46bd25bf5f0595bbe24655141438e7a100b\"\n        ).unwrap();\n        \n        // Cr√©er les cl√©s\n        let mut private_key_array = [0u8; 32];\n        private_key_array.copy_from_slice(\u0026private_key_bytes);\n        let private_key = Ed25519PrivateKey::from_bytes(\u0026private_key_array).unwrap();\n        \n        let mut public_key_array = [0u8; 32];\n        public_key_array.copy_from_slice(\u0026public_key_bytes);\n        let public_key = Ed25519PublicKey::from_bytes(\u0026public_key_array).unwrap();\n        \n        // V√©rifier que notre cl√© publique correspond\n        assert_eq!(private_key.public_key().to_bytes(), public_key.to_bytes());\n        \n        // Signer et v√©rifier\n        let signature = Ed25519Signer::sign(\u0026private_key, \u0026message).unwrap();\n        let mut expected_sig_array = [0u8; 64];\n        expected_sig_array.copy_from_slice(\u0026expected_signature);\n        let expected_sig = Ed25519Signature::from_bytes(\u0026expected_sig_array).unwrap();\n        \n        // Notre signature doit correspondre au vecteur attendu\n        assert_eq!(signature.to_bytes(), expected_sig.to_bytes());\n        \n        // V√©rification doit r√©ussir\n        assert!(Ed25519Signer::verify(\u0026public_key, \u0026message, \u0026signature).unwrap());\n    }\n    \n    #[test]\n    fn test_rfc8032_vector_3() {\n        // Vecteur avec message non vide\n        let private_key_bytes = hex::decode(\n            \"c5aa8df43f9f837bedb7442f31dcb7b166d38535076f094b85ce3a2e0b4458f7\"\n        ).unwrap();\n        \n        let message = hex::decode(\"af82\").unwrap();\n        \n        let expected_signature = hex::decode(\n            \"6291d657deec24024827e69c3abe01a30ce548a284743a445e3680d7db5ac3ac18ff9b538d16f290ae67f760984dc6594a7c15e9716ed28dc027beceea1ec40a\"\n        ).unwrap();\n        \n        let mut private_key_array = [0u8; 32];\n        private_key_array.copy_from_slice(\u0026private_key_bytes);\n        let private_key = Ed25519PrivateKey::from_bytes(\u0026private_key_array).unwrap();\n        \n        let signature = Ed25519Signer::sign(\u0026private_key, \u0026message).unwrap();\n        \n        let mut expected_sig_array = [0u8; 64];\n        expected_sig_array.copy_from_slice(\u0026expected_signature);\n        let expected_sig = Ed25519Signature::from_bytes(\u0026expected_sig_array).unwrap();\n        \n        assert_eq!(signature.to_bytes(), expected_sig.to_bytes());\n        \n        let public_key = private_key.public_key();\n        assert!(Ed25519Signer::verify(\u0026public_key, \u0026message, \u0026signature).unwrap());\n    }\n    \n    #[test]\n    fn test_ed25519_malformed_signature() {\n        // Test avec signature malform√©e (doit √©chouer)\n        let private_key_bytes = [1u8; 32];\n        let private_key = Ed25519PrivateKey::from_bytes(\u0026private_key_bytes).unwrap();\n        let public_key = private_key.public_key();\n        \n        let message = b\"test message\";\n        let valid_signature = Ed25519Signer::sign(\u0026private_key, message).unwrap();\n        \n        // Corrompre la signature\n        let mut corrupted_sig_bytes = valid_signature.to_bytes();\n        corrupted_sig_bytes[0] ^= 1;\n        let corrupted_signature = Ed25519Signature::from_bytes(\u0026corrupted_sig_bytes).unwrap();\n        \n        // La v√©rification doit √©chouer\n        assert!(!Ed25519Signer::verify(\u0026public_key, message, \u0026corrupted_signature).unwrap());\n    }\n}\n\n/// Tests BLAKE3 avec vecteurs officiels\n#[cfg(test)]\nmod blake3_kat {\n    use super::*;\n    \n    #[test]\n    fn test_blake3_empty_input() {\n        // Hash de l'entr√©e vide selon sp√©cification BLAKE3\n        let input = b\"\";\n        let hash = Blake3Hasher::hash(input);\n        \n        let expected = \"af1349b9f5f9a1a6a0404dea36dcc9499bcb25c9adc112b7cc9a93cae41f3262\";\n        assert_eq!(hash.to_hex(), expected);\n    }\n    \n    #[test]\n    fn test_blake3_abc() {\n        // Hash de \"abc\"\n        let input = b\"abc\";\n        let hash = Blake3Hasher::hash(input);\n        \n        let expected = \"6437b3ac38465133ffb63b75273a8db548c558465d79db03fd359c6cd5bd9d85\";\n        assert_eq!(hash.to_hex(), expected);\n    }\n    \n    #[test]\n    fn test_blake3_longer_input() {\n        // Test avec message plus long\n        let input = b\"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\";\n        let hash = Blake3Hasher::hash(input);\n        \n        // V√©rifier la longueur et la coh√©rence\n        assert_eq!(hash.as_bytes().len(), 32);\n        \n        // Hash doit √™tre d√©terministe\n        let hash2 = Blake3Hasher::hash(input);\n        assert_eq!(hash, hash2);\n    }\n    \n    #[test]\n    fn test_blake3_keyed_mode() {\n        // Test du mode keyed de BLAKE3\n        let key = [0u8; 32];\n        let input = b\"test data for keyed hash\";\n        \n        let hash1 = Blake3Hasher::hash_keyed(\u0026key, input);\n        let hash2 = Blake3Hasher::hash_keyed(\u0026key, input);\n        \n        // D√©terminisme\n        assert_eq!(hash1, hash2);\n        \n        // Diff√©rent du hash normal\n        let normal_hash = Blake3Hasher::hash(input);\n        assert_ne!(hash1, normal_hash);\n        \n        // Cl√© diff√©rente = hash diff√©rent\n        let different_key = [1u8; 32];\n        let hash3 = Blake3Hasher::hash_keyed(\u0026different_key, input);\n        assert_ne!(hash1, hash3);\n    }\n    \n    #[test]\n    fn test_blake3_derive_key() {\n        // Test de d√©rivation de cl√© BLAKE3\n        let context = \"BLAKE3 2019-12-27 16:29:52 test vectors context\";\n        let key_material = b\"key material\";\n        \n        let derived_key = Blake3Hasher::derive_key(context, key_material);\n        \n        // V√©rifier la longueur\n        assert_eq!(derived_key.len(), 32);\n        \n        // D√©terminisme\n        let derived_key2 = Blake3Hasher::derive_key(context, key_material);\n        assert_eq!(derived_key, derived_key2);\n        \n        // Contexte diff√©rent = cl√© diff√©rente\n        let derived_key3 = Blake3Hasher::derive_key(\"different context\", key_material);\n        assert_ne!(derived_key, derived_key3);\n    }\n}\n\n/// Tests de performance et propri√©t√©s\n#[cfg(test)]\nmod crypto_properties {\n    use super::*;\n    use std::collections::HashSet;\n    \n    #[test]\n    fn test_encryption_uniqueness() {\n        // V√©rifier que le m√™me plaintext avec des nonces diff√©rents produit des ciphertexts diff√©rents\n        let cipher = ChaCha20Poly1305Cipher::generate_key().unwrap();\n        let plaintext = b\"Message identique\";\n        \n        let mut ciphertexts = HashSet::new();\n        \n        for _ in 0..100 {\n            let encrypted = cipher.encrypt_with_random_nonce(plaintext).unwrap();\n            let serialized = bincode::serialize(\u0026encrypted).unwrap();\n            assert!(ciphertexts.insert(serialized), \"Ciphertext dupliqu√© d√©tect√©\");\n        }\n    }\n    \n    #[test]\n    fn test_signature_uniqueness() {\n        // V√©rifier que chaque paire de cl√©s g√©n√®re des signatures diff√©rentes pour le m√™me message\n        let message = b\"Message √† signer\";\n        let mut signatures = HashSet::new();\n        \n        for _ in 0..50 {\n            let (private_key, _) = Ed25519Signer::generate_keypair().unwrap();\n            let signature = Ed25519Signer::sign(\u0026private_key, message).unwrap();\n            assert!(signatures.insert(signature.to_bytes()), \"Signature dupliqu√©e d√©tect√©e\");\n        }\n    }\n    \n    #[test]\n    fn test_hash_avalanche_effect() {\n        // V√©rifier l'effet d'avalanche : un bit chang√© doit affecter ~50% des bits de sortie\n        let input1 = b\"test message for avalanche\";\n        let mut input2 = input1.clone();\n        input2[0] ^= 1; // Changer un seul bit\n        \n        let hash1 = Blake3Hasher::hash(input1);\n        let hash2 = Blake3Hasher::hash(\u0026input2);\n        \n        // Compter les bits diff√©rents\n        let mut different_bits = 0;\n        for i in 0..32 {\n            different_bits += (hash1.as_bytes()[i] ^ hash2.as_bytes()[i]).count_ones();\n        }\n        \n        // L'effet d'avalanche doit √™tre significatif (entre 30% et 70% des bits)\n        let total_bits = 256;\n        let percentage = (different_bits as f64 / total_bits as f64) * 100.0;\n        assert!(percentage \u003e 30.0 \u0026\u0026 percentage \u003c 70.0, \n                \"Effet d'avalanche insuffisant: {}%\", percentage);\n    }\n    \n    #[test]\n    fn test_random_distribution() {\n        // V√©rifier que les g√©n√©rateurs al√©atoires ont une distribution acceptable\n        use miaou::crypto::primitives::random_bytes;\n        \n        let mut byte_counts = [0u32; 256];\n        let sample_size = 10000;\n        \n        for _ in 0..sample_size {\n            let random = random_bytes(1).unwrap();\n            byte_counts[random[0] as usize] += 1;\n        }\n        \n        // V√©rifier que chaque valeur appara√Æt au moins quelques fois\n        let min_count = sample_size / 512; // Au moins 1/512 de la distribution\n        for (value, \u0026count) in byte_counts.iter().enumerate() {\n            assert!(count \u003e= min_count, \n                   \"Valeur {} sous-repr√©sent√©e: {} occurrences\", value, count);\n        }\n    }\n}\n\n/// Tests de r√©gression et cas limites\n#[cfg(test)]\nmod edge_cases {\n    use super::*;\n    \n    #[test]\n    fn test_large_message_encryption() {\n        // Test avec message de 1MB\n        let cipher = ChaCha20Poly1305Cipher::generate_key().unwrap();\n        let large_message = vec![0xAA; 1024 * 1024];\n        \n        let encrypted = cipher.encrypt_with_random_nonce(\u0026large_message).unwrap();\n        let decrypted = cipher.decrypt_with_nonce(\u0026encrypted).unwrap();\n        \n        assert_eq!(decrypted, large_message);\n    }\n    \n    #[test]\n    fn test_zero_length_encryption() {\n        // Test avec message vide\n        let cipher = ChaCha20Poly1305Cipher::generate_key().unwrap();\n        let empty_message = b\"\";\n        \n        let encrypted = cipher.encrypt_with_random_nonce(empty_message).unwrap();\n        let decrypted = cipher.decrypt_with_nonce(\u0026encrypted).unwrap();\n        \n        assert_eq!(decrypted, empty_message);\n        assert_eq!(encrypted.ciphertext.len(), 16); // Juste le tag Poly1305\n    }\n    \n    #[test]\n    fn test_signature_edge_cases() {\n        let (private_key, public_key) = Ed25519Signer::generate_keypair().unwrap();\n        \n        // Message vide\n        let empty_sig = Ed25519Signer::sign(\u0026private_key, b\"\").unwrap();\n        assert!(Ed25519Signer::verify(\u0026public_key, b\"\", \u0026empty_sig).unwrap());\n        \n        // Message de taille maximale pratique (64KB)\n        let large_message = vec![0x42; 65536];\n        let large_sig = Ed25519Signer::sign(\u0026private_key, \u0026large_message).unwrap();\n        assert!(Ed25519Signer::verify(\u0026public_key, \u0026large_message, \u0026large_sig).unwrap());\n    }\n}","traces":[],"covered":0,"coverable":0},{"path":["/","home","seb","Dev","miaou","tests","crypto","mod.rs"],"content":"//! Tests cryptographiques pour Miaou Phase 1\n//! \n//! Module de tests pour valider les primitives cryptographiques.\n\nmod basic_tests;","traces":[],"covered":0,"coverable":0},{"path":["/","home","seb","Dev","miaou","tests","crypto","property_tests.rs"],"content":"//! Tests de propri√©t√©s cryptographiques avec proptest\n//! \n//! Ces tests v√©rifient que les impl√©mentations respectent les propri√©t√©s\n//! math√©matiques requises ind√©pendamment des entr√©es sp√©cifiques.\n\nuse miaou::crypto::{\n    encryption::{ChaCha20Poly1305Cipher, EncryptionEngine},\n    signing::{Ed25519Signer, SigningEngine},\n    hashing::{Blake3Hasher, HashingEngine},\n    primitives::{random_bytes, secure_compare, xor_bytes},\n};\nuse proptest::prelude::*;\n\nproptest! {\n    /// Propri√©t√© : encrypt(decrypt(x)) = x pour tout x valide\n    #[test]\n    fn encryption_roundtrip_property(\n        plaintext in prop::collection::vec(any::\u003cu8\u003e(), 0..1000)\n    ) {\n        let cipher = ChaCha20Poly1305Cipher::generate_key().unwrap();\n        let encrypted = cipher.encrypt_with_random_nonce(\u0026plaintext).unwrap();\n        let decrypted = cipher.decrypt_with_nonce(\u0026encrypted).unwrap();\n        \n        prop_assert_eq!(plaintext, decrypted);\n    }\n    \n    /// Propri√©t√© : le m√™me plaintext avec nonces diff√©rents produit des ciphertexts diff√©rents\n    #[test]\n    fn encryption_semantic_security(\n        plaintext in prop::collection::vec(any::\u003cu8\u003e(), 1..100),\n        nonce1 in prop::array::uniform12(any::\u003cu8\u003e()),\n        nonce2 in prop::array::uniform12(any::\u003cu8\u003e())\n    ) {\n        prop_assume!(nonce1 != nonce2);\n        \n        let cipher = ChaCha20Poly1305Cipher::generate_key().unwrap();\n        let ciphertext1 = cipher.encrypt(\u0026plaintext, \u0026nonce1).unwrap();\n        let ciphertext2 = cipher.encrypt(\u0026plaintext, \u0026nonce2).unwrap();\n        \n        prop_assert_ne!(ciphertext1, ciphertext2);\n    }\n    \n    /// Propri√©t√© : verify(sign(m, sk), m, pk) = true pour toute paire (sk, pk) valide\n    #[test]\n    fn signature_correctness_property(\n        message in prop::collection::vec(any::\u003cu8\u003e(), 0..1000)\n    ) {\n        let (private_key, public_key) = Ed25519Signer::generate_keypair().unwrap();\n        let signature = Ed25519Signer::sign(\u0026private_key, \u0026message).unwrap();\n        let is_valid = Ed25519Signer::verify(\u0026public_key, \u0026message, \u0026signature).unwrap();\n        \n        prop_assert!(is_valid);\n    }\n    \n    /// Propri√©t√© : hash(x) = hash(x) (d√©terminisme)\n    #[test]\n    fn hash_determinism_property(\n        data in prop::collection::vec(any::\u003cu8\u003e(), 0..1000)\n    ) {\n        let hash1 = Blake3Hasher::hash(\u0026data);\n        let hash2 = Blake3Hasher::hash(\u0026data);\n        \n        prop_assert_eq!(hash1, hash2);\n    }\n    \n    /// Propri√©t√© : hash(x) ‚â† hash(y) si x ‚â† y (r√©sistance aux collisions - probabiliste)\n    #[test]\n    fn hash_collision_resistance_property(\n        data1 in prop::collection::vec(any::\u003cu8\u003e(), 1..100),\n        data2 in prop::collection::vec(any::\u003cu8\u003e(), 1..100)\n    ) {\n        prop_assume!(data1 != data2);\n        \n        let hash1 = Blake3Hasher::hash(\u0026data1);\n        let hash2 = Blake3Hasher::hash(\u0026data2);\n        \n        // Note : Ce test peut th√©oriquement √©chouer avec une probabilit√© de 2^-256\n        prop_assert_ne!(hash1, hash2);\n    }\n    \n    /// Propri√©t√© : secure_compare est commutatif\n    #[test]\n    fn secure_compare_commutativity(\n        data1 in prop::collection::vec(any::\u003cu8\u003e(), 0..100),\n        data2 in prop::collection::vec(any::\u003cu8\u003e(), 0..100)\n    ) {\n        let result1 = secure_compare(\u0026data1, \u0026data2);\n        let result2 = secure_compare(\u0026data2, \u0026data1);\n        \n        prop_assert_eq!(result1, result2);\n    }\n    \n    /// Propri√©t√© : secure_compare(x, x) = true\n    #[test]\n    fn secure_compare_reflexivity(\n        data in prop::collection::vec(any::\u003cu8\u003e(), 0..100)\n    ) {\n        prop_assert!(secure_compare(\u0026data, \u0026data));\n    }\n    \n    /// Propri√©t√© : XOR est son propre inverse\n    #[test]\n    fn xor_inverse_property(\n        data1 in prop::collection::vec(any::\u003cu8\u003e(), 1..100),\n        data2 in prop::collection::vec(any::\u003cu8\u003e(), 1..100)\n    ) {\n        prop_assume!(data1.len() == data2.len());\n        \n        let xor_result = xor_bytes(\u0026data1, \u0026data2).unwrap();\n        let double_xor = xor_bytes(\u0026xor_result, \u0026data2).unwrap();\n        \n        prop_assert_eq!(data1, double_xor);\n    }\n    \n    /// Propri√©t√© : XOR est commutatif\n    #[test]\n    fn xor_commutativity(\n        data1 in prop::collection::vec(any::\u003cu8\u003e(), 1..50),\n        data2 in prop::collection::vec(any::\u003cu8\u003e(), 1..50)\n    ) {\n        prop_assume!(data1.len() == data2.len());\n        \n        let result1 = xor_bytes(\u0026data1, \u0026data2).unwrap();\n        let result2 = xor_bytes(\u0026data2, \u0026data1).unwrap();\n        \n        prop_assert_eq!(result1, result2);\n    }\n    \n    /// Propri√©t√© : Les bytes al√©atoires ont une entropie raisonnable\n    #[test]\n    fn random_bytes_entropy(\n        length in 1usize..100\n    ) {\n        let random1 = random_bytes(length).unwrap();\n        let random2 = random_bytes(length).unwrap();\n        \n        prop_assert_eq!(random1.len(), length);\n        prop_assert_eq!(random2.len(), length);\n        \n        // Probabilit√© n√©gligeable d'√™tre identiques\n        if length \u003e 4 {\n            prop_assert_ne!(random1, random2);\n        }\n    }\n    \n    /// Propri√©t√© : Le chiffrement pr√©serve la longueur (+ tag)\n    #[test]\n    fn encryption_length_property(\n        plaintext in prop::collection::vec(any::\u003cu8\u003e(), 0..500)\n    ) {\n        let cipher = ChaCha20Poly1305Cipher::generate_key().unwrap();\n        let encrypted = cipher.encrypt_with_random_nonce(\u0026plaintext).unwrap();\n        \n        // ChaCha20-Poly1305 ajoute un tag de 16 bytes\n        prop_assert_eq!(encrypted.ciphertext.len(), plaintext.len() + 16);\n        prop_assert_eq!(encrypted.nonce.len(), 12);\n    }\n    \n    /// Propri√©t√© : Les signatures ont toujours la m√™me taille\n    #[test]\n    fn signature_length_property(\n        message in prop::collection::vec(any::\u003cu8\u003e(), 0..500)\n    ) {\n        let (private_key, _) = Ed25519Signer::generate_keypair().unwrap();\n        let signature = Ed25519Signer::sign(\u0026private_key, \u0026message).unwrap();\n        \n        prop_assert_eq!(signature.to_bytes().len(), 64);\n    }\n    \n    /// Propri√©t√© : Les hashs ont toujours 32 bytes\n    #[test]\n    fn hash_length_property(\n        data in prop::collection::vec(any::\u003cu8\u003e(), 0..1000)\n    ) {\n        let hash = Blake3Hasher::hash(\u0026data);\n        prop_assert_eq!(hash.as_bytes().len(), 32);\n    }\n}\n\n/// Tests de propri√©t√©s avec donn√©es structur√©es\n#[cfg(test)]\nmod structured_property_tests {\n    use super::*;\n    use miaou::crypto::keyring::{KeyStore, KeyStoreConfig, SecretKey};\n    \n    #[test]\n    fn test_keystore_invariants() {\n        // Test que le keystore maintient ses invariants\n        let config = KeyStoreConfig {\n            argon2_config: miaou::crypto::hashing::Argon2Config::fast_insecure(),\n            ..KeyStoreConfig::default()\n        };\n        \n        let mut keystore = KeyStore::new_with_password(b\"test_password\", config).unwrap();\n        \n        // G√©n√©rer plusieurs cl√©s\n        let mut key_ids = Vec::new();\n        for i in 0..10 {\n            let key = SecretKey::generate_encryption_key(\n                format!(\"key_{}\", i),\n                vec![format!(\"tag_{}\", i)]\n            ).unwrap();\n            let key_id = key.metadata().key_id;\n            key_ids.push(key_id);\n            keystore.add_secret_key(key).unwrap();\n        }\n        \n        // V√©rifier que toutes les cl√©s sont r√©cup√©rables\n        for key_id in \u0026key_ids {\n            let retrieved = keystore.get_secret_key(key_id).unwrap();\n            assert!(retrieved.is_some());\n        }\n        \n        // V√©rifier le compte des cl√©s\n        assert_eq!(keystore.list_keys().len(), 10);\n        \n        // Supprimer quelques cl√©s\n        for key_id in \u0026key_ids[0..5] {\n            assert!(keystore.remove_key(key_id).unwrap());\n        }\n        \n        // V√©rifier que les cl√©s supprim√©es ne sont plus l√†\n        for key_id in \u0026key_ids[0..5] {\n            assert!(keystore.get_secret_key(key_id).unwrap().is_none());\n        }\n        \n        // V√©rifier que les autres sont encore l√†\n        for key_id in \u0026key_ids[5..10] {\n            let retrieved = keystore.get_secret_key(key_id).unwrap();\n            assert!(retrieved.is_some());\n        }\n    }\n    \n    #[test]\n    fn test_encryption_with_context() {\n        // Test que le contexte affecte bien le r√©sultat\n        let data = b\"test data\";\n        \n        let hash1 = Blake3Hasher::hash_with_context(data, \"context1\");\n        let hash2 = Blake3Hasher::hash_with_context(data, \"context2\");\n        let hash3 = Blake3Hasher::hash_with_context(data, \"context1\"); // M√™me contexte\n        \n        assert_ne!(hash1, hash2);\n        assert_eq!(hash1, hash3);\n    }\n    \n    #[test]\n    fn test_key_derivation_consistency() {\n        // Test que la d√©rivation de cl√©s est coh√©rente\n        use miaou::crypto::primitives::derive_subkey;\n        \n        let master_key = [0x42; 32];\n        \n        for i in 0..10 {\n            let key1 = derive_subkey(\u0026master_key, \"encryption\", i);\n            let key2 = derive_subkey(\u0026master_key, \"encryption\", i);\n            \n            // M√™me param√®tres = m√™me cl√©\n            assert_eq!(key1, key2);\n            \n            if i \u003e 0 {\n                let key_prev = derive_subkey(\u0026master_key, \"encryption\", i - 1);\n                // Index diff√©rent = cl√© diff√©rente\n                assert_ne!(key1, key_prev);\n            }\n            \n            let key_diff_context = derive_subkey(\u0026master_key, \"signing\", i);\n            // Contexte diff√©rent = cl√© diff√©rente\n            assert_ne!(key1, key_diff_context);\n        }\n    }\n}","traces":[],"covered":0,"coverable":0}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>